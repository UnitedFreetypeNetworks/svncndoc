<chapter xml:id="svn.reposadmin">
    <info>
      <title>版本库管理</title>
    </info>
    <para>Subversion版本库是保存任意数量项目版本化数据的中央仓库，因此，版本库成为管理员关注的对象。版本库的维护一般并不需要太多的关注，但为了避免一些潜在的问题和解决一些实际问题，理解怎样适当的配置和维护还是非常重要的。</para>
    <para>在这一章里，我们将讨论如何建立和配置一个Subversion版本库，还会讨论版本库的维护，包括<command>svnlook</command>和<command>svnadmin</command>工具的使用实例。我们将说明一些常见的问题和错误，并提供一些安排版本库数据的建议。</para>
    <para>如果您只是以普通用户的身份访问版本库对数据进行版本控制(就是说通过Subversion客户端)，您完全可以跳过本章。但是如果您已经是或打算成为Subversion版本库的管理员，<footnote><para>这可能听起来很崇高， 但我们所指的只是那些对管理别人工作拷贝数据之外的神秘领域感兴趣的人。</para></footnote>您一定要关注一下本章的内容。</para>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.reposadmin.basics">
      <info>
        <title>Subversion 版本库的定义</title>
      </info>
      <para>在进入版本库管理这块宽泛的主题之前，让我们进一步确定一下版本库的定义，它是怎样工作的？让人有什么感觉？它希望茶是热的还是冰的，加糖或柠檬吗？作为一名管理员，你应该既能够从物理具体细节的视角－版本库如何响应一个非Subversion的工具，也能够从逻辑视角－数据在版本库中如何展示。</para>
      <para>通过典型的文件浏览器应用程序或命令行为基础的文件系统浏览工具查看，Subversion版本库只是另一个目录。也有一些子目录下包含可读的数据文件，也有一些子目录包含不可读的数据文件。Subversion设计的其他地方，模块化被认真考虑，等级化的组织可以减少混乱，所以脱离细节粗略看一下典型的版本库可以有效地揭示版本库的基本组件。</para>
      <screen>
$ ls repos
conf/  dav/  db/  format  hooks/  locks/  README.txt
</screen>
      <para>下面是一个你看到列出目录的快速总揽。(不要因为术语陷入困境―这些组件的细节介绍可以从本章或其他章节找到。)</para>
      <variablelist>
        <varlistentry>
          <term>conf</term>
          <listitem>
            <para>一个存储配置文件的目录。</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>dav</term>
          <listitem>
            <para>一个为mod_dav_svn模块存储自己数据的目录。</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>db</term>
          <listitem>
            <para>你的版本化数据的数据存储方式。</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>format</term>
          <listitem>
            <para>包含了一个用来表示版本库布局版本号整数的文件。</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>hooks</term>
          <listitem>
            <para>一个存储钩子脚本模版的目录(还有钩子脚本本身， 如果你安装了的话)。</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>locks</term>
          <listitem>
            <para>一个存储Subversion版本库锁定文件的目录，被用来追踪对版本库的访问。</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>README.txt</term>
          <listitem>
            <para>这个文件只是用来告诉它的阅读者，他现在看的是 Subversion 的版本库。</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>当然，当通过Subversion库访问时，这些平常的文件和目录立刻变成了虚拟文件系统的实现，由自定义的事件触发完成。这个文件系统的目录和文件都有自己的概念，与真实的文件系统(例如NTFS、FAT32、ext3等等)很类似，但是也有特别的地方―它在修订版本间锁定目录和文件，保持你的所有修改可以永远访问的，这是你的所有版本化数据存放的地方。</para>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.reposadmin.planning">
      <info>
        <title>版本库开发策略</title>
      </info>
      <para>因为Subversion版本库本身和所依赖技术设计的简单性，创建和配置版本库是一件相对直接的任务。需要做一些的预备决定，但是设置Subversion版本库的实际工作非常直接，在做过几次之后就会发现不必费太多心思去做这件事。</para>
      <para>下面是一些你需要预先考虑的事情：</para>
      <itemizedlist>
        <listitem>
          <para>你的版本库将要存放什么数据(或多个版本库)，这些数据如何组织？</para>
        </listitem>
        <listitem>
          <para>版本库存放在哪里，如何被访问？</para>
        </listitem>
        <listitem>
          <para>你需要什么类型的访问控制和版本库事件报告？</para>
        </listitem>
        <listitem>
          <para>你希望使用哪种数据存储方式？</para>
        </listitem>
      </itemizedlist>
      <para>在本节，我们要尝试帮你回答这些问题。</para>
      <!-- =============================================================== -->
      <section xml:id="svn.reposadmin.projects.chooselayout">
        <info>
          <title>规划你的版本库结构</title>
        </info>
        <para>在Subversion版本库中，移动版本化的文件和目录不会损失任何信息，甚至也可以将版本库的的一组数据无损历史的移植到另一个版本库，但是这样一来那些经常访问版本库并且以为文件总是在同一个路径的用户可能会受到干扰。为将来着想，最好预先对你的版本库布局进行规划。以一种高效的<quote>布局</quote>开始项目，可以减少将来很多不必要的麻烦。</para>
        <para>假如你是一个版本库管理员，需要向多个项目提供版本控制支持。那么，你首先要决定的是，用一个版本库支持多个项目，还是为每个项目建立一个版本库，还是两种方法的混合方式。</para>
        <para>使用一个版本库支持多个项目有很多好处，最明显的无过于不需要维护好几个版本库。单一版本库就意味着只有一个钩子程序，只需要备份一个数据库，当Subversion进行不兼容升级时，只需要一次转储和装载操作，等等。还有，你可以轻易的在项目之间移动数据，还不会损失任何历史版本信息。</para>
        <para>单一版本库的缺点是，不同的项目通常都有不同的版本库触发事件需求，例如需要发送提交通知邮件到不同的邮件列表，需要不同的鉴定提交是否合法的定义。这些都不是不可逾越的问题，当然―之需要你的钩子程序能够察看版本库的布局，而不是假定整个版本库与同一组人关联。还有，别忘了Subversion的修订版本号是针对整个版本库的，这些号码没有任何魔力。即使最近没有对某个项目作出修改，版本库的修订版本号还是会因为其它项目的修改而不停的提升，许多人并不喜欢这样的事实。<footnote><para>无论是在忽略情况下建立或很少考虑过如何产生正确的软件开发矩阵，都不应该愚蠢的担心全局的修订版本号码，这不应该成为安排项目和版本库的理由。</para></footnote></para>
        <para>可以采用折中的办法。比如，可以把许多项目按照彼此之间的关联程度划分为几个组合，然后为每一个项目组合建立一个版本库。这样，在相关项目之间共享数据依旧很简单，而如果修订版本号有了变化，至少开发人员知道，改变的东西多少和他们有些关系。</para>
        <para>在决定了如何用版本库组织项目以后，就该决定如何设置版本库的目录层次了。由于Subversion按普通的目录复制方式完成分支和标签操作(参见<xref linkend="svn.branchmerge"/>)，Subversion社区建议为每一个项目建立一个<firstterm>项目根目录</firstterm>―项目的<quote>顶级</quote>目录―然后在根目录下建立三个子目录：<filename>trunk</filename>，保存项目的开发主线；<filename>branches</filename>，保存项目的各种开发分支；<filename>tags</filename>，保存项目的标签，也就是创建后永远不会修改的分支(可能会删除)。 <footnote><para><filename>trunk</filename>、<filename>tags</filename>和<filename>branches</filename>可以使用<quote>TTB目录</quote>来表示。</para></footnote></para>
        <para>举个例子，一个版本库可能会有如下的布局：</para>
        <screen>
/
   calc/
      trunk/
      tags/
      branches/
   calendar/
      trunk/
      tags/
      branches/
   spreadsheet/
      trunk/
      tags/
      branches/
   …
</screen>
        <para>项目在版本库中的根目录地址并不重要。如果每个版本库中只有一个项目，那么就可以认为项目的根目录就是版本库的根目录。如果版本库中包含多个项目，那么可以将这些项目划分成不同的组合(按照项目的目标或者是否需要共享代码甚至是字母顺序)保存在不同子目录中，下面的例子给出了一个类似的布局：</para>
        <screen>
/
   utils/
      calc/
         trunk/
         tags/
         branches/
      calendar/
         trunk/
         tags/
         branches/
      …
   office/
      spreadsheet/
         trunk/
         tags/
         branches/
      …
</screen>
        <para>按照你认为合适的方式安排版本库的布局，Subversion自身并不强制或者偏好某一种布局形式，对于Subversion来说，目录就是目录。最后，在设计版本库布局的时候，不要忘了考虑一下项目参与者们的意见。</para>
        <para>为了完整性，我们需要提一下另一种常见的布局，在这种布局中<filename>trunk</filename>、<filename>tags</filename>和<filename>branches</filename>都在根目录下，而你的项目在各个子目录下，例如：</para>
        <screen>
/
   trunk/
      calc/
      calendar/
      spreadsheet/
      …
   tags/
      calc/
      calendar/
      spreadsheet/
      …
   branches/
      calc/
      calendar/
      spreadsheet/
      …
</screen>
        <para>这种布局没有什么不对的，但是它只是或不是你的用户的直觉。特别是在大的，有许多用户的多项目情况下，用户可能只熟悉版本库中一两个项目。但是项目作为分支的方式可以鼓励项目的个性和将注意力集中在一个单独的实体。尽管这也是一个社会问题，因为实践的原因，我们很愿意对安排提出一些建议―当一个项目的历史都在一个目录里时，很容易查询(或是修改、移植)单个项目的历史―过去、现在、标签和分支―单独为那个项目。</para>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.reposadmin.basics.hosting">
        <info>
          <title>决定在哪里与如何部署你的版本库</title>
        </info>
        <para>在创建Subversion版本库之前，一个明显的问题是所有的东西要存放在什么地方，这与很多问题关联，包括版本库如何访问(通过Subversion服务器或直接访问)、被谁访问(防火墙后的用户或全部是在Internet上)、你将围绕Subversion提供哪些服务(版本库浏览接口，e-mail为基础的提交通知等)、你的数据备份策略，等等。</para>
        <para>我们在<xref linkend="svn.serverconfig"/>覆盖了服务器的选择和配置，我们也提供一些可能会使你必须决定使用某种服务器的问题的答案。例如，特定的部署策略可能会需要从多个计算机通过远程文件系统访问版本库，这个情况下(下一小节会读到)要求你不能选择一种版本库后端数据存储方式，因为只有一种后端在这种场景下可以工作。</para>
        <para>列出所有的Subversion可能的部署方法是不可能的，超出了本书的范围，我们只是简单的鼓励你使用这部分内容和参考材料验证你的想法，并预先计划。</para>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.reposadmin.basics.backends">
        <info>
          <title>选择数据存储格式</title>
        </info>
        <para>在Subversion1.1中，版本库中有两种数据存储方式―通常叫做<quote>后端</quote>或其他容易混淆的名字，如<quote>(版本化的)文件系统</quote>，每一个版本库都会使用一种。一种是在Berkeley DB数据库中存储数据，我们称之为<quote>BDB后端</quote>；另一种是使用普通的文件，自定义格式，Subversion开发者根据习惯称之为<firstterm>FSFS</firstterm><footnote><para>通常读作<quote>fuzz-fuzz</quote>, 如果Jack Repenning说起这个问题。(本书，假定读者认为是<quote>eff-ess-eff-ess</quote>。)</para></footnote> ―一种使用本地操作系统文件存储数据的版本化文件系统直接实现―而不是通过某个数据库层或其他抽象层来保存数据。</para>
        <para><xref linkend="svn.reposadmin.basics.backends.tbl-1"/>从总体上比较了Berkeley DB和FSFS版本库。</para>
        <table xml:id="svn.reposadmin.basics.backends.tbl-1">
          <info>
            <title>版本库数据存储对照表</title>
          </info>
          <tgroup cols="4">
            <thead>
              <row>
                <entry>分类</entry>
                <entry>特性</entry>
                <entry>Berkeley DB</entry>
                <entry>FSFS</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry morerows="1">可靠性</entry>
                <entry>数据完整性</entry>
                <entry>当正确部署，非常可靠；Berkeley DB 4.4支持自动恢复。</entry>
                <entry>较老的版本较少被描述，但是有数据毁坏bug。</entry>
              </row>
              <row>
                <entry>对操作中断的敏感</entry>
                <entry>很敏感；系统崩溃或者权限问题会导致数据库<quote>楔住</quote>停止工作，需要日志式的恢复过程。</entry>
                <entry>十分敏感。</entry>
              </row>
              <row>
                <entry morerows="3">可用性</entry>
                <entry>可只读加载</entry>
                <entry>否</entry>
                <entry>是</entry>
              </row>
              <row>
                <entry>存储平台无关</entry>
                <entry>否</entry>
                <entry>是</entry>
              </row>
              <row>
                <entry>可从网络文件系统访问</entry>
                <entry>通常，不。</entry>
                <entry>是</entry>
              </row>
              <row>
                <entry>组访问权处理</entry>
                <entry>对于用户的umask设置十分敏感；最好只由一个用户访问。</entry>
                <entry>对umask设置不敏感。</entry>
              </row>
              <row>
                <entry morerows="2">伸缩性</entry>
                <entry>版本库磁盘使用情况</entry>
                <entry>较大(特别是没有清除日志时)。</entry>
                <entry>较小。</entry>
              </row>
              <row>
                <entry>修订版本树的数量</entry>
                <entry>数据库；没有问题。</entry>
                <entry>许多古老的本地文件系统在处理单一目录包含上千个条目时出现问题。</entry>
              </row>
              <row>
                <entry>有很多文件的目录</entry>
                <entry>较慢。</entry>
                <entry>较快。</entry>
              </row>
              <row>
                <entry morerows="1">性能</entry>
                <entry>检出最新的代码</entry>
                <entry>没有有意义的区别。</entry>
                <entry>没有有意义的区别。</entry>
              </row>
              <row>
                <entry>大的提交</entry>
                <entry>整体较慢，但是在整个提交周期中消耗被分摊。</entry>
                <entry>较快，但是最后较长的延时可能会导致客户端操作超时。</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <para>两种后端都有优点和缺点，没有一种更加<quote>正式</quote>，尽管新的FSFS在Subversion1.2成为缺省数据存储，两者用来存储版本化数据都是可靠的。但是就象你在<xref linkend="svn.reposadmin.basics.backends.tbl-1"/>看到的，FSFS后端在部署场景中提供了更多的灵活性，更灵活意味着你很难错误的配置。那些原因―加上不使用Berkeley DB意味着在这个系统有更少的组件―这就是为什么今天几乎所有的人都使用FSFS来创建新的版本库。</para>
        <para>幸运的是，大多数访问Subversion的程序不会在意其所用的后端数据存储。而且你不必一定要使用你最初的数据存储方法―如果后来你改变了主意，Subversion提供了移植版本库数据到另一个版本库的方法，我们会在后面详细讨论。</para>
        <para>下面的小节提供了数据存储类型更加详细的介绍。</para>
        <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
        <section xml:id="svn.reposadmin.basics.backends.bdb">
          <info>
            <title>Berkeley DB</title>
          </info>
          <para>在Subversion的初始设计阶段，开发者因为多种原因而决定采用Berkeley DB，比如它的开源协议、事务支持、可靠性、性能、简单的API、线程安全、支持游标等。</para>
          <para>Berkeley DB提供了真正的事务支持－这或许是它最强大的特性，访问你的Subversion版本库的多个进程不必担心偶尔会破坏其他进程的数据。事务系统提供的隔离对于任何给定的操作，Subversion版本库代码看到的只是数据库的静态视图－而不是一个在其他进程影响不断变化的数据库－并能够根据该视图作出决定。如果该决定正好同其他进程所做操作冲突，整个操作会回滚，就像什么都没有发生一样，并且Subversion会优雅的再次对更新的静态视图进行操作。</para>
          <para>Berkeley DB另一个强大的特性是热备份－不必<quote>脱机</quote>就可以备份数据库环境的能力。我们将会在<xref linkend="svn.reposadmin.maint.backup"/>讨论如何备份你的版本库，能够不停止系统对版本库做全面备份的好处是显而易见的。</para>
          <para>Berkeley DB同时是一个可信赖的数据库系统。Subversion利用了Berkeley DB可以记日志的便利，这意味着数据库先在磁盘上写一个日志文件，描述它将要做的修改，然后再做这些修改。这是为了确保如果如果任何地方出了差错，数据库系统能恢复到先前的<firstterm>检查点</firstterm>―一个日志文件认为没有错误的位置，重新开始事务直到数据恢复为一个可用的状态。关于Berkeley DB日志文件的更多信息请查看<xref linkend="svn.reposadmin.maint.diskspace"/>。</para>
          <para>但是每朵玫瑰都有刺，我们也必须记录一些Berkeley DB已知的缺陷。首先，Berkeley DB环境不是跨平台的。你不能简单的拷贝一个在Unix上创建的Subversion版本库到一个Windows系统并期望它能够正常工作。尽管Berkeley DB数据库的大部分格式是不受架构约束的，但环境还是有一些方面没有独立出来。其次，使用Berkeley DB的Subversion不能在95/98系统上运行―如果你需要将版本库建在一个Windows机器上，请装到Windows2000或更新的系统上。</para>
          <para>然而Berkeley DB对于在网络共享上工作提出了一组规范，<footnote><para>Berkeley DB需要底层的文件系统实现严格的POSIX锁定语法，更重要的是，将文件直接映射到内存的能力。</para></footnote>大多数网络文件系统和应用没有实现这个要求，所以不能允许在网络共享上的BDB后端版本库被多个客户端同时访问(首先要知道版本库存放在网络共享上是非常普遍的)。</para>
          <warning>
            <para>如果你尝试在不顺从的远程文件系统上使用Berkeley DB，结果是不可预知的―你会立刻看到神秘的错误，或者是在发生隐含错误之后几个月之后才发现。你必须认真考虑在网络共享情况下使用FSFS数据存储。</para>
          </warning>
          <para>最后，因为Berkeley DB的库直接链接到了Subversion中，它对于中断比典型的关系型数据库系统更为敏感。大多数SQL系统，举例来说，有一个主服务进程来协调对数据库表的访问。如果一个访问数据库的程序因为某种原因出现问题，数据库守护进程察觉到连接中断会做一些清理。因为数据库守护进程是唯一访问数据库表的进程，应用程序不需要担心访问许可的冲突。但是，这些情况与Berkeley DB不同。Subversion(和使用Subversion库的程序)直接访问数据库的表，这意味着如果有一个程序崩溃，就会使数据库处于一个暂时的不一致、不可访问的状态。当这种情况发生时，管理员需要让Berkeley DB恢复到一个检查点，这的确有点讨厌。除了崩溃的进程，还有一些情况能让版本库出现异常，比如程序在数据库文件的所有权或访问权限上发生冲突。</para>
          <note>
            <para>Berkeley DB 4.4(对应Subversion 1.4和更高)提供了在需要恢复时自动恢复Berkeley DB环境的能力，当Subversion进程发现任何以前进程未清理的连接，就会执行所有可能的恢复，然后就当什么都没有发生一样继续执行。这样不会完全消除版本库楔住的可能，但是大大减少了人工干预恢复的数量。</para>
          </note>
          <para>因为Berkeley DB是这样快速和可伸缩，最好是使用某种单用户单服务进程方式处理―例如Apache的<command>httpd</command>或<command>svnserve</command>(见<xref linkend="svn.serverconfig"/>)―而最好不要使用许多不同的用户通过<literal>file://</literal>或<literal>svn+ssh://</literal>的URL访问的方法。如果使用多个用户直接访问Berkeley DB版本库的，请确定要读<xref linkend="svn.serverconfig.multimethod"/>。</para>
        </section>
        <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
        <section xml:id="svn.reposadmin.basics.backends.fsfs">
          <info>
            <title>FSFS</title>
          </info>
          <para>在2004年中期，另一种版本库存储系统慢慢形成了：一种不需要数据库的存储系统。FSFS版本库在单一文件中存储修订版本树，所以版本库中所有的修订版本都在一个子文件夹中有限的几个文件里。事务在单独的子目录中被创建，创建完成后，一个单独的事务文件被创建并移动到修订版本目录，这保证提交是原子性的。因为一个修订版本文件是持久不可改变的，版本库也可以做到<quote>热</quote>备份，就象Berkeley DB版本库一样。</para>
          <para>修订版本文件格式代表了一个修订版本的目录结构，文件内容，和其它修订版本树中相关信息。不像Berkeley DB数据库，这种存储格式可跨平台并且与CPU架构无关。因为没有日志或用到共享内存的文件，数据库能被网络文件系统安全的访问和在只读环境下检查。缺少数据库花消同时也意味着版本库的总体体积可以稍小一点。</para>
          <para>FSFS也有一种不同的性能特性。当提交大量文件时，FSFS可以更快的追加条目。另一方面，FSFS通过写入与上一个版本比较的变化来记录新版本，这也意味着获取最新修订版本时会比Berkeley DB慢一点，提交时FSFS也会有一个更长的延迟，在某些极端情况下会导致客护端在等待回应时超时。</para>
          <para>最重要的区别是当出现错误时FSFS不会楔住的能力。如果使用Berkeley DB的进程发生许可错误或突然崩溃，数据库会一直无法使用，直到管理员恢复。假如在应用FSFS版本库时发生同样的情况，版本库不会受到任何干扰，最坏情况下也就是会留下一些事务数据。</para>
          <para>FSFS的唯一真实的争议是其相对于Berkeley DB的不成熟，不像Berkeley DB有着多年历史的，而且有专门的开发团队，强大的Oracle会提供支持。<footnote><para>Oracle在2006情人节购买了Sleepycat和它的旗舰软件Berkeley DB。</para></footnote>FSFS在工程上更新一点，在Subversion1.4之前，我们还发现了一些确实很严重的数据一致性问题，尽管只在非常罕见的情况下发生，然而还是发生了。但是，FSFS还是很快被一些最大的开放和私有Subversion版本库所采用，并且它承诺了在跨平台时的有较少的麻烦。</para>
        </section>
      </section>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.reposadmin.create">
      <info>
        <title>创建和配置你的版本库</title>
      </info>
      <para>在<xref linkend="svn.reposadmin.planning"/>，我们我们看了一些在创建和配置Subversion版本库之前需要做的重要决定，现在我们最终要干活了！在本小节，我们要看看如何真实的创建一个Subversion版本库，并配置它在特定版本库事件执行自定义动作。</para>
      <!-- =============================================================== -->
      <section xml:id="svn.reposadmin.basics.creating">
        <info>
          <title>创建版本库</title>
        </info>
        <para>创建一个Subversion版本库出乎寻常的简单。 Subversion提供的<command>svnadmin</command> 工具，有一个执行这个功能的子命令(<command>svnadmin create</command>)。</para>
        <screen>
$ # Create a repository
$ svnadmin create /var/svn/repos
$
</screen>
        <para> 这样在目录<filename>/path/to/repos</filename>使用默认数据存储方式创建了一个新的版本库。在Subversion 1.2之前，缺省值是Berkeley DB；而现在是FSFS。你可以通过<option>--fs-type</option>参数明确地指定文件系统类型，可选的值包括<literal>fsfs</literal>和<literal>bdb</literal>。</para>
        <screen>
$ # Create an FSFS-backed repository
$ svnadmin create --fs-type fsfs /var/svn/repos
$
</screen>
        <screen>
# Create a Berkeley-DB-backed repository
$ svnadmin create --fs-type bdb /var/svn/repos
$
</screen>
        <para>运行这个命令之后，你有了一个Subversion版本库。</para>
        <tip>
          <para>你可能已经注意到了，<command>svnadmin</command>命令的路径参数只是一个普通的文件系统路径，而不是一个<command>svn</command>客户端程序访问版本库时使用的URL。<command>svnadmin</command>和<command>svnlook</command>都被认为是服务器端工具―它们在版本库所在的机器上使用，用来检查或修改版本库，不能通过网络来执行任务。一个Subversion的新手通常会犯的错误，就是试图将URL(甚至<quote>本地</quote><literal>file:</literal>路径)传给这两个程序。</para>
        </tip>
        <para>这个命令在目录<filename>/path/to/repos</filename>创建了一个新的版本库。这个新的版本库会以修订版本版本0开始其生命周期，里面除了最上层的根目录(<filename>/</filename>)，什么都没有。刚开始，修订版本0有一个修订版本属性<literal>svn:date</literal>，设置为版本库创建的时间。</para>
        <para>现在你有了一个版本库，可以用户化了。</para>
        <warning>
          <para>一般来说，版本库除了一小部分―例如配置文件和钩子脚本，你不要(也不需要)手动干预版本库。<command>svnadmin</command>工具应该足以用来处理对版本库的任何修改，或者你也可以使用第三方工具(比如Berkeley DB的工具包)来调整部分版本库。<emphasis>不</emphasis>要尝试通过处理版本库数据存储文件手工修改版本控制历史！</para>
        </warning>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.reposadmin.create.hooks">
        <info>
          <title>实现版本库钩子</title>
        </info>
        <para><firstterm>钩子</firstterm>是通过版本库事件触发，例如新版本的创建或一个未版本化属性的修改。一些钩子(叫做<quote>pre hooks</quote>)在事件发生前运行，可以用来报告发生了什么以及防止它发生。还有一些钩子(<quote>post hooks</quote>)在版本库事件之后发生，只是用来报告。每个钩子能够获得事件的足够信息，例如提出的(或完成的)版本库修改细节，还有触发事件的用户名。</para>
        <para>默认情况下，<filename>hooks</filename>子目录中包含各种版本库钩子模板。</para>
        <screen>
$ ls repos/hooks/
post-commit.tmpl          post-unlock.tmpl  pre-revprop-change.tmpl
post-lock.tmpl            pre-commit.tmpl   pre-unlock.tmpl
post-revprop-change.tmpl  pre-lock.tmpl     start-commit.tmpl
$
</screen>
        <para>对每种Subversion版本库支持的钩子的都有一个模板，通过查看这些脚本的内容，你能看到是什么事件触发了脚本及如何给传脚本传递数据。同时，这些模版也是如何使用这些脚本，结合Subversion支持的工具来完成有用任务的例子。要实际安装一个可用的钩子，你需要在<filename>repos/hooks</filename>目录下安装一些与钩子同名(如 <command>start-commit</command>或者<command>post-commit</command>)的可执行程序或脚本。</para>
        <para>在Unix平台上，这意味着要提供一个与钩子同名的脚本或程序(可能是shell 脚本，Python 程序，编译过的c语言二进制文件或其他东西)。当然，脚本模板文件不仅仅是展示了一些信息―在Unix下安装钩子最简单的办法就是拷贝这些模板，并且去掉<literal>.tmpl</literal>扩展名，然后自定义钩子的内容，确定脚本是可运行的。Windows用文件的扩展名来决定一个程序是否可运行，所以你要使程序的基本名与钩子同名，同时，它的扩展名是Windows系统所能辨认的，例如<filename>exe</filename>、<filename>com</filename>和批处理的<filename>bat</filename>。</para>
        <tip>
          <para>由于安全原因，Subversion版本库在一个空环境中执行钩子脚本―就是没有设置任何环境变量，甚至没有<literal>$PATH</literal>或<literal>%PATH%</literal>。由于这个原因，许多管理员会感到很困惑，它们的钩子脚本手工运行时正常，可在Subversion中却不能运行。要注意，必须在你的钩子中设置好环境变量或为你的程序指定好绝对路径。</para>
        </tip>
        <para>Subversion会试图以当前访问版本库的用户身份执行钩子。通常，对版本库的访问总是通过Apache HTTP服务器和mod_dav_svn进行，因此，执行钩子的用户就是运行Apache的用户。钩子本身需要具有操作系统级的访问许可，用户可以运行它。另外，其它被钩子直接或间接使用的文件或程序(包括Subversion版本库本身)也要被同一个用户访问。换句话说，要注意潜在的访问控制问题，它可能会让你的钩子无法按照你的目的顺利执行。</para>
        <para>Subversion版本库有9种钩子实现，你可以在<xref linkend="svn.ref.reposhooks"/>获得每个的信息。作为一个版本库管理员，你需要决定你要实现的钩子(通过提供家当名称和执行许可的程序)类型和方法，这种决策需要对版本库的部署非常熟悉。例如，如果你使用服务器配置方式，通过版本库检测用户名称和权限，你不需要通过钩子系统实现访问控制。</para>
        <para>在Subversion社区和其他地方都不缺Subversion钩子，这些脚本覆盖了广泛的工具―基本的访问控制，政策相关检查，问题追踪集成，email或提交通知等等。关于最常用的钩子程序的讨论，可以看<xref linkend="svn.3rdparty"/>，如果你希望写你自己的，可以看<xref linkend="svn.developer"/>。</para>
        <warning>
          <para>尽管经过调整钩子脚本可以作任何事情，但钩子脚本的作者仍会受到一些限制：不要修改使用钩子脚本修改提交事务，因为使用钩子脚本自动修改错误或提交文件的政策违例的尝试会导致问题。Subversion会在客户端缓存对应的版本库数据，如果你这样修改了提交事务，这些缓存就进入了未知的状态，这种不一致会导致令人吃惊和预想不到的行为。作为对事物修改的替换，你可以简单的在<filename>pre-commit</filename>确认事物信息并且拒绝提交，如果这样满足不了需求，作为额外的奖赏，你的用户会学会小心顺从的工作习惯。</para>
        </warning>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.reposadmin.create.bdb">
        <info>
          <title>Berkeley DB 配置</title>
        </info>
        <para>Berkeley DB环境是对一个或多个数据库、日志文件、区域文件和配置文件的封装。Berkeley DB环境对许多参数有自己的缺省值，例如任何时间里可用的数据库锁定数目、日志文件的最大值等。Subversion文件系统会使用Berkeley DB的默认值。 不过，有时候你的特定版本库与它独特的数据集合和访问类型，可能需要不同的配置选项。</para>
        <para>Berkeley DB的制造者知道不同的应用和数据库环境有不同的需求，所以他们提供了覆盖Berkeley DB环境配置的机制。你的版本库的Berkeley配置文件位于<filename>db</filename>目录的<filename>DB_CONFIG</filename>， Subversion在创建版本库时自己创建了这个文件。这个文件初始时包含了一些默认选项，也包含了Berkeley DB在线文档的指针，使你能够了解这些选项是做什么的。当然，你也可以为你的<filename>DB_CONFIG</filename> 文件添加任何Berkeley DB支持的选项。需要注意到，虽然Subversion不会尝试读取并解析这个文件，或使用其中的设置，你一定要避免会导致Berkeley DB按照Subversion代码不习惯的方式工作的修改。另外，<filename>DB_CONFIG</filename>的修改在复原数据库环境(用<command>svnadmin recover</command>)之前不会产生任何效果。</para>
      </section>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.reposadmin.maint">
      <info>
        <title>版本库维护</title>
      </info>
      <para>维护一个Subversion版本库是一项令人沮丧的工作，主要因为有数据库后端与生俱来的复杂性。做好这项工作需要知道一些工具――它们是什么，什么时候用以及如何使用。这一节将会向你介绍Subversion自带的版本库管理工具，以及如何使用它们来完成诸如版本库移植、升级、备份和整理之类的任务。</para>
      <!-- =============================================================== -->
      <section xml:id="svn.reposadmin.maint.tk">
        <info>
          <title>管理员的工具箱</title>
        </info>
        <para>Subversion提供了一些用来创建、查看、修改和修复版本库的工具。让我们首先详细了解一下每个工具，然后，我们再看一下仅在Berkeley DB后端分发版本中提供的版本数据库工具。首先，我们简短检查一下Berkeley DB发布包含的针对版本库后端数据库的工具，不是Subversion本身提供的工具。</para>
        <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
        <section xml:id="svn.reposadmin.maint.tk.svnadmin">
          <info>
            <title>svnadmin</title>
          </info>
          <para><command>svnadmin</command>程序是版本库管理员最好的朋友。除了提供创建Subversion版本库的功能，这个程序使你可以维护这些版本库。<command>svnadmin</command>的语法同其他Subversion命令类似：</para>
          <screen>
$ svnadmin help
general usage: svnadmin SUBCOMMAND REPOS_PATH  [ARGS &amp; OPTIONS ...]
Type 'svnadmin help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svnadmin --version' to see the program version and FS modules.

Available subcommands:
   crashtest
   create
   deltify
…
</screen>
          <para>在本章的前面)(在<xref linkend="svn.reposadmin.basics.creating"/>)，我们已经讨论了<command>svnadmin</command>的<literal>create</literal>子命令，本章后面我们会详细讲解大多数其他的子命令，关于所有的子命令你可以参考<xref linkend="svn.ref.svnadmin"/>。</para>
        </section>
        <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
        <section xml:id="svn.reposadmin.maint.tk.svnlook">
          <info>
            <title>svnlook</title>
          </info>
          <para><command>svnlook</command>是Subversion提供的用来查看版本库中不同的修订版本和事务(正在产生的修订版本)。这个程序不会修改版本库内容－这是个<quote>只读</quote>的工具。<command>svnlook</command>通常用在版本库钩子程序中，用来记录版本库即将提交(<command>用在pre-commit钩子时)</command>或者已经提交的(用在<command>post-commit</command>钩子时)修改。版本库管理员可以将这个工具用于诊断。</para>
          <para><command>svnlook</command>的语法很直接：</para>
          <screen>
$ svnlook help
general usage: svnlook SUBCOMMAND REPOS_PATH [ARGS &amp; OPTIONS ...]
Note: any subcommand which takes the '--revision' and '--transaction'
      options will, if invoked without one of those options, act on
      the repository's youngest revision.
Type 'svnlook help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svnlook --version' to see the program version and FS modules.
…
</screen>
          <para>几乎<command>svnlook</command>的每一个子命令都能操作修订版本或事务树，显示树本身的信息，或是它与版本库中上一个修订版本的不同。你可以用<option>--revision</option>(<option>-r</option>)和<option>--transaction</option>(<option>-t</option>)选项指定要查看的修订版本或事务。如果没有指定<option>--revision</option>(<option>-r</option>)和<option>--transaction</option>(<option>-t</option>)选项，<command>svnlook</command>会检查版本库最新的(或者说<quote>HEAD</quote>)修订版本。所以当19是位于<filename>/path/to/repos</filename>的版本库的最新版本时，如下的两个命令起到相同的效果：</para>
          <screen>
$ svnlook info /var/svn/repos
$ svnlook info /var/svn/repos -r 19
</screen>
          <para>这些子命令的唯一例外是<command>svnlook youngest</command>，它不需要任何选项，只会打印出版本库的最新修订版本号：</para>
          <screen>
$ svnlook youngest /var/svn/repos
19
$
</screen>
          <note>
            <para>请记住只能浏览未提交的事物，大多数版本库没有这样的事物，因为事物要么是已经提交的(也就是你可以<option>--revision</option>(<option>-r</option>)访问的修订版本)，要么是退出的和删除的。</para>
          </note>
          <para><command>svnlook</command>的输出被设计为人和机器都易理解，拿<command>svnlook info</command>子命令举例来说：</para>
          <screen>
$ svnlook info /var/svn/repos
sally
2002-11-04 09:29:13 -0600 (Mon, 04 Nov 2002)
27
Added the usual
Greek tree.
$
</screen>
          <para><command>svnlook info</command>的输出包含如下的内容，按照给定的顺序：</para>
          <orderedlist inheritnum="ignore" continuation="restarts">
            <listitem>
              <para>作者，后接换行。</para>
            </listitem>
            <listitem>
              <para>日期，后接换行。</para>
            </listitem>
            <listitem>
              <para>日志消息的字数，后接换行。</para>
            </listitem>
            <listitem>
              <para>日志信息本身， 后接换行。</para>
            </listitem>
          </orderedlist>
          <para>这种输出是人可阅读的，像是时间戳这种有意义的条目，使用文本表示，而不是其他比较晦涩的方式(例如许多无聊的人推荐的十亿分之一秒的数量)。这种输出也是机器可读的―因为日志信息可以有多行，没有长度的限制，<command>svnlook</command>在日志消息之前提供了消息的长度，这使得脚本或者其他这个命令的封装器能够针对日志信息做出许多职能的决定，或仅仅是在这个输出成为最后一个字节之前应该略过多少字节。</para>
          <para><command>svnlook</command>还可以做很多别的查询：显示我们先前提到的信息的一些子集，递归显示版本目录树，报告指定的修订版本或事务中哪些路径曾经被修改过，显示对文件和目录做过的文本和属性的修改，等等。<xref linkend="svn.ref.svnlook"/>是<command>svnlook</command>命令能接受子命令的完全特性参考。</para>
        </section>
        <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
        <section xml:id="svn.reposadmin.maint.tk.svndumpfilter">
          <info>
            <title>svndumpfilter</title>
          </info>
          <para>虽然在管理员的日常工作中并不会经常使用，不过<command>svndumpfilter</command>提供了一项特别有用的功能―可以简单快速的作为Subversion版本库历史的以路径为基础的过滤器。</para>
          <para><command>svndumpfilter</command>的语法如下：</para>
          <screen>
$ svndumpfilter help
general usage: svndumpfilter SUBCOMMAND [ARGS &amp; OPTIONS ...]
Type "svndumpfilter help &lt;subcommand&gt;" for help on a specific subcommand.
Type 'svndumpfilter --version' to see the program version.
  
Available subcommands:
   exclude
   include
   help (?, h)
</screen>
          <para>There are only two interesting subcommands:
          <command>svndumpfilter exclude</command> and
          <command>svndumpfilter include</command>.  They allow you to
          make the choice between implicit or explicit inclusion of
          paths in the stream.  You can learn more about these
          subcommands and <command>svndumpfilter</command>'s unique
          purpose later in this chapter, in <xref linkend="svn.reposadmin.maint.filtering"/>.</para>
        </section>
        <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
        <section xml:id="svn.reposadmin.maint.tk.svnsync">
          <info>
            <title>svnsync</title>
          </info>
          <para><command>svnsync</command>程序是Subversion 1.4版的新特性，提供了维护一个只读版本库镜像的全部功能。这个程序只有一个工作―将一个版本库的历史转移到另一个，尽管有几种方法，但这种方法的主要特点是可以远程操作―<quote>源</quote>，<quote>目标</quote><footnote><para>或者是, <quote>sync</quote> ？</para></footnote>版本库以及<command>svnsync</command>程序可能在不同的计算机上。</para>
          <para>就像你期望的，<command>svnsync</command>的语法与本节提到的其他命令非常类似。</para>
          <screen>
$ svnsync help
general usage: svnsync SUBCOMMAND DEST_URL  [ARGS &amp; OPTIONS ...]
Type 'svnsync help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svnsync --version' to see the program version and RA modules.

Available subcommands:
   initialize (init)
   synchronize (sync)
   copy-revprops
   help (?, h)
$
</screen>
          <para>我们会在<xref linkend="svn.reposadmin.maint.replication"/>详细讨论使用<command>svnsync</command>实现版本库复制。</para>
        </section>
        <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
        <section xml:id="svn.reposadmin.maint.tk.fsfsreshard">
          <info>
            <title>fsfs-reshard.py</title>
          </info>
          <para>While not an official member of the Subversion
          toolchain, the <command>fsfs-reshard.py</command> script
          (found in the <filename>tools/server-side</filename>
          directory of the Subversion source distribution) is a useful
          performance tuning tool for administrators of FSFS-backed
          Subversion repositories.  FSFS repositories contain files
          that describe the changes made in a single revision, and
          files that contain the revision properties associated with
          a single revision.  Repositories created in versions of
          Subversion prior to 1.5 keep these files in two
          directories―one for each type of file.  As new
          revisions are committed to the repository, Subversion drops
          more files into these two directories―over time, the
          number of these files in each directory can grow to be quite
          large.  This has been observed to cause performance problems
          on certain network-based filesystems.</para>
          <para>Subversion 1.5 creates FSFS-backed repositories using a
          slightly modified layout in which the contents of these two
          directories are <firstterm>sharded</firstterm>, or scattered
          across several subdirectories.  This can greatly reduce the
          time it takes the system to locate any one of these files,
          and therefore increases the overall performance of
          Subversion when reading from the repository.  The number of
          subdirectories used to house these files is configurable,
          though, and that's where
          <command>fsfs-reshard.py</command> comes in.  This script
          reshuffles the repository's file structure into a new
          arrangement that reflects the requested number of sharding
          subdirectories.  This is especially useful for converting an
          older Subversion repository into the new Subversion 1.5
          sharded layout (which Subversion will not automatically do
          for you) or for fine-tuning an already sharded
          repository.</para>
        </section>
        <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
        <section xml:id="svn.reposadmin.maint.tk.bdbutil">
          <info>
            <title>Berkeley DB 工具</title>
          </info>
          <para>如果你使用Berkeley DB版本库，那么所有纳入版本控制的文件系统结构和数据都储存在一系列数据库的表中，而这个目录就是版本库的<filename>db/</filename>。这个子目录是一个标准的Berkeley DB环境目录，可以应用任何Berkeley数据库工具进行操作，通常这些工具随Berkeley DB发布。</para>
          <para>对于Subversion的日常使用来说，这些工具并没有什么用处。大多数Subversion版本库必须的数据库操作都集成到<command>svnadmin</command>工具中。比如，<command>svnadmin list-unused-dblogs</command>和<command>svnadmin list-dblogs</command>实现了Berkeley <command>db_archive</command>命令功能的一个子集，而<command>svnadmin recover</command>则起到了<command>db_recover</command>工具的作用。</para>
          <para>当然，还有一些Berkeley DB工具有时是有用的。<command>db_load</command>和<command>db_dump</command>分别将Berkeley DB数据库中的键值对以特定的格式读写文件。Berkeley数据库本身不支持跨平台转移，这两个工具在这样的情况下就可以实现在平台间转移数据库的功能，而无需关心操作系统或机器架构。就像我们以前描述的，你可以使用<command>svnadmin dump</command>和<command>svnadmin load</command>实现类似的目的，但是<command>db_dump</command>和<command>db_load</command>可以更快一点，它们也可以协助Berkeley DB的hacker来篡改BDB后端的数据，这是Subversion工具不允许的。此外，<command>db_stat</command>工具能够提供关于Berkeley DB环境的许多有用信息，包括详细的锁定和存储子系统的统计信息。</para>
          <para>关于Berkeley DB工具的更多信息，可以访问Oracle网站的Berkeley DB文档部分，在<uri href="http://www.oracle.com/technology/documentation/berkeley-db/db/">http://www.oracle.com/technology/documentation/berkeley-db/db/</uri>。</para>
        </section>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.reposadmin.maint.setlog">
        <info>
          <title>修正提交消息</title>
        </info>
        <para>有时用户输入的日志信息有错误(比如拼写错误或者内容错误)。如果配置版本库时设置了(使用<literal>pre-revprop-change</literal>和 <literal>post-revprop-change</literal>钩子；参见<xref linkend="svn.reposadmin.create.hooks"/>)允许用户在提交后修改日志信息的选项，那么用户可以使用<command>svn</command>程序的<literal>propset</literal>命令(参见<xref linkend="svn.ref"/>)<quote>修正</quote>日志信息中的错误。不过为了避免永远丢失信息，Subversion版本库通常设置为仅能由管理员修改非版本化属性(这也是默认的选项)。</para>
        <para>如果管理员想要修改日志信息，那么可以使用<command>svnadmin setlog</command>命令。这个命令从指定的文件中读取信息，取代版本库中某个修订版本的日志信息(<literal>svn:log</literal>属性)。</para>
        <screen>
$ echo "Here is the new， correct log message" &gt; newlog.txt
$ svnadmin setlog myrepos newlog.txt -r 388
</screen>
        <para>即使是<command>svnadmin setlog</command>命令也受到限制。<literal>pre-</literal>和 <literal>post-revprop-change</literal>钩子同样会被触发，因此必须进行相应的设置才能允许修改非版本化属性。不过管理员可以使用<command>svnadmin setlog</command>命令的<option>--bypass-hooks</option>选项跳过钩子。</para>
        <warning>
          <para>不过需要注意的是，一旦跳过钩子也就跳过了钩子所提供的所有功能，比如邮件通知(通知属性有改动)、系统备份(可以用来跟踪非版本化的属性变更)等等。换句话说，要留心你所作出的修改，以及你作出修改的方式。</para>
        </warning>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.reposadmin.maint.diskspace">
        <info>
          <title>管理磁盘空间</title>
        </info>
        <para>虽然存储器的价格在过去的几年里以让人难以致信的速度滑落，但是对于那些需要对大量数据进行版本管理的管理员们来说，磁盘空间的消耗依然是一个重要的因素。版本库每增加一个字节都意味着需要多一个字节的磁盘空间进行备份，对于多重备份来说，就需要消耗更多的磁盘空间。Berkeley DB版本库的主要存储机制是基于一个复杂的数据库系统建立的，因此了解一些数据性质是有意义的，比如哪些数据必须保持在线，哪些数据需要备份、哪些数据可以安全的删除等等。</para>
        <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
        <section xml:id="svn.reposadmin.maint.diskspace.deltas">
          <info>
            <title>让 Subversion 节约磁盘空间</title>
          </info>
          <para>为了尽可能减小版本库的体积，Subversion在版本库中采用了<firstterm>增量化技术</firstterm>(或称为<quote>增量存储技术</quote>)。增量化技术可以将一组数据表示为相对于另一组数据的不同。如果这两组数据十分相似，增量化技术就可以仅保存其中一组数据以及两组数据的差别，而不需要同时保存两组数据，从而节省了磁盘空间。每次一个文件的新版本提交到版本库，版本库就会将之前的版本(之前的多个版本)相对于新版本做增量化处理。采用了这项技术，版本库的数据量大小基本上是可以估算出来的―主要是版本化的文件的大小―并且远小于<quote>全文</quote>保存所需的数据量。而Subversion 1.4以后，空间存储变得更为节省―现在文件内容的全文本身都是压缩的了。</para>
          <note>
            <para>由于Subversion版本库的增量化数据保存在单一Berkeley DB数据库文件中，减少数据的体积并不一定能够减小数据库文件的大小。但是，Berkeley DB会在内部记录未使用的数据库文件区域，并且在增加数据库文件大小之前会首先使用这些未使用的区域。因此，即使增量化技术不能立杆见影的节省磁盘空间，也可以极大的减慢数据库的膨胀速度。</para>
          </note>
        </section>
        <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
        <section xml:id="svn.reposadmin.maint.diskspace.deadtxns">
          <info>
            <title>删除终止的事务</title>
          </info>
          <para>尽管不太常见，Subversion的提交进程也有失败，同时留下将要生成的修订版本―未提交的事物和所有随之的文件和目录修改。出现这种情况可能有以下原因：客户端的用户粗暴的结束了操作，操作过程中出现网络故障，等等。不管是什么原因，死亡的事务总是有可能会出现。这类事务不会产生什么负面影响，仅仅是消耗了一点点磁盘空间。不过，严厉的管理员总是希望能够将它们清除出去。</para>
          <para>可以使用<command>svnadmin lstxns</command>命令列出当前的事务名。</para>
          <screen>
$ svnadmin lstxns myrepos
19
3a1
a45
$
</screen>
          <para>将输出的结果条目作为<command>svnlook</command>(设置<option>--transaction</option> (<option>-t</option>) option)选项)的参数，就可以获得事务的详细信息，如事务的创建者、创建时间，事务已作出的更改类型，由这些信息可以判断出是否可以将这个事务安全的删除。如果可以安全删除，那么只需将事务名作为参数输入到<command>svnadmin rmtxns</command>，就可以将事务清除掉了。其实<literal>rmtxns</literal>子命令可以直接以<literal>lstxns</literal>的输出作为输入进行清理。</para>
          <screen>
$ svnadmin rmtxns myrepos `svnadmin lstxns myrepos`
$
</screen>
          <para>在按照上面例子中的方法清理版本库之前，你或许应该暂时关闭版本库和客户端的连接。这样在你开始清理之前，不会有正常的事务进入版本库。<xref linkend="svn.reposadmin.maint.diskspace.deadtxns.ex-1"/>中的shell脚本可以用来迅速获得版本库中异常事务的信息。</para>
          <example xml:id="svn.reposadmin.maint.diskspace.deadtxns.ex-1">
            <info>
              <title>txn-info.sh (报告异常事务)</title>
            </info>
            <programlisting>
#!/bin/sh

### Generate informational output for all outstanding transactions in
### a Subversion repository.

REPOS="${1}"
if [ "x$REPOS" = x ] ; then
  echo "usage: $0 REPOS_PATH"
  exit
fi

for TXN in `svnadmin lstxns ${REPOS}`; do 
  echo "---[ Transaction ${TXN} ]-------------------------------------------"
  svnlook info "${REPOS}" -t "${TXN}"
done
</programlisting>
          </example>
          <para>该命令的输出主要由多个<command>svnlook info</command>(参见<xref linkend="svn.reposadmin.maint.tk.svnlook"/>)的输出组成，类似于下面的例子：</para>
          <screen>
$ txn-info.sh myrepos
---[ Transaction 19 ]-------------------------------------------
sally
2001-09-04 11:57:19 -0500 (Tue， 04 Sep 2001)
0
---[ Transaction 3a1 ]-------------------------------------------
harry
2001-09-10 16:50:30 -0500 (Mon， 10 Sep 2001)
39
Trying to commit over a faulty network.
---[ Transaction a45 ]-------------------------------------------
sally
2001-09-12 11:09:28 -0500 (Wed， 12 Sep 2001)
0
$
</screen>
          <para>一个废弃了很长时间的事务通常是提交错误或异常中断的结果。事务的时间戳可以提供给我们一些有趣的信息，比如一个进行了9个月的操作居然还是活动的等等。</para>
          <para>简言之，作出事务清理的决定前应该仔细考虑一下。许多信息源―比如Apache的错误和访问日志，已成功完成的Subversion提交日志等等―都可以作为决策的参考。当然，管理员还可以直接和那些似乎已经死亡事务的提交者直接交流(比如通过邮件)，来确认该事务确实已经死亡了。</para>
        </section>
        <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
        <section xml:id="svn.reposadmin.maint.diskspace.bdblogs">
          <info>
            <title>删除不使用的 Berkeley DB 日志文件</title>
          </info>
          <para>目前为止，Subversion版本库中耗费磁盘空间的最大凶手是日志文件，每次Berkeley DB在修改真正的数据文件之前都会进行预写入(pre-writes)操作。这些文件记录了数据库从一个状态变化到另一个状态的所有动作――数据库文件反映了特定时刻数据库的状态，而日志文件则记录了所有状态变化的信息。因此，日志文件会以很快的速度膨胀起来。</para>
          <para>幸运的是，从版本4.2开始，Berkeley DB的数据库环境无需额外的操作即可删除无用的日志文件。如果编译<command>svnadmin</command>时使用了高于4.2版本的Berkeley DB，那么由此<command>svnadmin</command>程序创建的版本库就具备了自动清除日志文件的功能。如果想屏蔽这个功能，只需设置<command>svnadmin create</command>命令的<option>--bdb-log-keep</option>选项即可。如果创建版本库以后想要修改关于此功能的设置，只需编辑版本库中<filename>db</filename>目录下的<filename>DB_CONFIG</filename>文件，注释掉包含<literal>set_flags DB_LOG_AUTOREMOVE</literal>内容的这一行，然后运行<command>svnadmin recover</command>强制设置生效就行了。查阅<xref linkend="svn.reposadmin.create.bdb"/>获得更多关于数据库配置的帮助信息。</para>
          <para>如果不自动删除日志文件，那么日志文件会随着版本库的使用逐渐增加。这多少应该算是数据库系统的特性，通过这些日志文件可以在数据库严重损坏时恢复整个数据库的内容。但是一般情况下，最好是能够将无用的日志文件收集起来并删除，这样就可以节省磁盘空间。使用<command>svnadmin list-unused-dblogs</command>命令可以列出无用的日志文件：</para>
          <screen>
$ svnadmin list-unused-dblogs /var/svn/repos
/var/svn/repos/log.0000000031
/var/svn/repos/log.0000000032
/var/svn/repos/log.0000000033
…
$ rm `svnadmin list-unused-dblogs /var/svn/repos`
## disk space reclaimed!
</screen>
          <warning>
            <para>BDB后端的版本库的日志文件如果是用来作为备份或容灾恢复计划时，不要使用日志文件的自动删除特性。从日志文件重新构建版本库数据只有在所有的日志文件都存在时才能完成，如果有一些文件在别的程序将其拷贝之前就已经被删除了，不完整的备份日志文件就没有用了。</para>
          </warning>
        </section>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.reposadmin.maint.recovery">
        <info>
          <title>Berkeley DB 恢复</title>
        </info>
        <para>就像在<xref linkend="svn.reposadmin.basics.backends.bdb"/>提到的，如果没有正确的关闭，Berkeley DB版本库有时候会进入冻结的状态。当发生这种情况时，管理员需要恢复版本库进入一致的状态。当然这种情况只发生在BDB版本库，FSFS版本库不会有这种情况。对于使用Subversion 1.4和Berkeley DB 4.4或更新版本的用户，你一定发现Subversion对于这种情况已经更富弹性，但是Berkeley DB楔住的情况还是会发生，管理员需要知道如何安全的处理种情况。</para>
        <para>Berkeley DB使用一种锁机制保护版本库中的数据。锁机制确保数据库不会同时被多个访问进程修改，也就保证了从数据库中读取到的数据始终是稳定而且正确的。当一个进程需要修改数据库中的数据时，首先必须检查目标数据是否已经上锁。如果目标数据没有上锁，进程就将它锁上，然后作出修改，最后再将锁解除。而其它进程则必须等待锁解除后才能继续访问数据库中的相关内容。(你对这种锁无能为力，作为一个用户，可以应用版本库的版本化文件；我们会在<xref linkend="svn.advanced.locking.meanings"/>讨论因为术语冲突导致的概念混淆。)</para>
        <para>在操作Subversion版本库的过程中，致命错误(如内存或硬盘空间不足)或异常中断可能会导致某个进程没能及时将锁解除。结果就是后端的数据库系统被<quote>楔住</quote>了。一旦发生这种情况，任何访问版本库的进程都会挂起(每个访问进程都在等待锁被解除，但是锁已经无法解除了)。</para>
        <para>如果你的版本库出现这种情况，没什么好惊慌的。Berkeley DB的文件系统采用了数据库事务、检查点以及预写入日志等技术来确保只有灾难性的事件<footnote><para>比如：硬盘 + 大号电磁铁 = 毁灭。</para></footnote>才能永久性的破坏数据库环境。所以虽然一个过于稳重的版本库管理员通常都会按照某种方案进行大量的版本库离线备份，不过不要急着通知你的管理员进行恢复。</para>
        <para>然后，使用下面的方法试着<quote>恢复</quote>你的版本库：</para>
        <orderedlist inheritnum="ignore" continuation="restarts">
          <listitem>
            <para>确保没有其它进程访问(或者试图访问)版本库。对于网络版本库，这意味着关闭Apache HTTP Server或svnserve。</para>
          </listitem>
          <listitem>
            <para>成为版本库的拥有者和管理员。这一点很重要，如果以其它用户的身份恢复版本库，可能会改变版本库文件的访问权限，导致在版本库<quote>恢复</quote>后依旧无法访问。</para>
          </listitem>
          <listitem>
            <para>运行命令<command>svnadmin recover /var/svn/repos</command>，输出如下：</para>
            <screen>
Repository lock acquired。
Please wait; recovering the repository may take some time...

Recovery completed.
The latest repos revision is 19.
</screen>
            <para>此命令可能需要数分钟才能完成。</para>
          </listitem>
          <listitem>
            <para>重新启动服务进程。</para>
          </listitem>
        </orderedlist>
        <para>这个方法能修复几乎所有版本库锁住的问题。记住，要以数据库的拥有者和管理员的身份运行这个命令，而不一定是<literal>root</literal>用户。恢复过程中可能会使用其它数据存储区(例如共享内存区)重建一些数据库文件。如果以<literal>root</literal>用户身份恢复版本库，这些重建的文件拥有者将变成<literal>root</literal>用户，也就是说，即使恢复了到版本库的连接，一般的用户也无权访问这些文件。</para>
        <para>如果因为某些原因，上面的方法没能成功的恢复版本库，那么你可以做两件事。首先，将破损的版本库保存到其它地方，然后从最新的备份中恢复版本库。然后，发送一封邮件到Subversion用户列表(地址是：<email>users@subversion.tigris.org</email>)，写清你所遇到的问题。对于Subversion的开发者来说，数据安全是最重要的问题。</para>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.reposadmin.maint.migrate">
        <info>
          <title>版本库数据的移植</title>
        </info>
        <para>Subversion文件系统将数据保存在许多数据库表中，而这些表的结构只有Subversion开发者们才了解(也只有他们才感兴趣)，不过，有些时候我们会想到把所有或一部分数据转移到另一个版本库。</para>
        <para>Subversion提供了转储版本库的功能，一个版本库转储流(当存放在磁盘上叫做<quote>dumpfile</quote>)是一种可移植的，普通文件格式，可以用来描述版本库的不同版本―什么发生了修改，谁做的，何时等等。这种转储流是解析版本化历史的主要机制―全部或部分，包含或部包含修改―在版本库之间。Subversion也提供了创建和加载这些转储流的工具―对应的<command>svnadmin dump</command>和<command>svnadmin load</command>子命令。</para>
        <warning>
          <para>虽然Subversion版本库转储格式包含了人可读的部分和熟悉的结构(类似RFC-822格式，大多数邮件使用的)，它不是纯文本的格式，这种格式必须作为二进制文件格式处理，对修改高度敏感。例如，许多文本编辑器会破坏这种文件的内容，通常是因为自动换行符替换。</para>
        </warning>
        <para>有很多导出和加载Subversion版本库数据的方法，在Subversion的早期阶段，最主要的原因是Subversion本身的进化。随着Subversion的成熟，对于数据后端模式的改变会导致更多的兼容性问题，所以用户需要使用旧版本的Subversion将版本库数据导出，然后用新版的版本库加载内容到新建的版本库。目前，这种类型的模式修改从Subversion 1.0版本还没有发生，而且Subversion开发者也许诺不会强制用户在小版本(如1.3到1.4)升级之间导入和导出版本库。但是也有一些其它原因导出和导入，包括重新部署Berkeley DB到版本库到新的OS或CPU架构，在Berkeley DB和FSFS后端之间切换，或者(我们会在<xref linkend="svn.reposadmin.maint.filtering"/>覆盖)从版本库历史中清理文件。</para>
        <note>
          <para>The Subversion repository dump format describes
          versioned repository changes only.  It will not carry any
          information about uncommitted transactions, user locks on
          filesystem paths, repository or server configuration
          customizations (including hook scripts), and so on.</para>
        </note>
        <para>无论你是什么原因需要移植版本库历史，都可以直接使用<command>svnadmin dump</command>和<command>svnadmin load</command>。<command>svnadmin dump</command>命令会将版本库中的修订版本数据按照特定的格式输出到转储流中，转储数据会输出到标准输出，而提示信息会输出到标准错误。这就是说，可以将转储数据存储到文件中，而同时在终端窗口中监视运行状态，例如：</para>
        <screen>
$ svnlook youngest myrepos
26
$ svnadmin dump myrepos &gt; dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
…
* Dumped revision 25.
* Dumped revision 26.
</screen>
        <para>最后，版本库中的指定的修订版本数据被转储到一个独立的文件中(在上面的例子中是<filename>dumpfile</filename>)。注意，<command>svnadmin dump</command>从版本库中读取修订版本树与其它<quote>读者</quote>(比如<command>svn checkout</command>)的过程相同，所以可以在任何时候安全的运行这个命令。</para>
        <para>另一个命令，<command>svnadmin load</command>，从标准输入流中读取Subversion转储数据，并且高效的将数据转载到目标版本库中。这个命令的提示信息输出到标准输出流中：</para>
        <screen>
$ svnadmin load newrepos &lt; dumpfile
&lt;&lt;&lt; Started new txn, based on original revision 1
     * adding path : A ... done.
     * adding path : A/B ... done.
     …
------- Committed new rev 1 (loaded from original rev 1) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 2
     * editing path : A/mu ... done.
     * editing path : A/D/G/rho ... done.

------- Committed new rev 2 (loaded from original rev 2) &gt;&gt;&gt;

…

&lt;&lt;&lt; Started new txn, based on original revision 25
     * editing path : A/D/gamma ... done.

------- Committed new rev 25 (loaded from original rev 25) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 26
     * adding path : A/Z/zeta ... done.
     * editing path : A/mu ... done.

------- Committed new rev 26 (loaded from original rev 26) &gt;&gt;&gt;

</screen>
        <para>load命令的结果就是添加一些新的修订版本―与使用普通Subversion客户端直接提交到版本库相同。正像一次简单的提交，你也可以使用钩子脚本在每次load的开始和结束执行一些操作。通过传递<option>--use-pre-commit-hook</option>和<option>--use-post-commit-hook</option>选项给<command>svnadmin load</command>，你可以告诉Subversion的对每一个加载修订版本执行pre-commit和post-commit钩子脚本，可以利用这个选项确保这种提交也能通过一般提交的检验。当然，你要小心使用这个选项，你一定不想接受一大堆提交邮件。你可以查看<xref linkend="svn.reposadmin.create.hooks"/>来得到更多相关信息。</para>
        <para>既然<command>svnadmin</command>使用标准输入流和标准输出流作为转储和装载的输入和输出，那么更漂亮的用法是(管道两端可以是不同版本的<command>svnadmin</command>：</para>
        <screen>
$ svnadmin create newrepos
$ svnadmin dump oldrepos | svnadmin load newrepos
</screen>
        <para>默认情况下，转储文件的体积可能会相当庞大――比版本库自身大很多。这是因为在转储文件中，每个文件的每个版本都以完整的文本形式保存下来。这种方法速度很快，而且很简单，尤其是直接将转储数据通过管道输入到其它进程中时(比如一个压缩程序，过滤程序，或者一个装载进程)。不过如果要长期保存转储文件，那么可以使用<option>--deltas</option>选项来节省磁盘空间。设置这个选项，同一个文件的数个连续修订版本会以增量式的方式保存―就像储存在版本库中一样。这个方法较慢，但是转储文件的体积则基本上与版本库的体积相当。</para>
        <para>之前我们提到<command>svnadmin dump</command>输出指定范围内的修订版本，使用<option>--revision </option> (<option>-r</option>) 选项可以指定一个单独的修订版本，或者一个修订版本的范围。如果忽略这个选项，所有版本库中的修订版本都会被转储。</para>
        <screen>
$ svnadmin dump myrepos -r 23 &gt; rev-23.dumpfile
$ svnadmin dump myrepos -r 100:200 &gt; revs-100-200.dumpfile
</screen>
        <para>Subversion在转储修订版本时，仅会输出与前一个修订版本之间的差异，通过这些差异足以从前一个修订版本中重建当前的修订版本。换句话说，在转储文件中的每一个修订版本仅包含这个修订版本作出的修改。这个规则的唯一一个例外是当前<command>svnadmin dump</command>转储的第一个修订版本。</para>
        <para>默认情况下，Subversion不会把转储的第一个修订版本看作对前一个修订版本的更改。 首先，转储文件中没有比第一个修订版本更靠前的修订版本了！其次，Subversion不知道装载转储数据时(如果真的需要装载的话)的版本库是什么样的情况。为了保证每次运行<command>svnadmin dump</command>都能得到一个独立的结果，第一个转储的修订版本默认情况下会完整的保存目录、文件以及属性等数据。</para>
        <para>不过，这些都是可以改变的。如果转储时设置了<option>--incremental</option>选项，<command>svnadmin</command>会比较第一个转储的修订版本和版本库中前一个修订版本，就像对待其它转储的修订版本一样。转储时也是一样，转储文件中将仅包含第一个转储的修订版本的增量信息。这样的好处是，可以创建几个连续的小体积的转储文件代替一个大文件，比如：</para>
        <screen>
$ svnadmin dump myrepos -r 0:1000 &gt; dumpfile1
$ svnadmin dump myrepos -r 1001:2000 --incremental &gt; dumpfile2
$ svnadmin dump myrepos -r 2001:3000 --incremental &gt; dumpfile3
</screen>
        <para>这些转储文件可以使用下列命令装载到一个新的版本库中：</para>
        <screen>
$ svnadmin load newrepos &lt; dumpfile1
$ svnadmin load newrepos &lt; dumpfile2
$ svnadmin load newrepos &lt; dumpfile3
</screen>
        <para>另一个有关的技巧是，可以使用<option>--incremental</option>选项在一个转储文件中增加新的转储修订版本。举个例子，可以使用<literal>post-commit</literal>钩子在每次新的修订版本提交后将其转储到文件中。或者，可以编写一个脚本，在每天夜里将所有新增的修订版本转储到文件中。这样，<command>svnadmin dump</command>命令就变成了很好的版本库备份工具，以防万一出现系统崩溃或其它灾难性事件。</para>
        <para>转储还可以用来将几个独立的版本库合并为一个版本库。使用<command>svnadmin load</command>的<option>--parent-dir</option>选项，可以在装载的时候指定根目录。也就是说，如果有三个不同版本库的转储文件，比如<filename>calc-dumpfile</filename>，<filename>cal-dumpfile</filename>，和<filename>ss-dumpfile</filename>，可以在一个新的版本库中保存所有三个转储文件中的数据：</para>
        <screen>
$ svnadmin create /var/svn/projects
$
</screen>
        <para>然后在版本库中创建三个目录分别保存来自三个不同版本库的数据：</para>
        <screen>
$ svn mkdir -m "Initial project roots" \
      file:///var/svn/projects/calc \
      file:///var/svn/projects/calendar \
      file:///var/svn/projects/spreadsheet
Committed revision 1.
$ 
</screen>
        <para>最后，将转储文件分别装载到各自的目录中：</para>
        <screen>
$ svnadmin load /var/svn/projects --parent-dir calc &lt; calc-dumpfile
…
$ svnadmin load /var/svn/projects --parent-dir calendar &lt; cal-dumpfile
…
$ svnadmin load /var/svn/projects --parent-dir spreadsheet &lt; ss-dumpfile
…
$
</screen>
        <para>我们再介绍一下Subversion版本库转储数据的最后一种用途――在不同的存储机制或版本控制系统之间转换。因为转储数据的格式的大部分是可以阅读的，所以使用这种格式描述变更集(每个变更集对应一个新的修订版本)会相对容易一些。事实上，<command>cvs2svn</command>工具(参见 <xref linkend="svn.forcvs.convert"/>)正是将CVS版本库的内容转换为转储数据格式，如此才能将CVS版本库的数据导入Subversion版本库之中。</para>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.reposadmin.maint.filtering">
        <info>
          <title>过滤版本库历史</title>
        </info>
        <para>因为Subversion使用底层的二进制区别和压缩算法(也可以选择完全非透明数据库系统)储存各类数据，手工调整是不明智的，即使这样做并不困难，我们也不鼓励这样做。然而，一旦你的数据存进了版本库，Subversion没有提供删除数据的简单办法。<footnote><para>那就是你是用版本控制的原因，对吗？</para></footnote>但是不可避免的，总会有些时候你需要处理版本库的历史数据。你也许想把一个不应该出现的文件从版本库中彻底清除(无论任何原因不应该在那个位置出现)。或者，你曾经用一个版本库管理多个工程，现在又想把它们分开。要完成这样的工作，管理员们需要更易于管理和扩展的方法表示版本库中的数据，Subversion版本库转储文件格式就是一个很好的选择。</para>
        <para>就像我们在<xref linkend="svn.reposadmin.maint.migrate"/>中说的，Subversion版本库转储文件记录了所有版本数据的变更信息，而且以易于阅读的格式保存。可以使用<command>svnadmin dump</command>命令生成转储文件，然后用<command>svnadmin load</command>命令生成一个新的版本库。(参见 <xref linkend="svn.reposadmin.maint.migrate"/>)。转储文件易于阅读意味着你可以查看和修改它。当然，问题是如果你有一个运行了三年的版本库，那么生成的转储文件会很庞大，阅读和手工修改起来都会花费很多时间。</para>
        <para>这正是<command>svndumpfilter</command>发挥作用的地方，这个程序可以对版本库转储流进行特定路径的过滤。这是一个独特而很有意义的用法，可以帮助你快速方便的修改转储的数据。使用时，只需提供一个你想要保留的(或者不想保留的)路径列表，然后把你的版本库转储文件送进这个过滤器。最后你就可以得到一个仅包含你想保留路径(明确的或含蓄的)的转储数据流。</para>
        <para>现在我来演示如何使用这个命令。我们会在其它章节(参见 <xref linkend="svn.reposadmin.projects.chooselayout"/>)讨论关于如何选择设定版本库布局的问题，比如应该使用一个版本库管理多个项目还是使用一个版本库管理一个项目，或者如何在版本库中安排数据等等。不过，有些时候，即使在项目已经展开以后，你还是希望对版本库的布局做一些调整。最常见的情况是，把原来存放在同一个版本库中的几个项目分开，各自成家。</para>
        <para>假设有一个包含三个项目的版本库： <literal>calc</literal>，<literal>calendar</literal>，和 <literal>spreadsheet</literal>。它们在版本库中的布局如下：</para>
        <screen>
/
   calc/
      trunk/
      branches/
      tags/
   calendar/
      trunk/
      branches/
      tags/
   spreadsheet/
      trunk/
      branches/
      tags/
</screen>
        <para>现在要把这三个项目转移到三个独立的版本库中。首先，转储整个版本库：</para>
        <screen>
$ svnadmin dump /var/svn/repos &gt; repos-dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
* Dumped revision 3.
…
$
</screen>
        <para>然后，将转储文件三次送入过滤器，每次仅保留一个顶级目录，就可以得到三个转储文件：</para>
        <screen>
$ svndumpfilter include calc &lt; repos-dumpfile &gt; calc-dumpfile
…
$ svndumpfilter include calendar &lt; repos-dumpfile &gt; cal-dumpfile
…
$ svndumpfilter include spreadsheet &lt; repos-dumpfile &gt; ss-dumpfile
…
$
</screen>
        <para>现在你必须要作出一个决定了。这三个转储文件中，每个都可以用来创建一个可用的版本库，不过它们保留了原版本库的精确路径结构。也就是说，虽然项目<literal>calc</literal>现在独占了一个版本库，但版本库中还保留着名为<filename>calc</filename>的顶级目录。如果希望<filename>trunk</filename>、<filename>tags</filename>和<filename>branches</filename>这三个目录直接位于版本库的根路径下，你可能需要编辑转储文件，调整<literal>Node-path</literal>和<literal>Copyfrom-path</literal>头参数，将路径<filename>calc/</filename>删除。同时，你还要删除转储数据中创建<filename>calc</filename>目录的部分。一般来说，就是如下的一些内容：</para>
        <screen>
Node-path: calc
Node-action: add
Node-kind: dir
Content-length: 0
  
</screen>
        <warning>
          <para>如果你打算通过手工编辑转储文件来移除一个顶级目录，注意不要让你的编辑器将换行符转换为本地格式(比如将<literal>\r\n</literal>转换为<literal>\n</literal>)。否则文件的内容就与所需的格式不相符，这个转储文件也就失效了。</para>
        </warning>
        <para>剩下的工作就是创建三个新的版本库，然后将三个转储文件分别导入，忽略转储流中发现的UUID：</para>
        <screen>
$ svnadmin create calc
$ svnadmin load --ignore-uuid calc &lt; calc-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : button.c ... done.
…
$ svnadmin create calendar
$ svnadmin load --ignore-uuid calendar &lt; cal-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : cal.c ... done.
…
$ svnadmin create spreadsheet
$ svnadmin load --ignore-uuid spreadsheet &lt; ss-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : ss.c ... done.
…
$
</screen>
        <para><command>svndumpfilter</command>的两个子命令都可以通过选项设定如何处理<quote>空</quote>修订版本。如果某个指定的修订版本仅包含路径的更改，过滤器就会将它删除，因为当前为空的修订版本通常是无用的甚至是让人讨厌的。为了让用户有选择的处理这些修订版本，<command>svndumpfilter</command>提供了以下命令行选项：</para>
        <variablelist>
          <varlistentry>
            <term>
              <option>--drop-empty-revs</option>
            </term>
            <listitem>
              <para>不生成任何空修订版本，忽略它们。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--renumber-revs</option>
            </term>
            <listitem>
              <para>如果空修订版本被剔除(通过使用<option>--drop-empty-revs</option>选项)，依次修改其它修订版本的编号，确保编号序列是连续的。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--preserve-revprops</option>
            </term>
            <listitem>
              <para>如果空修订版本被保留，保持这些空修订版本的属性(日志信息，作者，日期，自定义属性，等等)。如果不设定这个选项，空修订版本将仅保留初始时间戳，以及一个自动生成的日志信息，表明此修订版本由<command>svndumpfilter</command>处理过。</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <para>尽管<command>svndumpfilter</command>十分有用，能节省大量的时间，但它却是把不折不扣的双刃剑。首先，这个工具对路径语义极为敏感。仔细检查转储文件中的路径是不是以斜线开头。也许<literal>Node-path</literal>和<literal>Node-copyfrom-path</literal>这两个头参数对你有些帮助。</para>
        <screen>
…
Node-path: spreadsheet/Makefile
…
</screen>
        <para>如果这些路径以斜线开头，那么你传递给<command>svndumpfilter include</command>和<command>svndumpfilter exclude</command>的路径也必须以斜线开头(反之亦然)。如果因为某些原因转储文件中的路径没有统一使用或不使用斜线开头，<footnote><para>尽管<command>svnadmin dump</command>对是否以斜线作为路径的开头有统一的规定―这个规定就是不以斜线作为路径的开头―其它生成转储文件的程序不一定会遵守这个规定。</para></footnote>也许需要修正这些路径，统一使用斜线开头或不使用斜线开头。</para>
        <para>此外，复制操作生成的路径也会带来麻烦。Subversion支持在版本库中进行复制操作，也就是复制一个存在的路径，生成一个新的路径。问题是，<command>svndumpfilter</command>保留的某个文件或目录可能是由某个<command>svndumpfilter</command>排除的文件或目录复制而来的。也就是说，为了确保转储数据的完整性，<command>svndumpfilter</command>需要切断这些复制自被排除路径的文件与源文件的关系，还要将这些文件的内容以新建的方式添加到转储数据中。但是由于Subversion版本库转储文件格式中仅包含了修订版本的更改信息，因此源文件的内容基本上无法获得。如果你不能确定版本库中是否存在类似的情况，最好重新考虑一下到底保留/排除哪些路径，或许应该作为拷贝操作的源保留给你带来烦恼的路径。</para>
        <para>最后，<command>svndumpfilter</command>就是字面上的意思，如果你尝试将目录<filename>trunk/my-project</filename>中的内容迁移到其自己版本库，你可以使用<command>svndumpfilter include</command>命令保持<filename>trunk/my-project</filename>目录下的所有修改。但是结果转储文件对于将要被加载入的版本库没有任何假定，特别的，目录<filename>trunk/my-project</filename>可能从创建这个目录的修订版本开始，而它不会包含以自己创建<filename>trunk</filename>目录的指示(因为<filename>trunk</filename>没有匹配include过滤)。在尝试将转储流存放到版本库之前，你需要确定任何转储流将要存在的目录必须存在于目标版本库。</para>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.reposadmin.maint.replication">
        <info>
          <title>版本库复制</title>
        </info>
        <para>有许多场景下会存在一个Subversion版本库的版本历史与另一个完全相同。或许最明显的就是在主版本库因为硬件故障或网络已出或其他原因而不可用时，维护一个简单的备份版本库。其他的场景包括，部署一个镜像版本库来分流压力，作为软升级机制等等。</para>
        <para>Subversion 1.4提供了管理这种场景的工具―<command>svnsync</command>。<command>svnsync</command>实质上就是通知版本库<quote>重放</quote>修订版本，一次一个，然后将修订版本信息模拟提交到另一个版本库。<command>svnsync</command>运行不需要能够本地访问版本库―它的参数是版本库URL，所有的工作是通过Subversion版本库访问层(RA)接口实现的，所有要做的就是读源版本库，然后读写访问目标版本库。</para>
        <note>
          <para>当对远程源版本库使用<command>svnsync</command>时，Subversion版本库的服务器必须是Subversion1.4或更高的版本。</para>
        </note>
        <para>假定你已经有了一个希望镜像的源版本库，下一步就是你要有一个作为镜像的目标版本库。目标版本库可以使用任意文件系统数据存储后端(见<xref linkend="svn.reposadmin.basics.backends"/>)，但是其中一定不能有历史版本。<command>svnsync</command>的通讯议对于源和目标版本库版本历史的不一致非常敏感，因此，虽然<command>svnsync</command>无法要求目标版本库是只读的，<footnote><para>实际上，它不是真的完全只读，或者<command>svnsync</command>本身有时间将版本库历史拷入。</para></footnote>最好的办法就是只允许镜像进程修改目标版本库内容。</para>
        <warning>
          <para><emphasis>不要</emphasis>做出会对镜像版本库产生版本库历史偏移的修改，所有提交和版本库的属性修改必须是由<command>svnsync</command>执行的。</para>
        </warning>
        <para>对于目标版本库的另一种需求是<command>svnsync</command>可以修改特定版本化属性。<command>svnsync</command>在目标版本库的修订版本0的特别属性上记录了簿记信息，因为<command>svnsync</command>在版本库的钩子系统的框架下工作的，版本库缺省的状态(关闭了版本库属性修改；见<xref linkend="svn.ref.reposhooks.pre-revprop-change"/>)是不够的。你会需要明确的实现pre-revprop-change钩子，而且你的脚本必须允许<command>svnsync</command>设置它的特别属性，有了这些准备工作，你就可以开始镜像版本库修订版本了。</para>
        <tip>
          <para>实现授权措施允许复制进程的操作，同时防止其他用户修改镜像版本库内容是一个好主意。</para>
        </tip>
        <para>让我们在一个典型的镜像场景中浏览一下<command>svnsync</command>的使用，我们急着讨论实践推荐，但是如果你们不需要或者感到不适合你们的环境，你可以不必去关注。</para>
        <para>作为开发者喜欢的版本控制系统的一个服务，我们会Subversion的源代码版本库镜像到Internet，存放在不同的主机上，而不仅仅只有最初的Subversion版本库。远程主机的全局设置允许匿名用户读取版本库的信息，但是需要认证的用户才能修改版本库。(请原谅我们在此刻这里曲解Subversion服务器配置的细节―这些内容在<xref linkend="svn.serverconfig"/>。)因为没有更多的理由来建立更有趣的例子，我们会在第三个机器上创建复制进程，我们正在使用的一个例子。</para>
        <para>首先，我们会创建一个作为镜像的版本库，下面两步需要我们能够通过shell访问镜像版本库的机器。一旦版本库配置完成，我们不必再直接碰它了。</para>
        <screen>
$ ssh admin@svn.example.com \
      "svnadmin create /var/svn/svn-mirror"
admin@svn.example.com's password: ********
$
</screen>
        <para>此刻，我们有了我们的版本库，因为我们服务器的配置，这个版本库现在<quote>存在于</quote>Internet。现在，因为除了复制进程我们不希望任何其他修改，我们需要将这个进程同其他可能的提交者区分开来。为此，我们的进程使用专用的用户，只有特定用户<literal>syncuser</literal>的提交和属性修改可以被执行。</para>
        <para>我们会使用版本库的钩子系统来允许复制进程完成我们的任务，我们通过实现两个版本库事件钩子pre-revprop-change和start-commit来强制这个过程。我们的<filename>pre-revprop-change</filename>钩子脚本可以在<xref linkend="svn.reposadmin.maint.replication.pre-revprop-change"/>找到，只是验证尝试修改属性的用户是<literal>syncuser</literal>，如果是，则允许修改；否则，拒绝修改。</para>
        <example xml:id="svn.reposadmin.maint.replication.pre-revprop-change">
          <info>
            <title>镜像版本库的 pre-revprop-change 钩子</title>
          </info>
          <programlisting>
#!/bin/sh 

USER="$3"

if [ "$USER" = "syncuser" ]; then exit 0; fi

echo "Only the syncuser user may change revision properties" &gt;&amp;2
exit 1
</programlisting>
        </example>
        <para>这里覆盖了修订版本属性修改，我们现在需要来确认只有用户<literal>syncuser</literal>允许提交新版本到版本库，我们使用了一个像<xref linkend="svn.reposadmin.maint.replication.start-commit"/>的<filename>start-commit</filename>钩子。</para>
        <example xml:id="svn.reposadmin.maint.replication.start-commit">
          <info>
            <title>镜像版本库的 start-commit 钩子</title>
          </info>
          <programlisting>
#!/bin/sh 

USER="$2"

if [ "$USER" = "syncuser" ]; then exit 0; fi

echo "Only the syncuser user may commit new revisions" &gt;&amp;2
exit 1
</programlisting>
        </example>
        <para>在安装了我们的钩子脚本和确定它们可以被Subversion服务器执行后，我们完成了镜像版本库的配置，现在我们开始实际的镜像。</para>
        <para>对于<command>svnsync</command>，我们首先需要在目标版本库上注册源版本库，我们通过<command>svnsync initialize</command>实现这一步。提供的URL分别指向目标和源版本库，在Subversion1.4，这是必须的―只允许完全的版本库镜像。在Subversion1.5，你可以使用<command>svnsync</command>镜像版本库的子树。</para>
        <screen>
$ svnsync help init
initialize (init): usage: svnsync initialize DEST_URL SOURCE_URL

Initialize a destination repository for synchronization from
another repository.
…
$ svnsync initialize http://svn.example.com/svn-mirror \
                     http://svn.collab.net/repos/svn \
                     --sync-username syncuser --sync-password syncpass
Copied properties for revision 0.
$
</screen>
        <para>我们的目标版本库现在记住了它是Subversion公共源代码版本库的镜像，注意我们在<command>svnsync</command>提供了一个用户名和密码―这是我们的镜像版本库pre-revprop-change钩子的要求。</para>
        <note>
          <para><command>svnsync</command>的最初版本(在Subversion 1.4)有一些缺陷―用来认证的<option>--username</option>和<option>--password</option>命令行参数同时作用于源和目标版本库。显然，我们无法保证同步的用户认证信息是相同的，如果不一样，用户使用非交互模式(<option>--non-interactive</option>选项)来运行<command>svnsync</command>时会遇到这个问题。</para>
          <para>This has been fixed in Subversion 1.5 with the
          introduction of two new pairs of options.  Use
          <option>--source-username</option> and
          <option>--source-password</option> to provide authentication
          credentials for the source repository; use
          <option>--sync-username</option> and
          <option>--sync-password</option> to provide credentials for
          the destination repository.  (The old
          <option>--username</option> and <option>--password</option>
          options still exist for compatibility, but we advise against
          using them.)</para>
        </note>
        <para>现在有趣的部分开始了，通过一个单独的子命令，我们可以告诉<command>svnsync</command>将所有未镜像的修订版本从源版本库拷贝到目标版本库。<footnote><para>要预先警告一下，尽管对于普通读者只需要几秒钟就可以理解下面的输出，而对于整个镜像过程花费的时间可能会非常长。</para></footnote><command>svnsync synchronize</command>子命令会查看目标版本库特定修订版本的属性，并且检测同步的版本库是哪一个，以及最新镜像的修订版本是0。然后它会查询源版本库，检测其最新的修订版本。最后，它会询问源版本库服务器来开始重演从修订版本0到最新修订版本。<command>svnsync</command>从源版本库服务器得到返回的结果，然后将其作为新的提交转发到目标版本库服务器。</para>
        <screen>
$ svnsync help synchronize
synchronize (sync): usage: svnsync synchronize DEST_URL

Transfer all pending revisions to the destination from the source
with which it was initialized.
…
$ svnsync synchronize http://svn.example.com/svn-mirror
Transmitting file data ........................................
Committed revision 1.
Copied properties for revision 1.
Transmitting file data ..
Committed revision 2.
Copied properties for revision 2.
Transmitting file data .....
Committed revision 3.
Copied properties for revision 3.
…
Transmitting file data ..
Committed revision 23406.
Copied properties for revision 23406.
Transmitting file data .
Committed revision 23407.
Copied properties for revision 23407.
Transmitting file data ....
Committed revision 23408.
Copied properties for revision 23408.
$
</screen>
        <para>镜像修订版本有一点特别有趣，首先是到目标版本库的修订版本提交，然后跟着属性修改。这是因为最初的提交是通过用户<literal>syncuser</literal>执行的，而时间戳是提交的时间，而且Subversion底层的版本库访问接口不允许在提交时任意修改修订版本属性，所以<command>svnsync</command>会立即使用属性修改，将源版本库发现的所有修订版本属性拷贝到目标版本库，这其中就包括了修改作者和时间戳使之与源版本库一致的效果。</para>
        <para>值得注意的是<command>svnsync</command>会小心簿记所有的操作，可以安全的中断并重新开始，而不必破坏镜像数据的完整性。如果在<command>svnsync synchronize</command>时出现网络故障，只需要重新运行<command>svnsync synchronize</command>，她会从中断处开始。实际上，随着新的修订版本在源版本库出现，这样就可以保证你的镜像不会过时。</para>
        <sidebar>
          <info>
            <title>关于 svnsync</title>
          </info>
          <para><command>svnsync</command> needs to be able to set and
          modify revision properties on the mirror repository because
          those properties are part of the data it is tasked with
          mirroring.  As those properties change in the source
          repository, those changes need to be reflected in the mirror
          repository, too.  But <command>svnsync</command> also uses a
          set of custom revision properties―stored in revision 0
          of the mirror repository―for its own internal
          bookkeeping.  These properties contain information such as
          the URL and UUID of the source repository, plus some
          additional state-tracking information.</para>
          <para>One of those pieces of state-tracking information is a
          flag that essentially just means <quote>there's a
          synchronization in progress right now.</quote>  This is used
          to prevent multiple <command>svnsync</command> processes
          from colliding with each other while trying to mirror data
          to the same destination repository.  Now, generally you
          won't need to pay any attention whatsoever to
          <emphasis>any</emphasis> of these special properties (all of
          which begin with the prefix <literal>svn:sync-</literal>).
          Occasionally, though, if a synchronization fails
          unexpectedly, Subversion never has a chance to remove this
          particular state flag.  This causes all future
          synchronization attempts to fail because it appears that a
          synchronization is still in progress when, in fact, none is.
          Fortunately, recovering from this situation is as simple as
          removing the <literal>svn:sync-lock</literal> property which
          serves as this flag from revision 0 of the mirror
          repository:</para>
          <screen>
$ svn propdel --revprop -r0 svn:sync-lock http://svn.example.com/svn-mirror
property 'svn:sync-lock' deleted from repository revision 0
$
</screen>
          <para>That <command>svnsync</command> stores the source
          repository URL in a bookkeeping property on the mirror
          repository is the reason why you have to specify that
          URL only once, during <command>svnsync init</command>.  Future
          synchronization operations against that mirror simply
          consult the special <literal>svn:sync-from-url</literal>
          property stored on the mirror itself to know where
          to synchronize from.  This value is used literally by the
          synchronization process, though.  So while from within
          CollabNet's network you can perhaps access our example
          source URL as <literal>http://svn/repos/svn</literal>
          (because that first <literal>svn</literal> magically gets
          <literal>.collab.net</literal> appended to it by DNS
          voodoo), if you later need to update that mirror from
          another machine outside CollabNet's network, the
          synchronization might fail (because the hostname
          <literal>svn</literal> is ambiguous).  For this reason, it's
          best to use fully qualified source repository URLs when
          initializing a mirror repository rather than those that
          refer to only hostnames or IP addresses (which can change
          over time).  But here again, if you need an existing mirror
          to start referring to a different URL for the same source
          repository, you can change the bookkeeping property which
          houses that information:</para>
          <screen>
$ svn propset --revprop -r0 svn:sync-from-url <replaceable>NEW-SOURCE-URL</replaceable> \
      http://svn.example.com/svn-mirror
property 'svn:sync-from-url' set on repository revision 0
$
</screen>
          <para>Another interesting thing about these special
          bookkeeping properties is that <command>svnsync</command>
          will not attempt to mirror any of those properties when they
          are found in the source repository.  The reason is probably
          obvious, but basically boils down to
          <command>svnsync</command> not being able to distinguish the
          special properties it has merely copied from the source
          repository from those it needs to consult and maintain for
          its own bookkeeping needs.  This situation could occur if,
          for example, you were maintaining a mirror of a mirror of a
          third repository.  When <command>svnsync</command> sees its
          own special properties in revision 0 of the source
          repository, it simply ignores them.</para>
        </sidebar>
        <para>然而，这个进程还有一点不优雅的地方，因为Subversion属性修改可以发生在整个生命周期的任何时候，不会留下任何审计痕迹来说明所作的修改，扶植进程需要对此额外关注。如果你已经镜像了某个版本库的15个修订版本，而某个人修改了修订版本12的属性，你需要告诉它手工使用(或一些额外的工具)<command>svnsync copy-revprops</command>子命令，只是简单的重新复制某个特定修订版本的属性。</para>
        <screen>
$ svnsync help copy-revprops
copy-revprops: usage: svnsync copy-revprops DEST_URL [REV[:REV2]]

Copy the revision properties in a given range of revisions to the
destination from the source with which it was initialized.
…
$ svnsync copy-revprops http://svn.example.com/svn-mirror 12
Copied properties for revision 12.
$
</screen>
        <para>版本库复制只是一个壳，你一定会希望利用这个进程的自动化。例如，如果我们的例子是一个“拖和推”设置，你或许希望在post-commit和post-revprop-change钩子实现中从你的主版本库将修改推倒一个或多个镜像，这样就可以近乎实时的保持镜像的时效性。</para>
        <para>而且，这样做并不平凡，在人证用户只有部分读权限时<command>svnsync</command>也会优雅的镜像，它只会拷贝允许查看的版本库内容，显然这种镜像不适合备份方案。</para>
        <para>In Subversion 1.5, <command>svnsync</command> grew the
        ability to also mirror a subset of a repository rather than
        the whole thing.  The process of setting up and maintaining
        such a mirror is exactly the same as when mirroring a whole
        repository, except that instead of specifying the source
        repository's root URL when running <command>svnsync
        init</command>, you specify the URL of some subdirectory
        within that repository.  Synchronization to that mirror will
        now copy only the bits that changed under that source
        repository subdirectory.  There are some limitations to this
        support, though.  First, you can't mirror multiple disjoint
        subdirectories of the source repository into a single mirror
        repository―you'd need to instead mirror some parent
        directory that is common to both.  Second, the filtering
        logic is entirely path-based, so if the subdirectory you are
        mirroring was renamed at some point in the past, your mirror
        would contain only the revisions since the directory appeared
        at the URL you specified.  And likewise, if the source
        subdirectory is renamed in the future, your synchronization
        processes will stop mirroring data at the point that the
        source URL you specified is no longer valid.</para>
        <para>只要用户与版本库和镜像的交互继续，是可以有一个工作拷贝直接与这两个版本库交互。但是你需要跳出几个圈子才能做到这样。第一，你需要保证主和镜像版本库有相同的UUID(通常缺省不是相同)，本章后面<xref linkend="svn.reposadmin.maint.uuids"/>详细讨论了这个问题。</para>
        <para>现在两个版本库有了相同的UUID，你可以使用<command>svn switch --relocate</command>指向任何你希望操作的版本库，详细方法见<xref linkend="svn.ref.svn.c.switch"/>。这里也可能有危险，尽管如果主和镜像版本库没有同步的关闭，一个工作拷贝对于主版本库没有过时，而重定位的镜像却是过时的，显然期望存在的修订版本缺失会造成困惑。如果发生这个情况，你可以将工作拷贝重新定位到主版本库，然后等待镜像版本库变成最新，或者将工作拷贝恢复到你知道的版本库修订版本，再尝试重新定位。</para>
        <para>最后我们需要意识到，<command>svnsync</command>只支持修订版本为基础的复制，只有版本库转储文件包含的内容会进行复制。因此<command>svnsync</command>也有了版本库转储流的此类限制，它没有包括诸如钩子实现，版本库或服务器配置数据，未提交事务或关于用户锁定版本库路径的信息，只有Subversion版本库转储文件格式在复制时包含这些信息。</para>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.reposadmin.maint.backup">
        <info>
          <title>版本库备份</title>
        </info>
        <para>尽管现代计算机的诞生带来了许多便利，但有一件事听起来是完全正确的―有时候，事情变的糟糕，很糟糕，动力损耗、网络中断、坏掉的内存和损坏的硬盘都是对魔鬼的一种体验，即使对于最尽职的管理员，命运也早已注定。所以我们来到了这个最重要的主题―怎样备份你的版本库数据。</para>
        <para>Subversion版本库管理有两种备份方法―完全和增量。一个完全的版本库备份包含了在重大灾难后重建版本库所需的所有信息，通常，这意味着对版本库目录(包括Berkeley DB或FSFS环境)的完全复制，增量备份的内容要少一些：只包含在上次备份后改变的部分。</para>
        <para>随着完全备份的使用，这种幼稚的方法或许看起来有点不够健全，但是除非你临时关闭所有访问版本库的进程，否则这种递归的拷贝目录会有产生错误拷贝的风险。Berkeley DB的情况下，其文档中记述了按照什么顺序拷贝可以保证正确的备份拷贝，FSFS也有类似的顺序。但是你不必自己实现这种算法，因为Subversion的开发团队已经这样做了。<command>svnadmin hotcopy</command>关注了在热拷贝版本库时的所有细节，它的调用就像Unix的<command>cp</command>或Windows的<command>copy</command>一样琐碎：</para>
        <screen>
$ svnadmin hotcopy /var/svn/repos /var/svn/repos-backup
</screen>
        <para>作为结果的备份是一个完全功能的版本库，当发生严重错误时可以作为你的活动版本库的替换。</para>
        <para>当进行Berkeley DB版本库的备份时，你可以指导<command>svnadmin hotcopy</command>清理源版本库中无用的Berkeley DB日志文件(见<xref linkend="svn.reposadmin.maint.diskspace.bdblogs"/>)，只需要简单的在命令行里提供<option>--clean-logs</option>。</para>
        <screen>
$ svnadmin hotcopy --clean-logs /var/svn/bdb-repos /var/svn/bdb-repos-backup
</screen>
        <para>还有一些附加的加工命令，Subversion源程序中的<filename>tools/backup/</filename>目录包含了<command>hot-backup.py</command>脚本，这个脚本在<command>hot-backup.py</command>之上增加了备份管理功能，你可以保存每个版本库最近的配置号码。为了防止与以前的备份冲突，它会自动管理备份版本库目录名字，<quote>循环</quote>利用备份名，删除掉旧的，保存新的。即使你也有一个增量的备份，你还是会希望有规律的运行这个程序。例如，你会在一个调度程序(例如Unix系统的<command>cron</command>)中调用<command>hot-backup.py</command>会导致它在半夜执行(或者是任何你认为安全的时间间隔)。</para>
        <para>一些管理员使用不同的备份机制，通过生成和保存版本库转储数据。我们在<xref linkend="svn.reposadmin.maint.migrate"/>中描述如何使用<command>svnadmin dump --incremental</command>来对一个修订版本或一个修订版本范围执行增量备份。当然，通过取消<option>--incremental</option>选项可以得到完整的备份。在备份信息中方法的值非常灵活―不会与特定平台，版本化的文件系统类型或Subversion和Berkeley DB的版本绑定。但是灵活带来了代价，数据恢复会占用更长的时间―比每个新版本提交更长。此外，在非完全的量转储生成时，对已经备份修订版本的修订版本属性的修改不会被采纳，因为这些原因，我们不建议你单独依赖转储为基础的备份方法。</para>
        <para>如你所见，几种备份方式都有各自的优点，最简单的方式是完全热备份，将会每次建立版本库的完美复制品，这意味着如果当你的活动版本库发生了什么事情，你可以用备份恢复。但不幸的是，如果你维护多个备份，每个完全的备份会吞噬掉和你的活动版本库同样的空间。与之相对照的是增量备份，能够快速生成小的备份，但是恢复过程将会很痛苦，通常要包括多个增量拷贝的应用。其他方法都有自己的特点，管理员需要在创建拷贝和恢复的代价之间寻求平衡。</para>
        <para><command>svnsync</command>(见<xref linkend="svn.reposadmin.maint.replication"/>)实际上提供了一种更易实施的妥协方法，如果你有规律的同步镜像版本库，则在必要时，镜像版本库就成了主版本库发生问题时的一个合适替代者。这个方法最大的缺点是只有版本化的数据得到了同步―版本库的配置信息，用户指定的路径锁定和其它以物理形式存在于版本库路径而不存在于版本库虚拟文件系统的项目不会被svnsync处理。</para>
        <para>在每一种备份情境下，版本库管理员需要意识到对未版本化的修订版本属性的修改对备份的影响，因为这些修改本身不会产生新的修订版本，所以不会触发post-commit的钩子程序，也不会触发pre-revprop-change和post-revprop-change的钩子。 <footnote><para><command>svnadmin setlog</command>可以被绕过钩子程序被调用。</para></footnote>而且因为你可以改变修订版本的属性，而不需要遵照时间顺序―你可在任何时刻修改任何修订版本的属性―因此最新版本的增量备份不会捕捉到以前特定修订版本的属性修改。</para>
        <para>通常说来，在每次提交时，只有妄想狂才会备份整个版本库，然而，假设一个给定的版本库拥有一些恰当粒度的冗余机制(如每次提交的邮件)。版本库管理员也许会希望将版本库的热备份引入到系统级的每夜备份，对大多数版本库，归档的提交邮件为保存资源提供了足够的冗余措施，至少对于最近的提交。但是它是你的数据―你喜欢怎样保护都可以。</para>
        <para>通常情况下，最好的版本库备份方式是混合的，你可以平衡完全和增量备份，另外配合提交邮件的归档。Subversion开发者，举个例子，使用<command>hot-backup.py</command>对Subversion版本库进行完全备份并使用<command>rsync</command>同步这些备份；同时保存所有的提交日至和修改通知邮件；并且使用许多志愿者维护的<command>svnsync</command>镜像版本库。你们的解决方案可能非常类似，但是要实现满足需要和便利性的平衡。无论你做了什么，你需要一次次的验证你的备份―就像要检查备用轮胎是否有个窟窿？当然，所有做的事情都无法回避我们的硬件来自钢铁的命运，<footnote><para>你知道的―只是对各种变化莫测的问题的统称。</para></footnote>它将帮助你从艰难的时光恢复过来。</para>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.reposadmin.maint.uuids">
        <info>
          <title>管理版本库的 UUID</title>
        </info>
        <para>Subversion repositories have a universally unique
        identifier (UUID) associated with them.  This is used by
        Subversion clients to verify the identity of a repository when
        other forms of verification aren't good enough (such as
        checking the repository URL, which can change over time).
        Most Subversion repository administrators rarely, if ever,
        need to think about repository UUIDs as anything more than a
        trivial implementation detail of Subversion.  Sometimes,
        however, there is cause for attention to this detail.</para>
        <para>As a general rule, you want the UUIDs of your live
        repositories to be unique.  That is, after all, the point of
        having UUIDs.  But there are times when you want the
        repository UUIDs of two repositories to be exactly the same.
        For example, if you make a copy of a repository for backup
        purposes, you want the backup to be a perfect replica of the
        original so that, in the event that you have to restore that
        backup and replace the live repository, users don't suddenly
        see what looks like a different repository.  When dumping and
        loading repository history (as described earlier in <xref linkend="svn.reposadmin.maint.migrate"/>), you get to decide
        whether to apply the UUID encapsulated in the data dump
        stream to the repository in which you are loading the data.  The
        particular circumstance will dictate the correct
        behavior.</para>
        <para>There are a couple of ways to set (or reset) a
        repository's UUID, should you need to.  As of Subversion 1.5,
        this is as simple as using the <command>svnadmin
        setuuid</command> command.  If you provide this subcommand
        with an explicit UUID, it will validate that the UUID is
        well-formed and then set the repository UUID to that value.
        If you omit the UUID, a brand-new UUID will be generated for
        your repository.</para>
        <screen>
$ svnlook uuid /var/svn/repos
cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
$ svnadmin setuuid /var/svn/repos   # generate a new UUID
$ svnlook uuid /var/svn/repos
3c3c38fe-acc0-11dc-acbc-1b37ff1c8e7c
$ svnadmin setuuid /var/svn/repos \
           cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec  # restore the old UUID
$ svnlook uuid /var/svn/repos
cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
$
</screen>
        <para>For folks using versions of Subversion earlier than 1.5,
        these tasks are a little more complicated.  You can explicitly
        set a repository's UUID by piping a repository dump file stub
        that carries the new UUID specification through
        <userinput>svnadmin load --force-uuid <replaceable>REPOS-PATH</replaceable></userinput>.</para>
        <screen>
$ svnadmin load --force-uuid /var/svn/repos &lt;&lt;EOF
SVN-fs-dump-format-version: 2

UUID: cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
EOF
$ svnlook uuid /var/svn/repos
cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
$
</screen>
        <para>Having older versions of Subversion generate a brand-new
        UUID is not quite as simple to do, though.  Your best bet here
        is to find some other way to generate a UUID, and then
        explicitly set the repository's UUID to that value.</para>
      </section>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.reposadmin.maint.moving-and-removing">
      <info>
        <title>移动和删除版本库</title>
      </info>
      <para>Subversion repository data is wholly contained within the
      repository directory.  As such, you can move a Subversion
      repository to some other location on disk, rename a repository,
      copy a repository, or delete a repository altogether using the
      tools provided by your operating system for manipulating
      directories―<command>mv</command>, <command>cp
      -a</command>, and <command>rm -r</command> on Unix platforms;
      <command>copy</command>, <command>move</command>, and
      <command>rmdir /s /q</command> on Windows; vast numbers of mouse
      and menu gyrations in various graphical file explorer
      applications, and so on.</para>
      <para>Of course, there's often still more to be done when trying
      to cleanly affect changes such as this.  For example, you might
      need to update your Subversion server configuration to point to
      the new location of a relocated repository or to remove
      configuration bits for a now-deleted repository.  If you have
      automated processes that publish information from or about your
      repositories, they may need to be updated.  Hook scripts might
      need to be reconfigured.  Users may need to be notified.  The list
      can go on indefinitely, or at least to the extent that you've
      built processes and procedures around your Subversion
      repository.</para>
      <para>In the case of a copied repository, you should also consider
      the fact that Subversion uses repository UUIDs to distinguish
      repositories.  If you copy a Subversion repository using a
      typical shell recursive copy command, you'll wind up with two
      repositories that are identical in every way―including their UUIDs.
      In some circumstances, this might be desirable.  But in the
      instances where it is not, you'll need to generate a new UUID
      for one of these identical repositories.  See <xref linkend="svn.reposadmin.maint.uuids"/> for more about managing
      repository UUIDs.</para>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.reposadmin.summary">
      <info>
        <title>总结</title>
      </info>
      <para>现在，你应该已经对如何创建、配置以及维护Subversion版本库有了个基本的认识。我们向您介绍了几个可以帮助您工作的工具。通过这一章，我们说明了一些常见的管理误区，并提出了避免陷入误区的建议。</para>
      <para>剩下的，就是由你决定在你的版本库中存放一些什么有趣的资料，并最终通过网络获得这些资料。下一章是关于网络的内容。</para>
    </section>
  </chapter>
  <!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->