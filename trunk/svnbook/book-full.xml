
  <chapter xml:id="svn.customization">
    <info>
      <title>定制你的Subversion体验</title>
    </info>
    <para>版本控制可以成为复杂的主题，和科学一样充满艺术性，为解决事情能提供了无数的方法。贯穿这本书，你已经阅读许多Subversion命令行子命令，以及可以改变运行方式的选项，在本章我们要查看一些自定义Subversion工作的方法—设置Subversion运行配置，使用外置帮助程序，Subversion与操作系统配置的地区交互等等。</para>
    <!-- TODO(cmpilato): Gut the runtime config stuff like I did the
       property stuff, making larger topical sections to which the
       runtime config stuff generally refers.  Like already exists for
       external diff/diff3, add, for example, a section on external
       editors. -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.advanced.confarea">
      <info>
        <title>运行配置区</title>
      </info>
      <para>Subversion提供了许多用户可以控制的可选行为方式，许多是用户希望添加到所有的Subversion操作中的选项，为了避免强制用户记住命令行参数并且在每个命令中使用，Subversion使用配置文件，并且将配置文件保存在独立的Subversion配置区。</para>
      <para>Subversion<firstterm>配置区</firstterm>是一个双层结构，保存了可选项的名称和值。通常，Subversion配置区是一个保存<firstterm>配置文件</firstterm>的特殊目录(第一层结构)，目录中保存了一些标准INI格式的文本文件(文件中的<quote>section</quote>形成第二层结构)。这些文件可以简单用你喜欢的文本编辑器编辑(如Emacs或vi)，而且保存了客户端可以读取的指示，用来指导用户的一些行为选项。</para>
      <!-- =============================================================== -->
      <section xml:id="svn.advanced.confarea.layout">
        <info>
          <title>配置区布局</title>
        </info>
        <para><command>svn</command>命令行客户端第一次执行时，会创建一个用户配置区，在类Unix系统中，配置区位于用户主目录中，名为<filename>.subversion</filename>。在Win32系统，Subversion创建一个名为<filename>Subversion</filename>的目录，这个目录通常位于用户配置目录(顺便说一句，通常是一个隐藏目录)的<filename>Application Data</filename>子目录下。然而，在Win32平台上，此目录的具体位置在不同的系统上是不一样的，由Windows注册表决定。 <footnote><para><literal>APPDATA</literal>环境变量指向<filename>Application Data</filename>目录，所以你可以通过<filename>%APPDATA%\Subversion</filename>引用用户配置区目录。</para></footnote>我们以Unix下的名字<filename>.subversion</filename>来表示用户配置区。</para>
        <para>除了用户配置区，Subversion也提供了系统配置区，通过系统配置区，系统管理员可以为某个机器的所有用户建立缺省配置值。注意系统配置区不会规定强制性的策略—每个用户配置区都可以覆盖系统配置区中的配置项，而<command>svn</command>的命令行参数决定了最后的行为。在类Unix的平台上，系统配置区位于<filename>/etc/subversion</filename>目录下，在Windows平台上，系统配置区位于<filename>Application Data</filename>(再说一次，是由Windows注册表决定的)的<filename>Subversion</filename>目录中。与每用户配置区不同，<command>svn</command>不会试图创建系统配置区。</para>
        <para>目前，Subversion的配置区包含三个文件—两个配置文件(<filename>config</filename>和<filename>servers</filename>)，和一个INI文件格式的<filename>README.txt</filename>描述文件。配置文件创建的时候，Subversion的选项都设置为默认值。配置文件中的选项都按功能划分成组，大多数选项还有详细的文字描述注释，说明这些选项的值对Subversion的主要影响。要修改选项，只需用文本编辑器打开并编辑配置文件。如果想要恢复缺省的配置，可以直接删除(或者重命名)配置目录，并且运行一些如<command>svn --version</command>之类的无关紧要的<command>svn</command>命令，一个包含缺省值的新配置目录就会创建起来。</para>
        <para>用户配置区也缓存了认证信息，<filename>auth</filename>目录下的子目录中缓存了一些Subversion支持的各种认证方法的信息，这个目录需要相应的用户权限才可以访问。</para>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.advanced.confarea.windows-registry">
        <info>
          <title>配置和 Windows 注册表</title>
        </info>
        <para>除了基于INI文件的配置区，运行在Windows平台的Subversion客户端也可以使用Windows注册表来保存配置数据。注册表中保存的选项名称和值的含义与INI文件中相同，<quote>file/section</quote>在注册表中表现为注册表键树的层级，使得双层结构得以保留下来。</para>
        <para>Subversion的系统配置值保存在键<literal>HKEY_LOCAL_MACHINE\Software\Tigris.org\Subversion</literal>下。举个例子，<literal>global-ignores</literal>选项位于<filename>config</filename>文件的<literal>miscellany</literal>小节，在Windows注册表中，则位于<literal>HKEY_LOCAL_MACHINE\Software\Tigris.org\Subversion\Config\Miscellany\global-ignores</literal>。用户配置值存放在<literal>HKEY_CURRENT_USER\Software\Tigris.org\Subversion</literal>下。</para>
        <para>基于注册表的配置项在基于文件的配置项<emphasis>之前</emphasis>解析，所以其配置项的值会被配置文件中相同配置项的值覆盖，换句话说，在Windows系统下这样查找配置信息；低位的位置优先于高位的位置：</para>
        <orderedlist inheritnum="ignore" continuation="restarts">
          <listitem>
            <para>命令行选项</para>
          </listitem>
          <listitem>
            <para>用户INI配置文件</para>
          </listitem>
          <listitem>
            <para>用户注册表值</para>
          </listitem>
          <listitem>
            <para>系统INI配置文件</para>
          </listitem>
          <listitem>
            <para>系统注册表值</para>
          </listitem>
        </orderedlist>
        <para>此外，虽然Windows注册表不支持<quote>注释掉</quote>这种概念，但是Subversion会忽略所有以井号(<literal>#</literal>)开始的字符，这允许你快速的取消一个选项而不需要删除整个注册表键，明显简化了恢复选项的过程。</para>
        <para><command>svn</command>命令行客户端不会尝试写Windows注册表，也不会在注册表中创建默认配置区。不过可以使用<command>REGEDIT</command>创建所需的键。此外，还可以创建一个<filename>.reg</filename>文件(例如<xref linkend="svn.advanced.confarea.windows-registry.ex-1"/>中的这一个)，并在文件浏览器中双击这个文件，文件中的数据就会合并到注册表中。</para>
        <example xml:id="svn.advanced.confarea.windows-registry.ex-1">
          <info>
            <title>注册表条目(.reg)文件样例</title>
          </info>
          <programlisting>
REGEDIT4

[HKEY_LOCAL_MACHINE\Software\Tigris.org\Subversion\Servers\groups]

[HKEY_LOCAL_MACHINE\Software\Tigris.org\Subversion\Servers\global]
"#http-proxy-host"=""
"#http-proxy-port"=""
"#http-proxy-username"=""
"#http-proxy-password"=""
"#http-proxy-exceptions"=""
"#http-timeout"="0"
"#http-compression"="yes"
"#neon-debug-mask"=""
"#ssl-authority-files"=""
"#ssl-trust-default-ca"=""
"#ssl-client-cert-file"=""
"#ssl-client-cert-password"=""

[HKEY_CURRENT_USER\Software\Tigris.org\Subversion\Config\auth]
"#store-passwords"="yes"
"#store-auth-creds"="yes"

[HKEY_CURRENT_USER\Software\Tigris.org\Subversion\Config\helpers]
"#editor-cmd"="notepad"
"#diff-cmd"=""
"#diff3-cmd"=""
"#diff3-has-program-arg"=""

[HKEY_CURRENT_USER\Software\Tigris.org\Subversion\Config\tunnels]

[HKEY_CURRENT_USER\Software\Tigris.org\Subversion\Config\miscellany]
"#global-ignores"="*.o *.lo *.la #*# .*.rej *.rej .*~ *~ .#* .DS_Store"
"#log-encoding"=""
"#use-commit-times"=""
"#no-unlock"=""
"#enable-auto-props"=""

[HKEY_CURRENT_USER\Software\Tigris.org\Subversion\Config\auto-props]
</programlisting>
        </example>
        <para>上面例子里显示的<filename>.reg</filename>文件中，包含了一些最常用的配置选项和它们的缺省值。注意，上面的例子中不仅包含了系统设置(关于网络代理相关的选项)，也包含了用户设置(指定的编辑器程序，是否保存密码，以及其它选项)。同时要注意的是，所有选项都注释掉了，要启用其中的选项，只需删除该选项名称前面的井号(<literal>#</literal>)，然后设置相应的值就可以了。</para>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.advanced.confarea.opts">
        <info>
          <title>配置选项</title>
        </info>
        <!-- TODO(cmpilato): Rework and move this section to the Reference -->
        <para>本节我们会详细讨论Subversion目前支持的运行配置选项。</para>
        <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
        <section xml:id="svn.advanced.confarea.opts.servers">
          <info>
            <title>服务器</title>
          </info>
          <para><filename>servers</filename>文件保存了Subversion关于网络层的配置选项，这个文件有两个特别的小节：<literal>groups</literal> 和<literal>global</literal>。<literal>groups</literal>小节是一个交叉引用表，其中的关键字是<filename>servers</filename>文件中其它小节的名字，值则是<firstterm>globs</firstterm>格式的，也就是包含通配符的字符序列，对应于接收Subversion请求的主机名。</para>
          <programlisting>
[groups]
beanie-babies = *.red-bean.com
collabnet = svn.collab.net

[beanie-babies]
…

[collabnet]
…
</programlisting>
          <para>当通过网络访问Subversion服务器时，客户端会设法匹配正在尝试连接的服务器名字和<literal>groups</literal>小节中的glob名称，如果发现匹配，Subversion会在<filename>servers</filename>文件中查找对应于这个glob名称的小节，并从该小节中去读取真实的网络配置设置。</para>
          <para>如果没有能够匹配到<literal>groups</literal>中的glob名称，<literal>global</literal>小节中的选项就会发生作用。<literal>global</literal>小节中的选项与其他小节一样(当然是除了<literal>groups</literal>小节)，这些选项是：</para>
          <variablelist>
            <varlistentry>
              <term>
                <literal>http-proxy-exceptions</literal>
              </term>
              <listitem>
                <para>这里指定了一组逗号分割的列表，其内容是无须代理服务器可以直接访问的版本库主机名模式，模式语法与Unix的shell中的文件名相同，其中任何匹配的版本库主机不会通过代理访问。</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>http-proxy-host</literal>
              </term>
              <listitem>
                <para>代理服务器的详细主机名，是HTTP为基础的Subversion请求必须通过的，缺省值为空，意味着Subversion不会尝试通过代理服务器进行HTTP请求，而会尝试直接连接目标机器。</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>http-proxy-port</literal>
              </term>
              <listitem>
                <para>代理服务器的详细端口，缺省值为空。</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>http-proxy-username</literal>
              </term>
              <listitem>
                <para>代理服务器的用户名，缺省值为空。</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>http-proxy-password</literal>
              </term>
              <listitem>
                <para>代理服务器的密码，缺省为空。</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>http-timeout</literal>
              </term>
              <listitem>
                <para>等待服务器响应的时间，以秒为单位，如果你的网络速度较慢，导致Subversion的操作超时，你可以加大这个数值，缺省值是<literal>0</literal>，意思是让HTTP库Neon使用自己的缺省值。</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>http-compression</literal>
              </term>
              <listitem>
                <para>这说明是否在与设置好DAV的服务器通讯时使用网络压缩请求，缺省值是<literal>yes</literal>(尽管只有在这个功能编译到网络层时压缩才会有效)，设置<literal>no</literal>来关闭压缩，如调试网络传输时。</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>http-library</literal>
              </term>
              <listitem>
                <para>Subversion provides a pair of repository access
                modules that understand its WebDAV network protocol.
                The original one, which shipped with Subversion 1.0, is
                <literal>libsvn_ra_neon</literal> (though back then it
                was called <literal>libsvn_ra_dav</literal>).  Newer
                Subversion versions also provide
                <literal>libsvn_ra_serf</literal>, which uses a
                different underlying implementation and aims to
                support some of the newer HTTP concepts.</para>
                <para>At this point, <literal>libsvn_ra_serf</literal>
                is still considered experimental, though it appears to
                work in the common cases quite well.  To encourage
                experimentation, Subversion provides the
                <literal>http-library</literal> runtime configuration
                option to allow users to specify (generally, or in a
                per-server-group fashion) which WebDAV access module
                they'd prefer to use—<literal>neon</literal> or
                <literal>serf</literal>.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>http-auth-types</literal>
              </term>
              <listitem>
                <para>This option is a semicolon-delimited list of
                authentication types supported by the Neon-based
                WebDAV repository access modules.  Valid members of
                this list are <literal>basic</literal>,
                <literal>digest</literal>, and
                <literal>negotiate</literal>.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>neon-debug-mask</literal>
              </term>
              <listitem>
                <para>只是一个整形的掩码，底层的HTTP库Neon用来选择产生调试的输出，缺省值是<literal>0</literal>，意思是关闭所有的调试输出，关于Subversion使用Neon的详细信息，见<xref linkend="svn.developer"/>。</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>ssl-authority-files</literal>
              </term>
              <listitem>
                <para>这是一个分号分割的路径和文件列表，这些文件包含了Subversion客户端在用HTTPS访问时可以接受的认证授权(或者CA)证书。</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>ssl-trust-default-ca</literal>
              </term>
              <listitem>
                <para>如果你希望Subversion可以自动相信OpenSSL携带的缺省的CA，可以设置为<literal>yes</literal>。</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>ssl-client-cert-file</literal>
              </term>
              <listitem>
                <para>如果一个主机(或是一些主机)需要一个SSL客户端证书，你会收到一个提示说需要证书的路径。通过设置这个路径你的Subversion客户端可以自动找到你的证书而不会打扰你。没有标准的存放位置；Subversion会从任何你指定的路径得到这个文件。</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>ssl-client-cert-password</literal>
              </term>
              <listitem>
                <para>如果你的SSL客户端证书文件是用密码加密的，Subversion会在每次使用证书时请你输入密码，如果你发现这很讨厌(并且不介意把密码存放在<filename>servers</filename>文件中)，你可以设置这个参数为证书的密码，这样就不会再收到密码输入提示了。</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
        <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
        <section xml:id="svn.advanced.confarea.opts.config">
          <info>
            <title>配置</title>
          </info>
          <para>其它的Subversion运行选项保存在<filename>config</filename>文件中，这些运行选项与网络连接无关，只是一些正在使用的选项，但是为了应对未来的扩展，也按小节划分成组。</para>
          <para><literal>auth</literal>小节保存了Subversion相关的认证和授权的设置，它包括：</para>
          <variablelist>
            <varlistentry>
              <term>
                <literal>store-passwords</literal>
              </term>
              <listitem>
                <para>这告诉Subversion是否缓存服务器认证要求时用户提供的密码，缺省值是<literal>yes</literal>。设置为<literal>no</literal>可以关闭在存盘的密码缓存，你可以通过<command>svn</command>的<option>--no-auth-cache</option>命令行参数(那些支持这个参数的子命令)来覆盖这个设置，详细信息请见<xref linkend="svn.serverconfig.netmodel.credcache"/>。</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>store-auth-creds</literal>
              </term>
              <listitem>
                <para>这个设置与<literal>store-passwords</literal>相似，不过设置了这个选项将会保存<emphasis>所有</emphasis>认证信息，如用户名、密码、服务器证书，以及其他任何类型的可以缓存的凭证。</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <para><literal>helpers</literal>小节控制完成Subversion任务的外部程序，正确的选项包括：</para>
          <variablelist>
            <varlistentry>
              <term>
                <literal>editor-cmd</literal>
              </term>
              <listitem>
                <para>This specifies the program Subversion will use to
                query the user for certain types of textual metadata
                or when interactively resolving conflicts.  See
                <xref linkend="svn.advanced.externaleditors"/> for
                more details on using external text editors with
                Subversion.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>diff-cmd</literal>
              </term>
              <listitem>
                <para>这里是比较程序的绝对路径，当Subversion生成了<quote>diff</quote>输出时(例如当使用<command>svn diff</command>命令)就会使用，缺省Subversion会使用一个内置的比较库—设置这个参数会强制它使用外部程序执行这个任务，此类程序的更多信息见<xref linkend="svn.advanced.externaldifftools"/>。</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>diff3-cmd</literal>
              </term>
              <listitem>
                <para>这指定了一个三向的比较程序，Subversion使用这个程序来合并用户和从版本库接受的修改，缺省Subversion会使用一个内置的比较库—设置这个参数会导致它会使用外部程序执行这个任务，此类程序的更多信息见<xref linkend="svn.advanced.externaldifftools"/>。</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>diff3-has-program-arg</literal>
              </term>
              <listitem>
                <para>如果<literal>diff3-cmd</literal>选项设置的程序接受一个<option>--diff-program</option>命令行参数，这个标记必须设置为<literal>true</literal>。</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>merge-tool-cmd</literal>
              </term>
              <listitem>
                <para>This specifies the program that Subversion will
                use to perform three-way merge operations on your
                versioned files.  See <xref linkend="svn.advanced.externaldifftools"/> for more
                details on using such programs.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <para><literal>tunnels</literal>小节允许你定义一个<command>svnserve</command>和<literal>svn://</literal>客户端连接使用的管道模式，更多细节见<xref linkend="svn.serverconfig.svnserve.sshauth"/>。</para>
          <para><literal>miscellany</literal>小节是一些没法归到别处的选项。 <footnote><para>就是一个大杂烩？</para></footnote>在本小节，你会找到：</para>
          <variablelist>
            <varlistentry>
              <term>
                <literal>global-ignores</literal>
              </term>
              <listitem>
                <para>当运行<command>svn status</command>命令时，Subversion会和版本化的文件一样列出未版本化的文件和目录，并使用<literal>?</literal>字符(见see <xref linkend="svn.tour.cycle.examine.status"/>)标记，有时候察看无关的未版本化文件会很讨厌—比如程序编译产生的对象文件—的显示出来。<literal>global-ignores</literal>选项是一个空格分隔的列表，用来描述Subversion在它们版本化之前不想显示的文件和目录，缺省值是 <literal>*.o *.lo *.la #*# .*.rej *.rej .*~ *~ .#* .DS_Store</literal>。</para>
                <para>就像<command>svn status</command>，<command>svn add</command>和<command>svn import</command>命令也会忽略匹配这个列表的文件，你可以用单个的<option>--no-ignore</option>命令行参数来覆盖这个选项。</para>
                <para>For information on more fine-grained control of ignored items, see <xref linkend="svn.advanced.props.special.ignore"/>.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>enable-auto-props</literal>
              </term>
              <listitem>
                <para>这里指示Subversion自动对新加的或者导入的文件设置属性，缺省值是<literal>no</literal>，可以设置为<literal>yes</literal>来开启自动添加属性，这个文件的<literal>auto-props</literal>小节会说明哪些属性会被设置到哪些文件。</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>log-encoding</literal>
              </term>
              <listitem>
                <para>这个变量设置提交日志缺省的字符集，是<option>--encoding</option>选项(见<xref linkend="svn.ref.svn.sw"/>)的永久形式，Subversion版本库保存了一些UTF-8的日志信息，并且假定你的日志信息是用操作系统的本地编码，如果你提交的信息使用别的编码方式，你一定要指定不同的编码。</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>use-commit-times</literal>
              </term>
              <listitem>
                <para>通常你的工作拷贝文件会有最后一次被进程访问的时间戳，不管是你自己的编辑器还是用<command>svn</command>子命令。这通常对人们开发软件提供了便利，因为编译系统通常会通过查看时间戳来决定那些文件需要重新编译。</para>
                <para>在其他情形，有时候如果工作拷贝的文件时间戳反映了上一次在版本库中更改的时间会非常好，<command>svn export</command>命令会一直放置这些<quote>上次提交的时间戳</quote>放到它创建的目录树。通过设置这个config参数为<literal>yes</literal>，<command>svn checkout</command>、<command>svn update</command>、 <command>svn switch</command>和<command>svn revert</command>命令也会为它们操作的文件设置上次提交的时间戳。</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>mime-types-file</literal>
              </term>
              <listitem>
                <para>This option, new to Subversion 1.5, specifies the
                path of a MIME types mapping file, such as the
                <filename>mime.types</filename> file provided by the
                Apache HTTP Server.  Subversion uses this file to
                assign MIME types to newly added or imported files.
                See <xref linkend="svn.advanced.props.auto"/> and
                <xref linkend="svn.advanced.props.special.mime-type"/> for more about Subversion's detection and use of
                file content types.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>preserved-conflict-file-exts</literal>
              </term>
              <listitem>
                <para>The value of this option is a space-delimited list
                of file extensions that Subversion should preserve
                when generating conflict filenames.  By default, the
                list is empty.  This option is new to Subversion
                1.5.</para>
                <para>When Subversion detects conflicting file content
                changes, it defers resolution of those conflicts to the
                user.  To assist in the resolution, Subversion keeps
                pristine copies of the various competing versions of
                the file in the working copy.  By default, those
                conflict files have names constructed by appending to
                the original filename a custom extension such as
                <filename>.mine</filename> or
                <filename>.<replaceable>REV</replaceable></filename>
                (where <replaceable>REV</replaceable> is a revision
                number).  A mild annoyance with this naming scheme is
                that on operating systems where a file's extension
                determines the default application used to open and
                edit that file, appending a custom extension prevents
                the file from being easily opened by its native
                application.  For example, if the file
                <filename>ReleaseNotes.pdf</filename> was conflicted,
                the conflict files might be named
                <filename>ReleaseNotes.pdf.mine</filename> or
                <filename>ReleaseNotes.pdf.r4231</filename>.  While
                your system might be configured to use Adobe's Acrobat
                Reader to open files whose extensions are
                <filename>.pdf</filename>, there probably isn't an
                application configured on your system to open all
                files whose extensions are
                <filename>.r4231</filename>.</para>
                <para>You can fix this annoyance by using this
                configuration option, though.  For files with one of
                the specified extensions, Subversion will append to
                the conflict file names the custom extension just as
                before, but then also reappend the file's original
                extension.  Using the previous example, and assuming
                that <literal>pdf</literal> is one of the extensions
                configured in this list thereof, the conflict files
                generated for <filename>ReleaseNotes.pdf</filename>
                would instead be named
                <filename>ReleaseNotes.pdf.mine.pdf</filename> and
                <filename>ReleaseNotes.pdf.r4231.pdf</filename>.
                Because each file ends in
                <filename>.pdf</filename>, the correct default
                application will be used to view them.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>交互式冲突</literal>
              </term>
              <listitem>
                <para>This is a Boolean option that specifies whether
                Subversion should try to resolve conflicts
                interactively.  If its value is <literal>yes</literal>
                (which is the default value), Subversion will prompt
                the user for how to handle conflicts in the manner
                demonstrated in <xref linkend="svn.tour.cycle.resolve"/>.  Otherwise, it will simply flag the conflict and
                continue its operation, postponing resolution to a later
                time.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>no-unlock</literal>
              </term>
              <listitem>
                <para>This Boolean option corresponds to <command>svn
                commit</command>'s <option>--no-unlock</option>
                option, which tells Subversion not to release locks on
                files you've just committed.  If this runtime option
                is set to <literal>yes</literal>, Subversion will
                never release locks automatically, leaving you to run
                <command>svn unlock</command> explicitly.  It defaults
                to <literal>no</literal>.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <para><literal>auto-props</literal>小节控制Subversion客户端自动设置提交和导入的文件的属性的能力，它可以包含任意数量的键-值对，格式是<literal>PATTERN = PROPNAME=PROPVALUE</literal>，其中<literal>PATTERN</literal>是一个文件模式，匹配一系列文件名，此行其它两项为属性和值。如果一个文件匹配多次，会导致有多个属性集；然而，没有手段保障自动属性不会按照配置文件中的顺序应用，所以你可以一个规则<quote>覆盖</quote>另一个。你可以在<filename>config</filename>文件找到许多自动属性的用法实例。最后，如果你希望开启自动属性，不要忘了设置<literal>miscellany</literal>小节的<literal>enable-auto-props</literal>为<literal>yes</literal>。</para>
        </section>
      </section>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.advanced.l10n">
      <info>
        <title>本地化</title>
      </info>
      <para><firstterm>本地化</firstterm>是让程序按照地区特定方式运行的行为，如果一个程序的格式、数字或者是日期是你的本地方式，或者是打印的信息(或者是接受的输入)是你本地的语言，这个程序被叫做已经<firstterm>本地化了</firstterm>，这部分描述了针对本地化的Subversion的步骤。</para>
      <!-- =============================================================== -->
      <section xml:id="svn.advanced.l10n.understanding">
        <info>
          <title>理解区域设置</title>
        </info>
        <para>许多现代操作系统都有一个<quote>当前地区</quote>的概念—也就是本地化习惯服务的国家和地区。这些习惯—通常是被一些运行配置机制选择—影响程序展现数据的方式，也有接受用户输入的方式。</para>
        <para>在类Unix的系统，你可以运行<command>locale</command>命令来检查本地关联的运行配置的选项值：</para>
        <screen>
$ locale
LANG=
LC_COLLATE="C"
LC_CTYPE="C"
LC_MESSAGES="C"
LC_MONETARY="C"
LC_NUMERIC="C"
LC_TIME="C"
LC_ALL="C"
$
</screen>
        <para>输出是一个本地相关的环境变量和它们的值，在这个例子里，所有的变量设置为缺省的<literal>C</literal>地区，但是用户可以设置这些变量为特定的国家/语言代码组合。举个例子，如果有人设置<literal>LC_TIME</literal>变量为<literal>fr_CA</literal>，然后程序会知道使用讲法语的加拿大期望的格式来显示时间和日期信息。如果一个人会设置<literal>LC_MESSAGES</literal>变量为<literal>zh_TW</literal>，程序会知道使用繁体中文显示可读信息。如果设置<literal>LC_ALL</literal>的效果同分别设置所有的位置变量为同一个值有相同的效果。<literal>LANG</literal>用来作为没有设置地区变量的缺省值，为了查看Unix系统所有的地区列表，运行<command>locale -a</command>命令。</para>
        <para>在Windows，地区配置是通过<quote>地区和语言选项</quote>控制面板管理的，可以从已存在的地区查看选择，甚至可以自定义(会是个很讨厌的复杂事情)许多显示格式习惯。</para>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.advanced.l10n.svnuse">
        <info>
          <title>Subversion 对区域设置的使用</title>
        </info>
        <para>Subversion客户端，<command>svn</command>通过两种方式支持当前的地区配置。首先，它会注意<literal>LC_MESSAGES</literal>的值，然后尝试使用特定的语言打印所有的信息，例如：</para>
        <screen>
$ export LC_MESSAGES=de_DE
$ svn help cat
cat: Gibt den Inhalt der angegebenen Dateien oder URLs aus.
Aufruf: cat ZIEL[@REV]...
…
</screen>
        <para>这个行为在Unix和Windows上同样工作，注意，尽管有时你的操作系统支持某个地区，Subversion客户端可能不能讲特定的语言。为了制作本地化信息，志愿者可以提供各种语言的翻译。翻译使用GNU gettext包编写，相关的翻译模块使用<filename>.mo</filename>作为后缀名。举个例子，德国翻译文件为<filename>de.mo</filename>。翻译文件安装到你的系统的某个位置，在Unix它们会在<filename>/usr/share/locale/</filename>，而在Windows它们通常会在Subversion安装的<filename>\share\locale\</filename>目录。一旦安装，一个命名在程序后面的模块会为此提供翻译。举个例子，<filename>de.mo</filename>会最终安装到<filename>/usr/share/locale/de/LC_MESSAGES/subversion.mo</filename>，通过查看安装的<filename>.mo</filename>文件，我们可以看到Subversion支持的语言。</para>
        <para>第二种支持地区设置的方式包括<command>svn</command>怎样解释你的输入，版本库使用UTF-8保存了所有的路径，文件名和日志信息。在这种情况下，版本库是<firstterm>国际化的</firstterm>—也就是版本库准备接受任何人类的语言。这意味着，无论如何Subversion客户端要负责发送UTF-8的文件名和日志信息到版本库，为此，必须将数据从本地位置转化为UTF-8。</para>
        <para>举个例子，你创建了一个文件叫做<filename>caffè.txt</filename>，然后提交了这个文件，你写的日志信息是<quote>Adesso il caffè è più forte</quote>，文件名和日志信息都包含非ASCII字符，但是因为你的位置设置为<literal>it_IT</literal>，Subversion知道把它们作为意大利语解释，在发送到版本库之前，它用意大利字符集转化数据为UTF-8。</para>
        <para>注意当版本库要求UTF-8文件名和日志信息时，它<emphasis>不会</emphasis>注意到文件的内容，Subversion会把文件内容看作字节串，没有任何客户端和服务器会尝试理解或是编码这些内容。</para>
        <sidebar>
          <info>
            <title>字符集转换错误</title>
          </info>
          <para>当使用Subversion，你或许会碰到一个字符集转化关联的错误：</para>
          <screen>
svn: Can't convert string from native encoding to 'UTF-8':
…
svn: Can't convert string from 'UTF-8' to native encoding:
…
</screen>
          <para>这个错误信息通常会发生在Subversion客户端从版本库接收到一个UTF-8串，但字符不能转化为当前的地区文字时，举个例子，如果你的地区设置是<literal>en_US</literal>，但是一个写作者使用日本文件名提交，你会在<command>svn update</command>接受文件时会看到这个错误。</para>
          <para>解决方案或者是设置你的地区为<emphasis>可以</emphasis>表示即将到来的UTF-8数据，或者是修改版本库的文件名或信息。(不要忘记和你的合作者拍拍手—项目必须首先决定通用的语言，这样所有的参与者会使用相同的地区设置。)</para>
        </sidebar>
      </section>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.advanced.externaleditors">
      <info>
        <title>使用外置编辑器</title>
      </info>
      <para>The most obvious way to get data into Subversion is through
      the addition of files to version control, committing changes to
      those files, and so on.  But other pieces of
      information besides merely versioned file data live in your
      Subversion repository.  Some of these bits of
      information—commit log messages, lock comments, and some
      property values—tend to be textual in nature and are
      provided explicitly by users.  Most of this information can be
      provided to the Subversion command-line client using the
      <option>--message</option> (<option>-m</option>) and
      <option>--file</option> (<option>-F</option>) options with the
      appropriate subcommands.</para>
      <para>Each of these options has its pros and cons.  For example,
      when performing a commit, <option>--file</option>
      (<option>-F</option>) works well if you've already prepared a
      text file that holds your commit log message.  If you didn't,
      though, you can use <option>--message</option>
      (<option>-m</option>) to provide a log message on the command
      line.  Unfortunately, it can be tricky to compose anything more
      than a simple one-line message on the command line.  Users want
      more flexibility—multiline, free-form log message editing
      on demand.</para>
      <para>Subversion supports this by allowing you to specify an
      external text editor that it will launch as necessary
      to give you a more powerful input mechanism for this textual
      metadata.  There are several ways to tell Subversion which
      editor you'd like use.  Subversion checks the following things,
      in the order specified, when it wants to launch such an
      editor:</para>
      <orderedlist inheritnum="ignore" continuation="restarts">
        <listitem>
          <para>命令行选项<literal>--editor-cmd</literal></para>
        </listitem>
        <listitem>
          <para><literal>SVN_EDITOR</literal> environment variable</para>
        </listitem>
        <listitem>
          <para><literal>editor-cmd</literal> runtime configuration option</para>
        </listitem>
        <listitem>
          <para><literal>VISUAL</literal> environment variable</para>
        </listitem>
        <listitem>
          <para><literal>EDITOR</literal> environment variable</para>
        </listitem>
        <listitem>
          <para>也有可能Subversion会有一个内置的缺省值(官方编译版本不是如此)</para>
        </listitem>
      </orderedlist>
      <para>所有这些选项和变量(不像<literal>diff-cmd</literal>)的值的开头都是shell中要执行的命令行，Subversion会追加一个空格和一个需要编辑的临时文件，编辑器必须修改临时文件，并且返回一个0来表明成功。</para>
      <para>As noted, external editors can be used to provide commit log
      messages to any of the committing subcommands (such as
      <command>svn commit</command> or <command>import</command>,
      <command>svn mkdir</command> or <command>delete</command> when
      provided a URL target, etc.), and Subversion will try to
      launch the editor automatically if you don't specify either of
      the <option>--message</option> (<option>-m</option>) or
      <option>--file</option> (<option>-F</option>) options.  The
      <command>svn propedit</command> command is built almost entirely
      around the use of an external editor.  And beginning in version
      1.5, Subversion will also use the configured external text
      editor when the user asks it to launch an editor during
      interactive conflict resolution.  Oddly, there doesn't appear to
      be a way to use external editors to interactively provide lock
      comments.</para>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.advanced.externaldifftools">
      <info>
        <title>使用外置比较与合并工具</title>
      </info>
      <para>Subversion与外置两向和三向区别工具的接口可以追溯到很久以前，当时Subversion的唯一文本比较能力是建立在GNU的工具链之上，特别是<command>diff</command>和<command>diff3</command>工具，为了得到Subversion需要的方式，它使用非常复杂的选项和参数调用这些工具，而这些选项和参数都是工具特定的，渐渐的，Subversion发展了自己的比较区别库作为备份机制。<placeholder-1/><option>--diff-cmd</option>和<option>--diff3-cmd</option>选项是添加到Subversion的命令行客户端，所以用户可以更加容易的指明他们最喜欢的使用的GNU diff和diff3工具，而不是新奇的内置比较库，如果使用了这些选项，Subversion会忽略内置的比较库，转而使用外置程序，使用冗长的参数列表，目前还是这种情况。</para>
      <para>人们很快意识到使用简单的配置机制必须使Subversion使用位于特定位置的GNU diff和diff3工具，毕竟，Subversion并不验证其被告之要执行的程序是否是GNU的工具链的比较工具。唯一可以配置的方面是外置工具在系统的位置—而不是选项集，参数顺序等等。Subversion一直将这些GNU工具选项发给你的外置比较工具，而不管程序是否可以理解那些选项，那不是所有用户直觉的方式。</para>
      <para>使用外置比较和合并工具的关键是使用包裹脚本将Subversion的输出转化为你的脚本程序可以理解的形式，然后将这些比较工具的输出转化为你的Subversion期望的格式—GNU工具可能使用的格式，下面的小节覆盖了那些期望格式的细节。</para>
      <note>
        <para>何时启动双向或三向的文本比较或合并的决定完全是Subversion的决定，而这个决定是根据文件的<literal>svn:mime-type</literal>属性作出的，这意味着，例如，即使你有一个可以识别Microsoft Word格式的比较或合并工具，当你对一个Word文件设置为非人工可读(例如<literal>application/msword</literal>)时，依然不会调用这个识别Word的工具。关于MIME type的设定，可以见<xref linkend="svn.advanced.props.special.mime-type"/>。</para>
      </note>
      <para>Subversion 1.5 introduces interactive resolution of
      conflicts (described in <xref linkend="svn.tour.cycle.resolve"/>), and one of the options provided to users is the ability to
      launch a third-party merge tool.  If this action is taken,
      Subversion will consult the <literal>merge-tool-cmd</literal>
      runtime configuration option to find the name of an external
      merge tool and, upon finding one, will launch that tool with the
      appropriate input files.  This differs from the configurable
      three-way differencing tool in a couple of ways.  First, the
      differencing tool is always used to handle three-way
      differences, whereas the merge tool is employed only when
      three-way difference application has detected a conflict.
      Second, the interface is much cleaner—your configured
      merge tool need only accept as command-line parameters four path
      specifications:  the base file, the <quote>theirs</quote> file
      (which contains upstream changes), the <quote>mine</quote> file
      (which contains local modifications), and the path of the file
      where the final resolved contents should be stored.</para>
      <!-- =============================================================== -->
      <section xml:id="svn.advanced.externaldifftools.diff">
        <info>
          <title>外置 diff</title>
        </info>
        <para>Subversion可以调用适合GNU参数的diff工具，并期望外置程序能够返回成功的错误代码。对于大多数可用的diff程序，只有第6、7参数，diff两边文件的路径。需要注意Subversion对于每个修改的文件都要以异步方式(或<quote>后台</quote>)运行diff程序，你会得到许多并行的实例。最后，Subversion期望你的程序在发现区别时返回错误代码1，没有区别则返回0—任何其他的返回值都被认为是严重错误。 <footnote><para>GNU的diff手册这样说的：<quote>返回0意味着没有区别，1是有有区别，其它值意味着出现问题。</quote></para></footnote></para>
        <para><xref linkend="svn.advanced.externaldifftools.diff.ex-1"/>和<xref linkend="svn.advanced.externaldifftools.diff.ex-2"/>分别是Bourne shell和Windows批处理外置diff工具的包裹器模版。</para>
        <example xml:id="svn.advanced.externaldifftools.diff.ex-1">
          <info>
            <title>diffwrap.py</title>
          </info>
          <programlisting>
#!/bin/sh

# Configure your favorite diff program here.
DIFF="/usr/local/bin/my-diff-tool"

# Subversion provides the paths we need as the sixth and seventh 
# parameters.
LEFT=${6}
RIGHT=${7}

# Call the diff command (change the following line to make sense for
# your diff program).
$DIFF --left $LEFT --right $RIGHT

# Return an errorcode of 0 if no differences were detected, 1 if some were.
# Any other errorcode will be treated as fatal.
</programlisting>
        </example>
        <example xml:id="svn.advanced.externaldifftools.diff.ex-2">
          <info>
            <title>diffwrap.bat</title>
          </info>
          <programlisting>
@ECHO OFF

REM Configure your favorite diff program here.
SET DIFF="C:\Program Files\Funky Stuff\My Diff Tool.exe"

REM Subversion provides the paths we need as the sixth and seventh 
REM parameters.
SET LEFT=%6
SET RIGHT=%7

REM Call the diff command (change the following line to make sense for
REM your diff program).
%DIFF% --left %LEFT% --right %RIGHT%

REM Return an errorcode of 0 if no differences were detected, 1 if some were.
REM Any other errorcode will be treated as fatal.
</programlisting>
        </example>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.advanced.externaldifftools.diff3">
        <info>
          <title>外置 diff3</title>
        </info>
        <para>Subversion按照符合GNU的diff3的参数调用合并程序，期望外置程序会返回成功的错误代码，并且完整合并的文件结果打印到标准输出(这样Subversion可以重定向这些东西到适当的版本控制下的文件)。对于大多数可选的合并程序，只有第9、10和11参数，分别代表<quote>mine</quote>、<quote>older</quote>和<quote>yours</quote>的路径。需要注意，因为Subversion依赖于你的合并程序的输出，你的包裹脚本在输出发送到Subversion之前不要退出。当最终退出，如果合并成功返回0，如果有为解决的冲突则返回1—其它返回值都是严重错误。</para>
        <para><xref linkend="svn.advanced.externaldifftools.diff3.ex-1"/>和<xref linkend="svn.advanced.externaldifftools.diff3.ex-2"/>分别是Bourne shell和Windows批处理外置diff工具的包裹器模版。</para>
        <example xml:id="svn.advanced.externaldifftools.diff3.ex-1">
          <info>
            <title>diff3wrap.py</title>
          </info>
          <programlisting>
#!/bin/sh

# Configure your favorite diff3/merge program here.
DIFF3="/usr/local/bin/my-merge-tool"

# Subversion provides the paths we need as the ninth, tenth, and eleventh 
# parameters.
MINE=${9}
OLDER=${10}
YOURS=${11}

# Call the merge command (change the following line to make sense for
# your merge program).
$DIFF3 --older $OLDER --mine $MINE --yours $YOURS

# After performing the merge, this script needs to print the contents
# of the merged file to stdout.  Do that in whatever way you see fit.
# Return an errorcode of 0 on successful merge, 1 if unresolved conflicts
# remain in the result.  Any other errorcode will be treated as fatal.
</programlisting>
        </example>
        <example xml:id="svn.advanced.externaldifftools.diff3.ex-2">
          <info>
            <title>diff3wrap.bat</title>
          </info>
          <programlisting>
@ECHO OFF

REM Configure your favorite diff3/merge program here.
SET DIFF3="C:\Program Files\Funky Stuff\My Merge Tool.exe"

REM Subversion provides the paths we need as the ninth, tenth, and eleventh 
REM parameters.  But we only have access to nine parameters at a time, so we
REM shift our nine-parameter window twice to let us get to what we need.
SHIFT
SHIFT
SET MINE=%7
SET OLDER=%8
SET YOURS=%9

REM Call the merge command (change the following line to make sense for
REM your merge program).
%DIFF3% --older %OLDER% --mine %MINE% --yours %YOURS%

REM After performing the merge, this script needs to print the contents
REM of the merged file to stdout.  Do that in whatever way you see fit.
REM Return an errorcode of 0 on successful merge, 1 if unresolved conflicts
REM remain in the result.  Any other errorcode will be treated as fatal.
</programlisting>
        </example>
      </section>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.customization.summary">
      <info>
        <title>总结</title>
      </info>
      <para>Sometimes there's a single right way to do things; sometimes
      there are many.  Subversion's developers understand that while
      the majority of its exact behaviors are acceptable to most of
      its users, there are some corners of its functionality where
      such a universally pleasing approach doesn't exist.  In those
      places, Subversion offers users the opportunity to tell it how
      <emphasis>they</emphasis> want it to behave.</para>
      <para>In this chapter, we explored Subversion's runtime
      configuration system and other mechanisms by which users can
      control those configurable behaviors.  If you are a developer,
      though, the next chapter will take you one step further.  It
      describes how you can further customize your Subversion
      experience by writing your own software against Subversion's
      libraries.</para>
    </section>
  </chapter>
  <!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
  <chapter xml:id="svn.developer">
    <info>
      <title>嵌入 Subversion</title>
    </info>
    <para>Subversion有一个模块化的设计，以库的形式由C编写和实现。每个库都有一个定义良好的目的和API，而且这些接口不仅仅为了Subversion本身使用，也可以为任何希望嵌入编程方式控制Subversion的软件。此外，Subversion的API不仅仅可以为C程序使用，也可以使用如Ptyhon、Perl、Java或Ruby等高级语言调用。</para>
    <para>本章是为那些希望编写代码或其他语言绑定与Subversion交互的人准备的。如果你围绕Subversion功能编写健壮的脚本来简化你的生活，设法开发Subversion与其他软件的复杂集成，或者只是对Subversion不同库模块提供功能感兴趣，这一章是为你准备的。然而，如果你不能预见你会以此种程度参与Subversion，你可以放心的跳过本章，略过本章不会影响你对Subversion使用的体验。</para>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.developer.layerlib">
      <info>
        <title>分层的库设计</title>
      </info>
      <para>每个Subversion核心模块都属于三层中的某一层—版本库层、版本库访问(RA)层或是客户端层(见<xref linkend="svn.intro.architecture.dia-1"/>)。我们很快就会考察这些层，但首先让我们看一下Subversion库的摘要目录，为了一致性，我们将通过它们的无扩展Unix库名(例如<filename>libsvn_fs</filename>、<filename>libsvn_wc</filename>和<filename>mod_dav_svn</filename>)来引用它们。</para>
      <variablelist>
        <varlistentry>
          <term>libsvn_client</term>
          <listitem>
            <para>客户端程序的主要接口</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>libsvn_delta</term>
          <listitem>
            <para>目录树和文本区别程序</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>libsvn_diff</term>
          <listitem>
            <para>上下文区别和合并例程</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>libsvn_fs</term>
          <listitem>
            <para>Subversion文件系统库和模块加载器</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>libsvn_fs_base</term>
          <listitem>
            <para>Berkeley DB文件系统后端</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>libsvn_fs_fs</term>
          <listitem>
            <para>本地文件系统(FSFS)后端</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>libsvn_ra</term>
          <listitem>
            <para>版本库访问通用组件和模块装载器</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>libsvn_ra_local</term>
          <listitem>
            <para>本地版本库访问模块</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>libsvn_ra_neon</term>
          <listitem>
            <para>WebDAV版本库访问模块</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>libsvn_ra_serf</term>
          <listitem>
            <para>另一个(实验性的) WebDAV 版本库访问模块</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>libsvn_ra_svn</term>
          <listitem>
            <para>一个自定义版本库访问模块</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>libsvn_repos</term>
          <listitem>
            <para>版本库接口</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>libsvn_subr</term>
          <listitem>
            <para>各色各样的有用的子程序</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>libsvn_wc</term>
          <listitem>
            <para>工作拷贝管理库</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>mod_authz_svn</term>
          <listitem>
            <para>使用WebDAV访问Subversion版本库的Apache授权模块</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>mod_dav_svn</term>
          <listitem>
            <para>影射WebDAV操作为Subversion操作的Apache模块</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>单词<quote>各色各样的(miscellaneous)</quote>只在列表中出现过一次是一个好的迹象。Subversion开发团队非常注意将功能归入合适的层和库，或许模块化设计最大的好处就是从开发者的角度看减少了复杂性。作为一个开发者，你可以很快就描画出一副<quote>大图像</quote>，以便于你更精确地，也相对容易地找出某一功能所在的位置。</para>
      <para>模块化的另一个好处是我们有能力去构造一个全新的，能够完全实现相同API功能的库，以替换整个给定的模块，而又不会影响基础代码。在某种意义上，Subversion已经这样做了。<filename>libsvn_ra_neon</filename>、<filename>libsvn_ra_local</filename>、<filename>libsvn_ra_serf</filename>和<filename>libsvn_ra_svn</filename>都实现了相同的接口，均与版本库层进行通讯—libsvn_ra_loca与版本库直接连接，其他几个则通过网络。 <filename>libsvn_fs_baselibsvn_fs_fslibsvn_fs</filename></para>
      <para>客户端本身也得益于Subversion设计的模块化，Subversion的libsvn_client库提供了设计一个Subversion工作客户端(见<xref linkend="svn.developer.layerlib.client"/>)的绝大多数功能。所以尽管Subversion的发布版只有<command>svn</command>命令行客户端程序，依然有许多第三方的程序提供了各种形式的图形化客户端UI。这些GUI使用的API与命令行客户端完全相同。模块化类型的API的促使了大量Subversion客户端和IDE集成插件使用Subversion本身。</para>
      <!-- =============================================================== -->
      <section xml:id="svn.developer.layerlib.repos">
        <info>
          <title>版本库层</title>
        </info>
        <para>当提到Subversion版本库层时，我们通常会讨论两个基本概念—版本化文件系统实现(通过<filename>libsvn_fs</filename>访问，<filename>libsvn_fs_base</filename>和<filename>libsvn_fs_fs</filename>支持)，和包装在外的(以<filename>libsvn_repos</filename>实现)版本库逻辑。这些库提供了版本控制数据的存储和报告机制，这些层通过版本库访问层连接客户端层，从Subversion用户的角度，这些事情在整个过程的另一端。</para>
        <para>Subversion文件系统通过libsvn_fs API来访问，它并不是一个安装在操作系统之上的内核级的文件系统(例如Linux ext2或NTFS)，而是一个虚拟文件系统。它并未将<quote>文件</quote>和<quote>目录</quote>保存为真实的文件和目录(也就是用你熟知的shell程序可以浏览的那种)，而是采用了一种抽象的后端存储方式，这个后端存储方式有两种—一个是Berkeley DB数据库环境，另一个是普通文件表示。(要了解更多关于版本库后端的信息，请看<xref linkend="svn.reposadmin.basics.backends"/>)。除此之外，开发社区也非常有兴趣考虑在Subversion的未来版本中提供某种使用其它后端数据库系统的能力，也许是开放式数据库连接(ODBC)的机制。实际上，Google在2006中期启动Google Code主机服务项目之前做了一些类似的事情，它的部分开源项目组成员编写了新的Subversion文件系统，使用了他们的扩展性极好的Bigtable数据存储。</para>
        <para><filename>libsvn_fs</filename>支持的文件系统API包含了所有其他文件系统的功能：你可以创建和删除文件和目录、拷贝和移动、修改文件内容等等。它也包含了一些不太常用的特性，如对任意文件和目录添加、修改和删除元数据(<quote>properties</quote>)的能力。此外，Subversion文件系统是一个版本化的文件系统，意味着你修改你的目录树时，Subversion会记住修改以前的样子。也可以回到所有初始化版本库之后(且仅仅之后)的版本。</para>
        <para>所有你对目录树的修改包含在Subversion事务的上下文中，下面描述了修改文件系统的例程：</para>
        <orderedlist inheritnum="ignore" continuation="restarts">
          <listitem>
            <para>开始 Subversion 的提交事务。</para>
          </listitem>
          <listitem>
            <para>作出修改(添加、删除、属性修改等等。)。</para>
          </listitem>
          <listitem>
            <para>提交事务。</para>
          </listitem>
        </orderedlist>
        <para>一旦你提交了你的事务，你的文件系统修改就会永久的作为历史保存起来，每个这样的周期会产生一个新的树，所有的修订版本都是永远可以访问的一个不变的快照。</para>
        <sidebar>
          <info>
            <title>事务的其它信息</title>
          </info>
          <para>Subversion的事务概念，特别是在<filename>libsvn_fs_base</filename>中的数据库附近的代码，很容易与低层提供支持的数据库事务混淆。两种类型事务都提供了原子和隔离操作，换句话说，事务给你能力可以用<quote>全部或者没有</quote>样式执行一系列的动作—所有的动作都完全成功，或者是所有的<emphasis>没有</emphasis>发生—而且不会干扰别人操作数据。</para>
          <para>数据库事务通常围绕着一些对数据库本身的数据修改相关的小操作(如修改表行的内容)，Subversion是更大范围的事务，围绕着一些高一级的操作，如下一个修订版本文件系统的一组文件和目录的修改。如果这还不是很混乱，考虑这个：Subversion在创建Subversion事务(所以如果Subversion创建事务失败，数据库会看起来我们从来没有尝试创建)时会使用一个数据库事务！</para>
          <para>很幸运的是用户的文件系统API，数据库提供的事务支持本身几乎完全从外表隐藏(也是一个完全模块化的模式所应该的)。只有当你开始研究文件系统本身的实现时，这些事情才可见(或者是开始感兴趣)。</para>
        </sidebar>
        <para>大多数文件系统接口提供的功能作为一个动作发生在一个文件系统路径上，也就是，从文件系统的外部，描述和访问文件和目录独立版本的主要机制是经过如<filename>/foo/bar</filename>的路径，就像你在喜欢的shell程序中定位文件和目录。你通过传递它们的路径到相应的API功能来添加新的文件和目录，查询这些信息也是同样的机制。</para>
        <para>然而，不像大多数文件系统，一个单独的路径不足以在Subversion定位一个文件或目录，可以把目录树看作一个二维的系统，一个节点的兄弟代表了一种从左到右的动作，并且递减到子目录是一个向下的动作，<xref linkend="svn.developer.layerlib.repos.dia-1"/>展示了一个典型的树的形式。</para>
        <figure xml:id="svn.developer.layerlib.repos.dia-1">
          <info>
            <title>二维的文件和目录</title>
          </info>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/ch08dia1.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>当然，Subversion文件系统有一个其它文件系统所没有的第三维—时间！<footnote><para>我们理解这一定会给科幻小说迷带来一个震撼，他们认为时间是<emphasis>第四</emphasis>维的，我们要为提出这样一个不同理论的断言而伤害了他们的作出道歉。</para></footnote>在一个文件系统接口，几乎所有的功能都有个<parameter moreinfo="none">路径(path)</parameter>参数，也期望一个<parameter moreinfo="none">root</parameter>参数。<structname>svn_fs_root_t</structname>参数不仅描述了一个修订版本或一个Subversion事务(通常正好是一个修订版本)，而且提供了用来区分修订版本32的<filename>/foo/bar</filename>和修订版本98在同样路径的三维上下文环境。<xref linkend="svn.developer.layerlib.repos.dia-2"/>展示了修订版本历史作为添加的纬度进入到Subversion文件系统领域。</para>
        <figure xml:id="svn.developer.layerlib.repos.dia-2">
          <info>
            <title>版本时间 - 第三维！</title>
          </info>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/ch08dia2.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>像之前我们提到的，<filename>libsvn_fs</filename>的API感觉像是其它文件系统，只是有一个美妙的版本化能力。它设计为为所有对版本化的文件系统有兴趣的程序使用，不是巧合，Subversion本身也对这个功能很有兴趣。但是虽然文件系统API一定必须对基本的文件和目录版本化提供足够的支持，Subversion需要的更多—这是<filename>libsvn_repos</filename>到来的地方。</para>
        <para>Subversion版本库库(<filename>libsvn_repos</filename>)建立在(逻辑上讲)<filename>libsvn_fs</filename>的API之上，不仅仅提供了版本化文件系统的功能，它没有包裹所有的文件系统功能—只有文件系统常规周期中的主要事件使用版本库接口包裹，如包括Subversion事务的创建和提交，修订版本属性的修改。这些特别的事件使用版本库库包裹是因为它们有一些关联的钩子。版本库钩子系统并没有与与版本化文件系统的紧密关联，所以它们存在于版本库的包裹库。</para>
        <para>钩子机制需求是从文件系统代码的其它部分中抽象出单独的版本库库的一个原因，<filename>libsvn_repos</filename>的API提供了许多其他有用的工具，它们可以做到：</para>
        <itemizedlist>
          <listitem>
            <para>在Subversion版本库和版本库包括的文件系统的上创建、打开、销毁和执行恢复步骤。</para>
          </listitem>
          <listitem>
            <para>描述两个文件系统树的区别。</para>
          </listitem>
          <listitem>
            <para>关于所有(或者部分)修订版本中的文件系统中的一组文件的提交日志信息的查询</para>
          </listitem>
          <listitem>
            <para>产生可读的文件系统<quote>导出</quote>—一个文件系统修订版本的完整展现。</para>
          </listitem>
          <listitem>
            <para>解析导出格式，加载导出的版本到一个不同的Subversion版本库。</para>
          </listitem>
        </itemizedlist>
        <para>伴随着Subversion的发展，版本库库会随着文件系统提供更多的功能和配置选项而不断成长。</para>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.developer.layerlib.ra">
        <info>
          <title>版本库访问层</title>
        </info>
        <para>如果说Subversion版本库层是在<quote>这条线的另一端</quote>，那版本库访问(RA)层就是这条线。负责在客户端库和版本库之间编码数据，这一层包括<filename>libsvn_ra</filename>模块加载模块，RA模块本身(现在包括了<filename>libsvn_ra_neon</filename>、<filename>libsvn_ra_local</filename>、<filename>libsvn_ra_serf</filename>和<filename>libsvn_ra_svn</filename>)，和所有一个或多个RA模块需要的附加库，例如与Apache模块<filename>mod_dav_svn</filename>，或者<filename>libsvn_ra_svn</filename>的服务器<command>svnserve</command>。</para>
        <para>因为Subversion使用URL来识别版本库资源，URL模式的协议部分(通常是<literal>file:</literal>、<literal>http:</literal>、<literal>https:</literal>或<literal>svn:</literal>)用来监测那个RA模块用来处理通讯。每个模块注册一组它们知道如何<quote>说话</quote>的协议，所以RA加载器可以在运行中监测在手边的任务中使用哪个模块。通过运行<command>svn --version</command>，你可以监测Subversion命令行客户端所支持的RA模块和它们声明支持的协议：</para>
        <screen>
$ svn --version
svn, version 1.5.0 (Beta 1)
   compiled Mar 19 2008, 14:19:42

Copyright (C) 2000-2008 CollabNet.
Subversion is open source software, see http://subversion.tigris.org/
This product includes software developed by CollabNet (http://www.Collab.Net/).

The following repository access (RA) modules are available:

* ra_neon : Module for accessing a repository via WebDAV protocol using Neon.
  - handles 'http' scheme
  - handles 'https' scheme
* ra_svn : Module for accessing a repository using the svn network protocol.
  - handles 'svn' scheme
* ra_local : Module for accessing a repository on local disk.
  - handles 'file' scheme
* ra_serf : Module for accessing a repository via WebDAV protocol using serf.
  - handles 'http' scheme
  - handles 'https' scheme

$
</screen>
        <para>RA层导出的API包含了发送和接收版本化数据的必要功能，并且每一个存在的RA插件可以使用特定协议执行任务—libsvn_ra_dav同配置了<filename>mod_dav_svn</filename>模块的Apache HTTP服务器使用HTTP/WebDAV(可选SSL加密)通讯，<filename>libsvn_ra_svn</filename>同<command>svnserve</command>使用自定义网络协议通讯。</para>
        <para>对那些一直希望使用另一个协议来访问Subversion版本库的人，正好是为什么版本库访问层是模块化的！开发者可以简单的编写一个新的库来在一侧实现RA接口并且与另一侧的版本库通讯。你的新库可以使用存在的网络协议，或者发明你自己的。你可以使用进程间的通讯调用，或者—让我们发狂，我们会吗？—你甚至可以实现一个电子邮件为基础的协议，Subversion提供了API，你提供创造性。</para>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.developer.layerlib.client">
        <info>
          <title>客户端层</title>
        </info>
        <para>在客户端这一面，Subversion工作拷贝是所有动作发生的地方。大多数客户端库实现的功能是为了管理工作拷贝的目的实现的—满是文件子目录的目录是一个或多个版本库位置的可编辑的本地<quote>影射</quote>—从版本库访问层来回传递修改。</para>
        <para>Subversion的工作拷贝库，<filename>libsvn_wc</filename>直接负责管理工作拷贝的数据，为了完成这一点，库会在工作拷贝的每个目录的特殊子目录中保存关于工作拷贝的管理性信息。这个子目录叫做<filename>.svn</filename>，出现在所有工作拷贝目录里，保存了各种记录了状态和用来在私有工作区工作的文件和目录。对那些熟悉CVS的用户，<filename>.svn</filename>子目录与<filename>CVS</filename>工作拷贝管理目录的作用类似，关于<filename>.svn</filename>管理区域的更多信息，见本章的<xref linkend="svn.developer.insidewc"/>。</para>
        <para>Subversion客户端库<filename>libsvn_client</filename>具备最广泛的职责；它的工作是结合工作拷贝库和版本库访问库的功能，然后为希望普通版本控制的应用提供最高级的API。举个例子，<function>svn_client_checkout()</function>方法是用一个URL作为参数，传递这个URL到RA层然后在特定版本库打开一个会话。然后向版本库要求一个特定的目录树，然后把目录树发送给工作拷贝库，然后把完全的工作拷贝写到磁盘(<filename>.svn</filename>目录和一切)。</para>
        <para>客户端库是为任何程序使用设计的，尽管Subversion的源代码包括了一个标准的命令行客户端，用客户端库编写GUI客户端也是很简单，Subversion新的GUI(或者任何新的客户端，真的)不需要紧密围绕包含的命令行客户端—他们对具有相同功能、数据和回调机制的libsvn_client的API有完全的访问权利。事实上，Subversion源代码中包含了一段C程序(可以在<filename>tools/examples/minimal_client.c</filename>)例子，演示了如何利用Subversion客户端创建简单的客户端程序。</para>
        <sidebar>
          <info>
            <title>直接绑定 - 关于正确性</title>
          </info>
          <para>为什么GUI程序要直接访问<filename>libsvn_client</filename>而不以命令行客户端的包裹运行？除了效率以外，这也关系到潜在的正确性问题。一个命令行客户端程序(如Subversion提供的)如果绑定了客户端库，需要将反馈和请求数据字节从C翻译为可读的输出，这种翻译是有损耗的，程序不能得到API所提供的所有信息，或者是得到紧凑的信息。</para>
          <para>如果你已经包裹了这样一个命令行程序，第二个程序只能访问已经经过解释的(如我们提到的，不完全)信息，需要<emphasis>再次</emphasis>转化为<emphasis>它本身的</emphasis>展示格式。由于各层的包裹，原始数据的完整性越来越难以保证，结果很像对喜欢的录音带或录像带反复的拷贝(一个拷贝…)。</para>
          <para>但是关于直接绑定API使用，而不是包裹程序，这是Subversion项目对其API兼容性的承诺。在小版本的变化(如从1.3到1.4)中API的不会有函数原形的改变，简单来说就是你不需要将你程序源代码升级，因为你只是升级到了一个新版本的Subversion。某些方法可能会被废弃，但依然工作，这给你了缓冲时间来最终适应新API。Subversion的命令行输出没有这种兼容性承诺，可能会在每个版本更改。</para>
        </sidebar>
      </section>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.developer.insidewc">
      <info>
        <title>进入工作副本的管理区</title>
      </info>
      <para>像我们前面提到的，每个Subversion工作拷贝包含了一个特别的子目录叫做<filename>.svn</filename>，这个目录包含了关于工作拷贝目录的管理数据，Subversion使用<filename>.svn</filename>中的信息来追踪如下的数据：</para>
      <itemizedlist>
        <listitem>
          <para>工作拷贝中展示的目录和文件在版本库中的位置。</para>
        </listitem>
        <listitem>
          <para>工作拷贝中当前展示的文件和目录的修订版本。</para>
        </listitem>
        <listitem>
          <para>所有附加在文件和目录上的用户定义属性。</para>
        </listitem>
        <listitem>
          <para>原始(未编辑)的工作拷贝文件的拷贝。</para>
        </listitem>
      </itemizedlist>
      <para>Subversion工作拷贝管理区域的布局和内容主要是考虑的实现细节，不是被人来使用的。开发者被鼓励使用Subversion的API或工具来访问和处理工作拷贝数据，反对直接读写操作组成工作拷贝管理区域的文件。工作拷贝中管理数据采用的文件格式会不断改变—只是公共API成功的隐藏了这种改变。在本小节，我们将会探讨一些实现细节来安抚你们的焦虑。</para>
      <!-- =============================================================== -->
      <section xml:id="svn.developer.insidewc.entries">
        <info>
          <title>条目文件</title>
        </info>
        <para>或许<filename>.svn</filename>目录中最重要的单个文件就是<filename>entries</filename>了，这个条目文件是一个XML文档，包含了关于工作拷贝中的版本化的资源的大多数管理性信息，这个文件保留了版本库URL、原始修订版本、文件校验数据、可知的最后提交信息(作者、修订版本和时间戳)和本地拷贝历史—实际上是Subversion客户端关于一个版本化(或者是将要版本化的)资源的所有感兴趣的信息！</para>
        <para>熟悉CVS管理目录的人可能会发现，Subversion的<filename>.svn/entries</filename>实现了CVS的<filename>CVS/Entries</filename>、<filename>CVS/Root</filename>和<filename>CVS/Repository</filename>的功能。</para>
        <para><filename>.svn/entries</filename>的格式曾经多次修改，最初是XML文件，现在使用自定义的—尽管依然是可读的文件格式。早期的Subversion需要频繁调试文件内容，所以选择了XML这种格式，随着Subversion的成熟，频繁调试的需求消失了，而产生了用户对性能的要求。当然，Subversion的工作拷贝库可以从一种格式自动升级到另一种格式—按照老格式读取，然后按照新格式写—避免了重新检出工作拷贝，但是也造成了不同版本Subversion程序访问同一份工作拷贝的复杂情形。</para>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.developer.insidewc.base-and-props">
        <info>
          <title>原始副本和属性文件</title>
        </info>
        <para>如我们前面提到的，<filename>.svn</filename>也包含了一些原始的<quote>text-base</quote>文件版本，可以在<filename>.svn/text-base</filename>看到。这些原始文件的好处是多方面的—察看本地修改和区别不需要经过网络访问，减少传递修改时的数据—但是随之而来的代价是每个版本化的文件都在磁盘至少保存两次，现在看来这是对大多数文件可以忽略不计的一个惩罚。但是，当你版本控制的文件增多之后形势会变得很严峻，我们已经注意到了应该可以选择使用<quote>text-base</quote>，但是具有讽刺意味的是，当版本化文件增大时，<quote>text-base</quote>文件的存在会更加重要—谁会希望在提交一个小修改时在网络上传递一个大文件？</para>
        <para>同<quote>text-base</quote>文件的用途一样的还有属性文件和它们的<quote>prop-base</quote>拷贝，分别位于<filename>.svn/props</filename>和<filename>.svn/prop-base</filename>。因为目录也有属性，所以也有<filename>.svn/dir-props</filename>和<filename>.svn/dir-prop-base</filename>文件。</para>
      </section>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.developer.usingapi">
      <info>
        <title>使用 API</title>
      </info>
      <para>使用Subversion库API开发应用看起来相当的直接，所有的公共头 (<filename>.h</filename>)文件放在源文件的<filename>subversion/include</filename>目录，从源代码编译和安装Subversion本身，需要这些头文件拷贝到系统位置(例如<filename>/usr/local/include</filename>)。这些头文件包括了所有用户和Subversion库可以访问的功能和类型。Subversion开发者社区仔细的确保所有的公共API有完好的文档—直接引用头文件的文档。</para>
      <para>你首先应该注意Subversion的数据类型和方法是命名空间保护的，每一个公共Subversion对象名以<literal>svn_</literal>开头，然后紧跟一个这个对象定义(如<literal>wc</literal>、<literal>client</literal>和<literal>fs</literal>等等)所在的库的简短编码，然后是一个下划线(<literal>_</literal>)和后面的对象名称。半公开的方法(库使用，但是但库之外代码不可以使用并且只可以在库自己的目录看到)与这个命名模式不同，并不是库代码之后紧跟一个下划线，他们是用两个下划线(<literal>__</literal>)。给定源文件的私有方法没有特殊前缀，使用<literal>static</literal>声明。当然，一个编译器不会关心命名习惯，只是用来区分给定方法或数据类型的应用范围。</para>
      <para>关于Subversion的API编程的另一个好的资源是hacking指南，可以在<uri href="http://subversion.tigris.org/hacking.html">http://subversion.tigris.org/hacking.html</uri>找到，这个文档包含了有用的信息，同时满足Subversion本身的开发者和将Subversion作为第三方库的开发者。<footnote><para>当然，Subversion使用Subversion的API。</para></footnote></para>
      <!-- =============================================================== -->
      <section xml:id="svn.developer.usingapi.apr">
        <info>
          <title>Apache 可移植运行库</title>
        </info>
        <para>伴随Subversion自己的数据类型，你会看到许多<literal>apr</literal>开头的数据类型引用—来自Apache可移植运行库(APR)的对象。APR是Apache可移植运行库，源自为了服务器代码的多平台性，尝试将不同的操作系统特定字节与操作系统无关代码隔离。结果就提供了一个基础API的库，只有一些适度区别—或者是广泛的—来自各个操作系统。Apache HTTP服务器很明显是APR库的第一个用户，Subversion开发者立刻发现了使用APR库的价值。意味着Subversion没有操作系统特定的代码，也意味着Subversion客户端可以在Server存在的平台编译和运行。当前这个列表包括，各种类型的Unix、Win32、BeOS、OS/2和Mac OS X。</para>
        <para>除了提供了跨平台一致的系统调用， <footnote><para>Subversion使用尽可能多ANSI系统调用和数据类型。</para></footnote>APR给Subversion对多种数据类型有快速的访问，如动态数组和哈希表。Subversion在代码中广泛使用这些类型，但是Subversion的API原型中最常见的APR类型是<structname>apr_pool_t</structname>—APR内存池，Subversion使用内部缓冲池用来进行内存分配(除非外部库在API传递参数时需要一个不同的内存管理模式)， <footnote><para>Neon和Berkeley DB就是这种库的例子。</para></footnote>而且一个人如果针对Subversion的API编码不需要做同样的事情，他们可以在需要时给API提供缓冲池，这意味着Subversion的API使用者也必须链接到APR，必须调用<function moreinfo="none">apr_initialize()</function>来初始化APR子系统，而且在使用Subversion API时必须创建和管理池，通常是使用 <function>svn_pool_create()</function>、<function>svn_pool_clear()</function>和<function>svn_pool_destroy()</function>。</para>
        <sidebar>
          <info>
            <title>使用内存池编程</title>
          </info>
          <para>几乎每一个使用过C语言的开发者曾经感叹令人畏缩的内存管理，分配足够的内存，并且追踪内存的分配，在不需要时释放内存—这个任务会非常复杂。当然，如果没有正确地做到这一点会导致程序毁掉自己，或者更加严重一点，把电脑搞瘫。</para>
          <para>另一方面高级语言使开发者完全摆脱了内存管理，<placeholder-1/>Java和Python之类的语言使用<firstterm>垃圾收集</firstterm>原理，在需要的时候分配对象内存，在不使用时进行清理。</para>
          <para>APR提供了一种叫做池基础的中等的内存管理方法，允许开发者以一种低分辨率的方式控制内存—每块(或池<quote>pool</quote>)的内存，而不是每个对象。不是使用<function>malloc()</function>和其他按照对象分配内存的方式，你要求APR从内存创建一段内存池，当你结束使用在池中创建的对象，你销毁池，可以有效地取消其中的对象消耗的内存。通过池，你不需要跟踪每个对象的内存释放，你的程序只需要跟踪这些对象，将对象分配到池中，而池的生命周期(池的创建和删除之间的时间)满足所有对象的需要。</para>
        </sidebar>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.developer.usingapi.urlpath">
        <info>
          <title>URL 和路径需求</title>
        </info>
        <para>因为分布式版本控制操作是Subversion存在的重点，有意义来关注一下国际化(i18n)支持。毕竟，当<quote>分布式</quote>或许意味着<quote>横跨办公室</quote>，它也意味着<quote>横跨全球</quote>。为了更容易一点，Subversion的所有接受路径参数的公共接口都期望这些路径是规范的—这可以通过传递它们给<function>svn_path_canonicalize()</function>函数简单的完成—而且使用UTF-8编码。这意味着，举个例子，任何新的使用<filename>libsvn_client</filename>接口客户端库，在把这些参数传递给Subversion库前，需要首先将路径从本地编码转化为UTF-8代码，然后将Subversion传递回来的路径转换为本地代码，很幸运，Subversion提供了一组任何程序可以使用的转化方法(见<filename>subversion/include/svn_utf.h</filename>)。</para>
        <para>同样，Subversion的API需要所有的URL参数是正确的URI编码，所以，我们不会传递<uri>file:///home/username/My File.txt</uri>作为<filename>My File.txt</filename>的URL，而要传递<uri>file:///home/username/My%20File.txt</uri>。再次，Subversion提供了一些你可以使用的助手方法—<function>svn_path_uri_encode()</function>和<function>svn_path_uri_decode()</function>，分别用来URI的编码和解码。</para>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.developer.usingapi.otherlangs">
        <info>
          <title>使用 C 和 C++ 以外的语言</title>
        </info>
        <para>除C语言以外，如果你对使用其他语言结合Subversion库感兴趣—如Python脚本或是Java应用—Subversion通过简单包裹生成器(SWIG)提供了最初的支持。Subversion的SWIG绑定位于<filename>subversion/bindings/swig</filename>，并且慢慢的走向成熟进入可用状态。这个绑定允许你直接调用Subversion的API方法，使用包裹器会把脚本数据类型转化为Subversion需要的C语言库类型。</para>
        <para>非常不幸，Subversion的语言绑定缺乏对核心Subversion模块的关注，但是，花了很多力气处理创建针对Python、Perl和Ruby的功能绑定，在一定程度上，在这些接口上的工作量可以在其他语言的SWIG(包括C#、Guile、Java、MzScheme、OCaml、PHP、Tcl等等)接口上得到重用。然而，为了完成复杂的API，一些SWIG接口仍然需要额外的编程工作，关于SWIG本身的更多信息可以看项目的网站<uri href="http://www.swig.org/">http://www.swig.org/</uri>。</para>
        <para>Subversion也有Java的语言绑定，javahl绑定(位于Subversion源目录树的<filename>subversion/bindings/java</filename>)不是基于SWIG的，而是javah和手写JNI的混合，JavaHL几乎覆盖Subversion客户端的API，目标是作为Java基础的Subversion客户端和集成IDE的实现。</para>
        <para>Subversion的语言绑定缺乏Subversion核心模块的关注，但是通常可以作为一个产品信赖。大量脚本、应用、Subversion的GUI客户端和其他第三方工具现在已经成功地运用了Subversion语言绑定来完成Subversion的集成。</para>
        <para>这里使用其它语言的方法来与Subversion交互没有任何意义：Subversion开发社区没有提供其他的绑定，你可以在Subversion项目链接页里(<uri href="http://subversion.tigris.org/links.html">http://subversion.tigris.org/links.html</uri>)找到其他绑定的链接，但是有一些流行的绑定我觉得应该特别留意。首先是Python的流行绑定，Barry Scott的PySVN(<uri href="http://pysvn.tigris.org/">http://pysvn.tigris.org/</uri>)。PySVN鼓吹它们提供了更多Python样式的接口，而不像Subversion自己的Python绑定的C样式接口。对于希望寻求Subversion纯Java实现的人，可以看看SVNKit(<uri href="http://svnkit.com/">http://svnkit.com/</uri>)，也就是从头使用Java编写的Subversion。</para>
        <sidebar>
          <info>
            <title>SVNKit 与 javahl</title>
          </info>
          <para>In 2005, a small company called TMate announced the
          1.0.0 release of JavaSVN—a pure Java implementation of
          Subversion.  Since then, the project has been renamed to
          SVNKit (available at <uri href="http://svnkit.com/">http://svnkit.com/</uri>)
          and has seen great success as a provider of Subversion
          functionality to various Subversion clients, IDE
          integrations, and other third-party tools.</para>
          <para>The SVNKit library is interesting in that, unlike the
          javahl library, it is not merely a wrapper around the
          official Subversion core libraries.  In fact, it shares no
          code with Subversion at all.  But while it is easy to
          confuse SVNKit with javahl, and easier still to not even
          realize which of these libraries you are using, folks should
          be aware that SVNKit differs from javahl in some significant
          ways.  First, SVNKit is not developed as open source
          software and seems to have at any given time only a few
          developers working on it.  Also, SVNKit's license is more
          restrictive than that of Subversion.  Finally, by aiming to
          be a pure Java Subversion library, SVNKit is limited in
          which portions of Subversion can be reasonably cloned while
          still keeping up with Subversion's releases.  This has
          already happened once—SVNKit cannot access BDB-backed
          Subversion repositories via the <literal>file://</literal>
          protocol because there's no pure Java implementation of
          Berkeley DB that is file-format-compatible with the native
          implementation of that library.</para>
          <para>That said, SVNKit has a well-established track record of
          reliability.  And a pure Java solution is much more robust
          in the face of programming errors—a bug in SVNKit
          might raise a catchable Java Exception, but a bug in the Subversion core
          libraries as accessed via javahl can bring down your entire
          Java Runtime Environment.  So, weigh the costs when choosing
          a Java-based Subversion implementation.</para>
        </sidebar>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.developer.usingapi.codesamples">
        <info>
          <title>代码样例</title>
        </info>
        <para><xref linkend="svn.developer.layerlib.repos.ex-1"/>包含了一段C代码(C编写)描述了我们讨论的概念，它使用了版本库和文件系统接口(可以通过方法名<literal>svn_repos_</literal>和<literal>svn_fs_</literal>分辨)创建了一个添加目录的修订版本。你可以看到APR库的使用，为了内存分配而传递，这些代码也揭开了一些关于Subversion错误处理的晦涩事实—所有的Subversion错误必须需要明确的处理以防止内存泄露(在某些情况下，应用失败)。</para>
        <example xml:id="svn.developer.layerlib.repos.ex-1">
          <info>
            <title>使用版本库层</title>
          </info>
          <programlisting>
/* Convert a Subversion error into a simple boolean error code.
 *
 * NOTE:  Subversion errors must be cleared (using svn_error_clear())
 *        because they are allocated from the global pool, else memory
 *        leaking occurs.
 */
#define INT_ERR(expr)                           \
  do {                                          \
    svn_error_t *__temperr = (expr);            \
    if (__temperr)                              \
      {                                         \
        svn_error_clear(__temperr);             \
        return 1;                               \
      }                                         \
    return 0;                                   \
  } while (0)

/* Create a new directory at the path NEW_DIRECTORY in the Subversion
 * repository located at REPOS_PATH.  Perform all memory allocation in
 * POOL.  This function will create a new revision for the addition of
 * NEW_DIRECTORY.  Return zero if the operation completes
 * successfully, non-zero otherwise.
 */
static int
make_new_directory(const char *repos_path,
                   const char *new_directory,
                   apr_pool_t *pool)
{
  svn_error_t *err;
  svn_repos_t *repos;
  svn_fs_t *fs;
  svn_revnum_t youngest_rev;
  svn_fs_txn_t *txn;
  svn_fs_root_t *txn_root;
  const char *conflict_str;

  /* Open the repository located at REPOS_PATH. 
   */
  INT_ERR(svn_repos_open(&amp;repos, repos_path, pool));

  /* Get a pointer to the filesystem object that is stored in REPOS. 
   */
  fs = svn_repos_fs(repos);

  /* Ask the filesystem to tell us the youngest revision that
   * currently exists. 
   */
  INT_ERR(svn_fs_youngest_rev(&amp;youngest_rev, fs, pool));

  /* Begin a new transaction that is based on YOUNGEST_REV.  We are
   * less likely to have our later commit rejected as conflicting if we
   * always try to make our changes against a copy of the latest snapshot
   * of the filesystem tree. 
   */
  INT_ERR(svn_repos_fs_begin_txn_for_commit2(&amp;txn, repos, youngest_rev,
                                             apr_hash_make(pool), pool));

  /* Now that we have started a new Subversion transaction, get a root
   * object that represents that transaction. 
   */
  INT_ERR(svn_fs_txn_root(&amp;txn_root, txn, pool));
  
  /* Create our new directory under the transaction root, at the path
   * NEW_DIRECTORY. 
   */
  INT_ERR(svn_fs_make_dir(txn_root, new_directory, pool));

  /* Commit the transaction, creating a new revision of the filesystem
   * which includes our added directory path.
   */
  err = svn_repos_fs_commit_txn(&amp;conflict_str, repos, 
                                &amp;youngest_rev, txn, pool);
  if (! err)
    {
      /* No error?  Excellent!  Print a brief report of our success.
       */
      printf("Directory '%s' was successfully added as new revision "
             "'%ld'.\n", new_directory, youngest_rev);
    }
  else if (err-&gt;apr_err == SVN_ERR_FS_CONFLICT)
    {
      /* Uh-oh.  Our commit failed as the result of a conflict
       * (someone else seems to have made changes to the same area 
       * of the filesystem that we tried to modify).  Print an error
       * message.
       */
      printf("A conflict occurred at path '%s' while attempting "
             "to add directory '%s' to the repository at '%s'.\n", 
             conflict_str, new_directory, repos_path);
    }
  else
    {
      /* Some other error has occurred.  Print an error message.
       */
      printf("An error occurred while attempting to add directory '%s' "
             "to the repository at '%s'.\n", 
             new_directory, repos_path);
    }

  INT_ERR(err);
} 
</programlisting>
        </example>
        <para>请注意在<xref linkend="svn.developer.layerlib.repos.ex-1"/>中，代码可以非常容易使用<function>svn_fs_commit_txn()</function>提交事务。但是文件系统的API对版本库库的钩子一无所知，如果你希望你的Subversion版本库在每次提交一个事务时自动执行一些非Subversion的任务(例如，给开发者邮件组发送一个描述事务修改的邮件)，你需要使用<filename>libsvn_repos</filename>包裹的功能版本—增加钩子触发功能—在这个例子里是<function>svn_repos_fs_commit_txn()</function>。(关于Subversion版本库钩子的更多信息，见<xref linkend="svn.reposadmin.create.hooks"/>。)</para>
        <para>现在我们转换一下语言，<xref linkend="svn.developer.usingapi.otherlangs.ex-1"/>是使用Subversion SWIG的Python绑定实现了通过遍历版本库获取最新版本库修订版本，并且打印遍历访问路径的功能。</para>
        <example xml:id="svn.developer.usingapi.otherlangs.ex-1">
          <info>
            <title>使用 Python 处理版本库层</title>
          </info>
          <programlisting>
#!/usr/bin/python

"""Crawl a repository, printing versioned object path names."""

import sys
import os.path
import svn.fs, svn.core, svn.repos

def crawl_filesystem_dir(root, directory):
    """Recursively crawl DIRECTORY under ROOT in the filesystem, and return
    a list of all the paths at or below DIRECTORY."""

    # Print the name of this path.
    print directory + "/"
    
    # Get the directory entries for DIRECTORY.
    entries = svn.fs.svn_fs_dir_entries(root, directory)

    # Loop over the entries.
    names = entries.keys()
    for name in names:
        # Calculate the entry's full path.
        full_path = directory + '/' + name

        # If the entry is a directory, recurse.  The recursion will return
        # a list with the entry and all its children, which we will add to
        # our running list of paths.
        if svn.fs.svn_fs_is_dir(root, full_path):
            crawl_filesystem_dir(root, full_path)
        else:
            # Else it's a file, so print its path here.
            print full_path

def crawl_youngest(repos_path):
    """Open the repository at REPOS_PATH, and recursively crawl its
    youngest revision."""
    
    # Open the repository at REPOS_PATH, and get a reference to its
    # versioning filesystem.
    repos_obj = svn.repos.svn_repos_open(repos_path)
    fs_obj = svn.repos.svn_repos_fs(repos_obj)

    # Query the current youngest revision.
    youngest_rev = svn.fs.svn_fs_youngest_rev(fs_obj)
    
    # Open a root object representing the youngest (HEAD) revision.
    root_obj = svn.fs.svn_fs_revision_root(fs_obj, youngest_rev)

    # Do the recursive crawl.
    crawl_filesystem_dir(root_obj, "")
    
if __name__ == "__main__":
    # Check for sane usage.
    if len(sys.argv) != 2:
        sys.stderr.write("Usage: %s REPOS_PATH\n"
                         % (os.path.basename(sys.argv[0])))
        sys.exit(1)

    # Canonicalize the repository path.
    repos_path = svn.core.svn_path_canonicalize(sys.argv[1])

    # Do the real work.
    crawl_youngest(repos_path)
</programlisting>
        </example>
        <para>同样的C程序需要处理APR内存池系统，但是Python自己处理内存，Subversion的Python绑定也遵循这种习惯。在C语言中，为表示路径和条目的hash需要处理自定义的数据类型(例如APR提供的库)，但是Python有hash(叫做<quote>dictionaries</quote>)，并且是内置数据类型，而且还提供了一系列操作这些类型的函数，所以SWIG(通过Subversion的语言绑定层的自定义帮助)要小心的将这些自定义数据类型映射到目标语言的数据类型，这为目标语言的用户提供了一个更加直观的接口。</para>
        <para>Subversion的Python绑定也可以用来进行工作拷贝的操作，在本章前面的小节中，我们提到过<filename>libsvn_client</filename>接口，它存在的目的就是简化编写Subversion客户端的难度，<xref linkend="svn.developer.usingapi.otherlangs.ex-2"/>是一个例子，讲的是如何使用SWIG绑定创建一个扩展版本的<command>svn status</command>命令。</para>
        <example xml:id="svn.developer.usingapi.otherlangs.ex-2">
          <info>
            <title>一个 Python 状态爬虫</title>
          </info>
          <programlisting>
#!/usr/bin/env python

"""Crawl a working copy directory, printing status information."""

import sys
import os.path
import getopt
import svn.core, svn.client, svn.wc

def generate_status_code(status):
    """Translate a status value into a single-character status code,
    using the same logic as the Subversion command-line client."""
    code_map = { svn.wc.svn_wc_status_none        : ' ',
                 svn.wc.svn_wc_status_normal      : ' ',
                 svn.wc.svn_wc_status_added       : 'A',
                 svn.wc.svn_wc_status_missing     : '!',
                 svn.wc.svn_wc_status_incomplete  : '!',
                 svn.wc.svn_wc_status_deleted     : 'D',
                 svn.wc.svn_wc_status_replaced    : 'R',
                 svn.wc.svn_wc_status_modified    : 'M',
                 svn.wc.svn_wc_status_merged      : 'G',
                 svn.wc.svn_wc_status_conflicted  : 'C',
                 svn.wc.svn_wc_status_obstructed  : '~',
                 svn.wc.svn_wc_status_ignored     : 'I',
                 svn.wc.svn_wc_status_external    : 'X',
                 svn.wc.svn_wc_status_unversioned : '?',
               }
    return code_map.get(status, '?')

def do_status(wc_path, verbose):
    # Build a client context baton.
    ctx = svn.client.svn_client_ctx_t()

    def _status_callback(path, status):
        """A callback function for svn_client_status."""

        # Print the path, minus the bit that overlaps with the root of
        # the status crawl
        text_status = generate_status_code(status.text_status)
        prop_status = generate_status_code(status.prop_status)
        print '%s%s  %s' % (text_status, prop_status, path)
        
    # Do the status crawl, using _status_callback() as our callback function.
    revision = svn.core.svn_opt_revision_t()
    revision.type = svn.core.svn_opt_revision_head
    svn.client.svn_client_status2(wc_path, revision, _status_callback,
                                  svn.core.svn_depth_infinity, verbose,
                                  0, 0, 1, ctx)

def usage_and_exit(errorcode):
    """Print usage message, and exit with ERRORCODE."""
    stream = errorcode and sys.stderr or sys.stdout
    stream.write("""Usage: %s OPTIONS WC-PATH
Options:
  --help, -h    : Show this usage message
  --verbose, -v : Show all statuses, even uninteresting ones
""" % (os.path.basename(sys.argv[0])))
    sys.exit(errorcode)
    
if __name__ == '__main__':
    # Parse command-line options.
    try:
        opts, args = getopt.getopt(sys.argv[1:], "hv", ["help", "verbose"])
    except getopt.GetoptError:
        usage_and_exit(1)
    verbose = 0
    for opt, arg in opts:
        if opt in ("-h", "--help"):
            usage_and_exit(0)
        if opt in ("-v", "--verbose"):
            verbose = 1
    if len(args) != 1:
        usage_and_exit(2)
            
    # Canonicalize the repository path.
    wc_path = svn.core.svn_path_canonicalize(args[0])

    # Do the real work.
    try:
        do_status(wc_path, verbose)
    except svn.core.SubversionException, e:
        sys.stderr.write("Error (%d): %s\n" % (e.apr_err, e.message))
        sys.exit(1)
</programlisting>
        </example>
        <para>就像<xref linkend="svn.developer.usingapi.otherlangs.ex-1"/>中的例子，这个程序是池自由的，而且最重要的是使用Python的数据类型。<function>svn_client_ctx_t()</function>是欺骗，因为Subversion的API没有这个方法—这仅仅是SWIG自动语言生成中的一点问题(这是对应复杂C结构的一种工厂方法)。也需要注意传递给程序的路径(象最后一个)是通过<function>svn_path_canonicalize()</function>执行的，因为要防止触发Subversion底层C库的断言，也就是防止导致程序立刻随意退出。</para>
      </section>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.developer.summary">
      <info>
        <title>总结</title>
      </info>
      <para>One of Subversion's greatest features isn't something you
      get from running its command-line client or other tools.  It's
      the fact that Subversion was designed modularly and provides a
      stable, public API so that others—like yourself,
      perhaps—can write custom software that drives Subversion's
      core logic.</para>
      <para>In this chapter, we took a closer look at Subversion's
      architecture, examining its logical layers and describing that
      public API, the very same API that Subversion's own layers use
      to communicate with each other.  Many developers have found
      interesting uses for the Subversion API, from simple repository
      hook scripts, to integrations between Subversion and some other
      application, to completely different version control systems.
      What unique itch will <emphasis>you</emphasis> scratch with
      it?</para>
    </section>
  </chapter>
  <!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
  <chapter xml:id="svn.ref">
    <info>
      <title>Subversion 完全参考</title>
    </info>
    <para>本章是使用Subversion的一个完全手册，包括了命令行客户端(<command>svn</command>)和它的所有子命令，也有版本库管理程序(<command>svnadmin</command>和<command>svnlook</command>)和它们各自的子命令。</para>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.ref.svn">
      <info>
        <title>Subversion 命令行客户端：<command>svn</command></title>
      </info>
      <para>为了使用命令行客户端，只需要输入<command>svn</command>和它的子命令<footnote><para>是的，使用<option>--version</option>选项不需要子命令，几分钟后我们会到达那个部分。</para></footnote>以及相关的选项或操作的对象—输入的子命令和选项没有特定的顺序，下面使用<command>svn status</command>的方式都是合法的：</para>
      <screen>
$ svn -v status
$ svn status -v 
$ svn status -v myfile
</screen>
      <para>你可以在<xref linkend="svn.tour"/>发现更多使用客户端命令的例子，以及<xref linkend="svn.advanced.props"/>中的管理属性的命令。</para>
      <!-- =============================================================== -->
      <section xml:id="svn.ref.svn.sw">
        <info>
          <title>svn 选项</title>
        </info>
        <para>虽然Subversion的子命令有一些不同的选项，但有的选项是全局的—也就是说，每个选项保证是表示同样的事情，而不管是哪个子命令使用的。举个例子，<option>--verbose</option>(<option>-v</option>)一直意味着<quote>冗长输出</quote>，而不管使用它的命令是什么。</para>
        <para>The <command>svn</command> command-line client usually
        exits quickly with an error if you pass it an option which
        does not apply to the specified subcommand.  But as of
        Subversion 1.5, several of the options which apply to
        all—or nearly all—of the subcommands have been
        deemed acceptable by all subcommands, even if they have no
        effect on some of them.  They appear grouped together in the
        command-line client's usage messages as global options.  This
        was done to assist folks who write scripts which wrap the
        command-line client.  These global options are as
        follows:</para>
        <variablelist>
          <varlistentry>
            <term>
              <option>--config-dir</option>
              <replaceable>DIR</replaceable>
            </term>
            <listitem>
              <para>指导Subversion从指定目录而不是默认位置(用户主目录的<filename>.subversion</filename>)读取配置信息。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--no-auth-cache</option>
            </term>
            <listitem>
              <para>阻止在Subversion管理区缓存认证信息(如用户名密码)。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--non-interactive</option>
            </term>
            <listitem>
              <para>如果认证失败，或者是不充分的凭证时，防止出现要求凭证的提示(例如用户名和密码)。这在运行自动脚本时非常有用，只是让Subversion失败而不是提示更多的信息。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--password</option>
              <replaceable>PASS</replaceable>
            </term>
            <listitem>
              <para>Specifies the password to use when authenticating
              against a Subversion server.  If not provided, or if
              incorrect, Subversion will prompt you for this
              information as needed.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--username</option>
              <replaceable>NAME</replaceable>
            </term>
            <listitem>
              <para>Specifies the username to use when authenticating
              against a Subversion server.  If not provided, or if
              incorrect, Subversion will prompt you for this
              information as needed.</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <para>The rest of the options apply and are accepted by only a
        subset of the subcommand.  They are as follows:</para>
        <variablelist>
          <varlistentry>
            <term>
              <option>--accept</option>
              <replaceable>ACTION</replaceable>
            </term>
            <listitem>
              <para>Specifies an action for automatic conflict resolution.
              Possible actions are <literal>postpone</literal>,
              <literal>base</literal>, <literal>mine-full</literal>,
              <literal>theirs-full</literal>, <literal>edit</literal>, and
              <literal>launch</literal>.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--auto-props</option>
            </term>
            <listitem>
              <para>开启auto-props，覆盖<filename>config</filename>文件中的<literal>enable-auto-props</literal>指示。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><option>--change</option> (<option>-c</option>) <replaceable>ARG</replaceable></term>
            <listitem>
              <para>作为引用特定<quote>修改</quote>(也叫做修订版本)的方法，这个选项是<quote>-r ARG-1:ARG</quote>语法上的甜头。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--changelist</option>
              <replaceable>ARG</replaceable>
            </term>
            <listitem>
              <para>Instructs Subversion to operate only on members of the changelist named
              <replaceable>ARG</replaceable>.  You can use this option
              multiple times to specify sets of changelists.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--cl</option>
              <replaceable>ARG</replaceable>
            </term>
            <listitem>
              <para>这是<option>--changelist</option>选项的一个别名。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--depth</option>
              <replaceable>ARG</replaceable>
            </term>
            <listitem>
              <para>Instructs Subversion to limit the scope of an operation to a particular tree
              depth.  <replaceable>ARG</replaceable> is one of
              <literal>empty</literal>, <literal>files</literal>,
              <literal>immediates</literal>, or
              <literal>infinity</literal>.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--diff-cmd</option>
              <replaceable>CMD</replaceable>
            </term>
            <listitem>
              <para>指定用来表示文件区别的外部程序，当<command>svn diff</command>调用时，会使用Subversion的内置区别引擎，默认会提供统一区别输出，如果你希望使用一个外置区别程序，使用<option>--diff-cmd</option>。你可以通过<option>--extensions</option>(本小节后面有更多介绍)把选项传递到区别程序。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--diff3-cmd</option>
              <replaceable>CMD</replaceable>
            </term>
            <listitem>
              <para>指定一个外置程序用来合并文件。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--dry-run</option>
            </term>
            <listitem>
              <para>检验运行一个命令的效果，但没有实际的修改—可以用在磁盘和版本库。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--editor-cmd</option>
              <replaceable>CMD</replaceable>
            </term>
            <listitem>
              <para>指定一个外部程序来编辑日志信息或是属性值。如何设定缺省编辑器见<xref linkend="svn.advanced.confarea.opts.config"/>的<literal>editor-cmd</literal>小节。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--encoding</option>
              <replaceable>ENC</replaceable>
            </term>
            <listitem>
              <para>告诉Subversion你的提交日志信息是通过提供的字符集编码的，缺省时是你的操作系统的本地编码，如果你的提交信息使用其它编码，你一定要指定这个值。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><option>--extensions</option> (<option>-x</option>) <replaceable>ARGS</replaceable></term>
            <listitem>
              <para>指定一个或多个Subversion传递给提供文件区别的外部区别程序的参数，如果你要传递多个参数，你一定能够要用引号(例如，<command>svn diff --diff-cmd /usr/bin/diff -x "-b -E"</command>)括起所有的参数。这个选项<emphasis>只有</emphasis>在使用<option>--diff-cmd</option>选项时使用。</para>
            </listitem>
            <!-- TODO(fitz): Document -u -b -w and - -ignore-eol-style -->
          </varlistentry>
          <varlistentry>
            <term><option>--file</option> (<option>-F</option>) <replaceable>FILENAME</replaceable></term>
            <listitem>
              <para>为特定子命令使用命名文件的的内容，尽管不同的子命令对这些内容做不同的事情。例如，<command>svn commit</command>使用内容作为提交日志，而<command>svn propset</command>使用它作为属性值。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--force</option>
            </term>
            <listitem>
              <para>强制一个特定的命令或操作运行。Subversion有一些操作防止你做普通的使用，但是你可以传递force选项告诉Subversion<quote>我知道我做的事情，也知道这样的结果，所以让我做吧</quote>。这个选项在程序上等同于在打开电源的情况下做你自己的电子工作—如果你不知道你在做什么，你很有可能会得到一个威胁的警告。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--force-log</option>
            </term>
            <listitem>
              <para>将传递给<option>--message</option>(<option>-m</option>)或者<option>--file</option>(<option>-F</option>)的可疑参数指定为有效可接受。缺省情况下，如果选项的参数看起来会成为子命令的目标，Subversion会提出一个错误，例如，你传递一个版本化的文件路径给<option>--file</option>(<option>-F</option>)选项，Subversion会认为出了点错误，认为你将目标对象当成了参数，而你并没有提供其它的—未版本化的文件作为日志信息的文件。为了确认你的意图并且不考虑这类错误，传递<option>--force-log</option>选项给命令来接受它作为日志信息。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><option>--help</option> (<option>-h</option>或<option>-?</option>)</term>
            <listitem>
              <para>如果同一个或多个子命令一起使用，会显示每个子命令内置的帮助文本，如果单独使用，它会显示常规的客户端帮助文本。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--ignore-ancestry</option>
            </term>
            <listitem>
              <para>告诉Subversion在计算区别(只依赖于路径内容)时忽略祖先。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--ignore-externals</option>
            </term>
            <listitem>
              <para>告诉Subversion忽略外部定义和外部定义管理的工作拷贝。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--incremental</option>
            </term>
            <listitem>
              <para>打印适合串联的输出格式。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--keep-changelist</option>
            </term>
            <listitem>
              <para>Tells Subversion not to delete changelists after committing.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--keep-local</option>
            </term>
            <listitem>
              <para>Keeps the local copy of a file or directory (used
              with the <command>svn delete</command> command).</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><option>--file</option> (<option>-F</option>) <replaceable>FILENAME</replaceable></term>
            <listitem>
              <para>只显示第一个<replaceable>NUM</replaceable>日志信息。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><option>--message</option> (<option>-m</option>) <replaceable>MESSAGE</replaceable></term>
            <listitem>
              <para>表示你会在命令行中指定日志信息，紧跟这个开关，例如：</para>
              <screen>
$ svn commit -m "They don't make Sunday."
</screen>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--new</option>
              <replaceable>ARG</replaceable>
            </term>
            <listitem>
              <para>使用<replaceable>ARG</replaceable>作为新的目标(结合<command>svn diff</command>使用)。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--no-auto-props</option>
            </term>
            <listitem>
              <para>关闭auto-props，覆盖<filename>config</filename>文件中的<literal>enable-auto-props</literal>指示。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--no-diff-deleted</option>
            </term>
            <listitem>
              <para>防止Subversion打印删除文件的区别信息，缺省的行为方式是当你删除了一个文件后运行<command>svn diff</command>打印的区别与删除文件所有的内容得到的结果一样。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--no-ignore</option>
            </term>
            <listitem>
              <para>在状态列表中显示<literal>global-ignores</literal>配置选项或者是<literal>svn:ignore</literal>属性忽略的文件。见<xref linkend="svn.advanced.confarea.opts.config"/>和<xref linkend="svn.advanced.props.special.ignore"/>查看详情。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--no-unlock</option>
            </term>
            <listitem>
              <para>不自动解锁文件(缺省的提交行为是解锁提交列出的所有文件)，更多信息见<xref linkend="svn.advanced.locking"/>。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><option>--non-recursive</option> (<option>-N</option>)</term>
            <listitem>
              <para><emphasis>废弃的</emphasis>。防止子命令迭代到子目录，大多数子命令缺省是迭代的，但是一些子命令—通常是那些潜在的删除或者是取消本地修改的命令—千万不要。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--notice-ancestry</option>
            </term>
            <listitem>
              <para>在计算区别时关注祖先。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--old</option>
              <replaceable>ARG</replaceable>
            </term>
            <listitem>
              <para>使用<replaceable>ARG</replaceable>作为旧的目标(结合<command>svn diff</command>使用)。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--parents</option>
            </term>
            <listitem>
              <para>Creates and adds nonexistent or nonversioned parent
              subdirectories to the working copy or repository as part
              of an operation.  This is useful for automatically
              creating multiple subdirectories where none currently
              exist.  If performed on a URL, all the directories will
              be created in a single commit.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><option>--quiet</option> (<option>-q</option>)</term>
            <listitem>
              <para>请求客户端在执行操作时只显示重要信息。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--record-only</option>
            </term>
            <listitem>
              <para>标记修订版本已合并(通过<option>--revision</option> (<option>-r</option>)使用)</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><option>--recursive</option> (<option>-R</option>)</term>
            <listitem>
              <para><emphasis>废弃的</emphasis>。让子命令迭代到子目录，大多数子命令缺省是迭代的。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--non-interactive</option>
            </term>
            <listitem>
              <para>Used with the <command>svn merge</command>
              subcommand, merges all of the source URL's changes into
              the working copy.  See
              <xref linkend="svn.branchemerge.basicmerging.stayinsync"/>
              for details.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--relocate</option>
              <replaceable>目的路径[PATH...]</replaceable>
            </term>
            <listitem>
              <para><command>svn switch</command>子命令中使用，用来修改你的工作拷贝所引用的版本库位置。当版本库的位置修改了，而你有一个工作拷贝，希望继续使用时非常有用。见<command>svn switch</command>的例子。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--remove</option>
              <replaceable>ARG</replaceable>
            </term>
            <listitem>
              <para>从<replaceable>ARG</replaceable>变更列表清除</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><option>--revision</option> (<option>-r</option>) <replaceable>REV</replaceable></term>
            <listitem>
              <para>指出你将为特定操作提供一个修订版本(或修订版本的范围)，你可以提供修订版本号，修订版本关键字或日期(在华括号中)作为修订版本开关的参数。如果你希望提供一个修订版本范围，你可以提供用冒号隔开的两个修订版本，举个例子：</para>
              <screen>
$ svn log -r 1729
$ svn log -r 1729:HEAD
$ svn log -r 1729:1744
$ svn log -r {2001-12-04}:{2002-02-17}
$ svn log -r 1729:{2002-02-17}
</screen>
              <para>见<xref linkend="svn.tour.revs.keywords"/>查看更多信息。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--revprop</option>
            </term>
            <listitem>
              <para>操作针对修订版本属性，而不是Subversion文件或目录的属性。这个选项需要你传递<option>--revision</option>(<option>-r</option>)参数。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--set-depth</option>
              <replaceable>ARG</replaceable>
            </term>
            <listitem>
              <para>Sets the sticky depth on a directory in a working
              copy to one of <literal>empty</literal>,
              <literal>files</literal>, <literal>immediates</literal>,
              or <literal>infinity</literal>.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--show-ids</option>
              <replaceable>ARG</replaceable>
            </term>
            <listitem>
              <para>Used to make <command>svn mergeinfo</command>
              display either <literal>merged</literal>
              or <literal>eligible</literal> revisions.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><option>--show-updates</option> (<option>-u</option>)</term>
            <listitem>
              <para>导致客户端显示本地拷贝哪些文件已经过期，这不会实际更新你的任何文件—只是显示了如果你运行<command>svn update</command>时更新的文件。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--stop-on-copy</option>
            </term>
            <listitem>
              <para>导致Subversion子命令在传递历史时会在版本化资源拷贝时停止收集历史信息—也就是历史中资源从另一个位置拷贝过来的位置—如果遇到。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--strict</option>
            </term>
            <listitem>
              <para>导致Subversion使用严格的语法，就是明确使用特定而不是含糊的子命令(也就是，<command>svn propget</command>)。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--targets</option>
              <replaceable>FILENAME</replaceable>
            </term>
            <listitem>
              <para>告诉Subversion从你提供的文件中得到希望操作的文件列表，而不是在命令行列出所有的文件。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><option>--use-merge-history</option> (<option>-g</option>)</term>
            <listitem>
              <para>Uses or displays additional information from merge
              history.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><option>--verbose</option> (<option>-v</option>)</term>
            <listitem>
              <para>请求客户端在运行子命令打印尽量多的信息，会导致Subversion打印额外的字段，每个文件的细节信息或者是关于动作的附加信息。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--version</option>
            </term>
            <listitem>
              <para>打印客户端版本信息，这个信息不仅仅包括客户端的版本号，也有所有客户端可以用来访问Subversion版本库的版本库访问模块列表。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--with-all-revprops</option>
            </term>
            <listitem>
              <para>Used with the <option>--xml</option> option to <command>svn log</command>,
            will retrieve and display all revision
            properties in the log output.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--with-revprop</option>
              <replaceable>ARG</replaceable>
            </term>
            <listitem>
              <para>When used with any command that writes to the
              repository, sets the revision property, using the
              <replaceable>NAME=VALUE</replaceable> format,
              <replaceable>NAME</replaceable> to
              <replaceable>VALUE</replaceable>.  When used with
              <command>svn log</command> in <option>--xml</option> mode, this displays the value of
              <replaceable>ARG</replaceable> in the log output.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--xml</option>
            </term>
            <listitem>
              <para>使用XML格式打印输出。</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.ref.svn.c">
        <info>
          <title>svn 子命令</title>
        </info>
        <para>Here are the various subcommands for the <command>svn</command> program.  For the sake of
        brevity, we omit the global options (described in <xref linkend="svn.ref.svn.sw"/>) from the subcommand descriptions
        which follow.</para>
        <refentry xml:id="svn.ref.svn.c.add">
          <indexterm>
            <primary>svn</primary>
            <secondary>子命令</secondary>
            <tertiary>add</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svn add</refname>
            <refpurpose>添加文件、目录或符号链。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svn add PATH...</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>文件、目录或符号链到你的工作拷贝并且预定添加到版本库。它们会在下次提交上传并添加到版本库，如果你在提交之前改变了主意，你可以使用<command>svn revert</command>取消预定。</para>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>无</para>
          </refsection>
          <refsection>
            <info>
              <title>改变</title>
            </info>
            <para>工作拷贝2</para>
          </refsection>
          <refsection>
            <info>
              <title>访问版本库</title>
            </info>
            <para>否</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--auto-props
--depth ARG
--force
--no-auto-props
--no-ignore
--parents
--quiet (-q)
--targets FILENAME
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>添加一个文件到工作拷贝：</para>
            <screen>
$ svn add foo.c 
A         foo.c
</screen>
            <para>当添加一个目录，<command>svn add</command>缺省的行为方式是递归的：</para>
            <screen>
$ svn add testdir
A         testdir
A         testdir/a
A         testdir/b
A         testdir/c
A         testdir/d
</screen>
            <para>你可以只添加一个目录而不包括其内容：</para>
            <screen>
$ svn add --depth=empty otherdir
A         otherdir
</screen>
            <para>通常情况下，命令<command>svn add *</command>会忽略所有已经在版本控制之下的目录，有时候，你会希望添加所有工作拷贝的未版本化文件，包括那些隐藏在深处的文件，可以使用<command>svn add</command>的<option>--force</option>递归到版本化的目录下：</para>
            <screen>
$ svn add * --force
A         foo.c
A         somedir/bar.c
A         otherdir/docs/baz.doc
…
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svn.c.blame">
          <indexterm>
            <primary>svn</primary>
            <secondary>子命令</secondary>
            <tertiary>blame</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svn blame</refname>
            <refpurpose>显示特定文件和URL内嵌的作者和修订版本信息。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svn blame TARGET[@REV]...</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>显示特定文件和URL内嵌的作者和修订版本信息。每一行文本在开头都放了最后修改的作者(用户名)和修订版本号。</para>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>使用<command>svnserve</command>通过<command>inetd</command></para>
          </refsection>
          <refsection>
            <info>
              <title>改变</title>
            </info>
            <para>无2</para>
          </refsection>
          <refsection>
            <info>
              <title>访问版本库</title>
            </info>
            <para>是</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--extensions (-x) ARG
--force
--incremental
--revision (-r) ARG
--use-merge-history (-g)
--verbose (-v)
--xml
</screen>
            <!--

TODO(fitz): doc this:
  - -incremental            : give output suitable for concatenation
  - -xml                    : output in XML
  -x [- -extensions] arg    : Default: '-u'. When Subversion is invoking an
                             external diff program, ARG is simply passed along
                             to the program. But when Subversion is using its
                             default internal diff implementation, or when
                             Subversion is displaying blame annotations, ARG
                             could be any of the following:
                                -u (- -unified):
                                   Output 3 lines of unified context.
                                -b (- -ignore-space-change):
                                   Ignore changes in the amount of white space.
                                -w (- -ignore-all-space):
                                   Ignore all white space.
                                - -ignore-eol-style:
                                   Ignore changes in EOL style
  - -force                  : force operation to run

-->
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>如果你希望在测试版本库看到blame标记的<filename>readme.txt</filename>源代码：</para>
            <screen>
$ svn blame http://svn.red-bean.com/repos/test/readme.txt
     3      sally This is a README file.
     5      harry You should read this.
</screen>
            <para>即使<command>svn blame</command>说明Harry最后在修订版本5修改了<filename>readme.txt</filename>，你也需要验证Harry在修订版本修改行的<emphasis>上下文</emphasis>—也许他只是调整了空格。</para>
            <para>If you use the <option>--xml</option> option, you can
            get XML output describing the blame annotations, but not
            the contents of the lines themselves:</para>
            <screen>
$ svn blame --xml http://svn.red-bean.com/repos/test/readme.txt
&lt;?xml version="1.0"?&gt;
&lt;blame&gt;
&lt;target
   path="sandwich.txt"&gt;
&lt;entry
   line-number="1"&gt;
&lt;commit
   revision="3"&gt;
&lt;author&gt;sally&lt;/author&gt;
&lt;date&gt;2008-05-25T19:12:31.428953Z&lt;/date&gt;
&lt;/commit&gt;
&lt;/entry&gt;
&lt;entry
   line-number="2"&gt;
&lt;commit
   revision="5"&gt;
&lt;author&gt;harry&lt;/author&gt;
&lt;date&gt;2008-05-29T03:26:12.293121Z&lt;/date&gt;
&lt;/commit&gt;
&lt;/entry&gt;
&lt;/target&gt;
&lt;/blame&gt;
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svn.c.cat">
          <indexterm>
            <primary>svn</primary>
            <secondary>子命令</secondary>
            <tertiary>cat</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svn cat</refname>
            <refpurpose>输出特定文件或URL的内容。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svn cat TARGET[@REV]...</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>输出特定文件或URL的内容。列出目录的内容可以使用<command>svn list</command>。</para>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>无</para>
          </refsection>
          <refsection>
            <info>
              <title>改变</title>
            </info>
            <para>无2</para>
          </refsection>
          <refsection>
            <info>
              <title>访问版本库</title>
            </info>
            <para>是</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--revision (-r) REV
--show-ids
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>如果你希望不检出而察看版本库的readme.txt的内容：</para>
            <screen>
$ svn cat http://svn.red-bean.com/repos/test/readme.txt
This is a README file.
You should read this.
</screen>
            <tip>
              <para>如果你的工作拷贝已经过期(或者你有本地修改)，并且希望察看工作拷贝的<literal>HEAD</literal>修订版本的一个文件，如果你给定一个路径，<command>svn cat -r HEAD</command>会自动取得<literal>HEAD</literal>的修订版本：</para>
            </tip>
            <screen>
$ cat foo.c
This file is in my local working copy 
and has changes that I've made.

$ svn cat -r HEAD foo.c
Latest revision fresh from the repository!
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svn.c.changelist">
          <indexterm>
            <primary>svn</primary>
            <secondary>子命令</secondary>
            <tertiary>changelist</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svn changelist</refname>
            <refpurpose>Associate (or deassociate) local paths with a
            changelist.</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>changelist CLNAME TARGET...</programlisting>
            <programlisting>changelist --remove TARGET...</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>Used for dividing files in a working copy into a
            changelist (logical named grouping) in order to allow
            users to easily work on multiple file collections within a
            single working copy.</para>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>
              <command>cl</command>
            </para>
          </refsection>
          <refsection>
            <info>
              <title>改变</title>
            </info>
            <para>工作拷贝2</para>
          </refsection>
          <refsection>
            <info>
              <title>访问版本库</title>
            </info>
            <para>否</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--targets FILENAME
--depth ARG
--quiet (-q)
--config-dir DIR
--changelist ARG
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>Edit three files, add them to a changelist, then
            commit only files in that changelist:</para>
            <screen>
$ svn cl issue1729 foo.c bar.c baz.c
Path 'foo.c' is now a member of changelist 'issue1729'.
Path 'bar.c' is now a member of changelist 'issue1729'.
Path 'baz.c' is now a member of changelist 'issue1729'.

$ svn status
A      someotherfile.c
A      test/sometest.c

--- Changelist 'issue1729':
A      foo.c
A      bar.c
A      baz.c

$ svn commit --changelist issue1729 -m "Fixing Issue 1729."
Adding         bar.c
Adding         baz.c
Adding         foo.c
Transmitting file data ...
Committed revision 2.

$ svn status
A      someotherfile.c
A      test/sometest.c
</screen>
            <para>注意，只有在变更列表<replaceable>issue1729</replaceable>中的文件被提交了。</para>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svn.c.checkout">
          <indexterm>
            <primary>svn</primary>
            <secondary>子命令</secondary>
            <tertiary>checkout</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svn checkout</refname>
            <refpurpose>从版本库取出一个工作拷贝。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svn checkout URL[@REV]... [PATH]</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>从版本库取出一个工作拷贝，如果省略<replaceable>PATH</replaceable>，URL的基名称会作为目标，如果给定多个URL，每一个都会检出到<replaceable>PATH</replaceable>的子目录，使用URL基名称的子目录名称。</para>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>
              <command>co</command>
            </para>
          </refsection>
          <refsection>
            <info>
              <title>改变</title>
            </info>
            <para>创建一个工作拷贝。</para>
          </refsection>
          <refsection>
            <info>
              <title>访问版本库</title>
            </info>
            <para>是</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--depth ARG
--force
--ignore-externals
--quiet (-q)
--revision (-r) REV
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>取出一个工作拷贝到<filename>mine</filename>目录：</para>
            <screen>
$ svn checkout file:///var/svn/repos/test mine
A  mine/a
A  mine/b
A  mine/c
A  mine/d
Checked out revision 20.
$ ls
mine
</screen>
            <para>检出两个目录到两个单独的工作拷贝：</para>
            <screen>
$ svn checkout file:///var/svn/repos/test  file:///var/svn/repos/quiz
A  test/a
A  test/b
A  test/c
A  test/d
Checked out revision 20.
A  quiz/l
A  quiz/m
Checked out revision 13.
$ ls
quiz  test
</screen>
            <para>检出两个目录到两个单独的工作拷贝，但是将两个目录都放到<filename>working-copies</filename>：</para>
            <screen>
$ svn checkout file:///var/svn/repos/test  file:///var/svn/repos/quiz working-copies
A  working-copies/test/a
A  working-copies/test/b
A  working-copies/test/c
A  working-copies/test/d
Checked out revision 20.
A  working-copies/quiz/l
A  working-copies/quiz/m
Checked out revision 13.
$ ls
working-copies
</screen>
            <para>如果你打断一个检出(或其它打断检出的事情，如连接失败。)，你可以使用同样的命令重新开始或者是更新不完整的工作拷贝：</para>
            <screen>
$ svn checkout file:///var/svn/repos/test mine
A  mine/a
A  mine/b
^C
svn: The operation was interrupted
svn: caught SIGINT

$ svn checkout file:///var/svn/repos/test mine
A  mine/c
^C
svn: The operation was interrupted
svn: caught SIGINT

$ svn update mine
A  mine/d
Updated to revision 20.
</screen>
            <para>If you wish to check out some revision other than the
            most recent one, you can do so by providing the
            <option>--revision</option> (<option>-r</option>) option
            to the <command>svn checkout</command> command:</para>
            <screen>
$ svn checkout -r 2 file:///var/svn/repos/test mine
A  mine/a
Checked out revision 2.
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svn.c.cleanup">
          <indexterm>
            <primary>svn</primary>
            <secondary>子命令</secondary>
            <tertiary>cleanup</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svn cleanup</refname>
            <refpurpose>递归清理工作拷贝。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svn cleanup [PATH...]</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>递归清理工作拷贝，删除未完成的工作拷贝锁定，并恢复未完成的操作。如果你得到一个<quote>工作拷贝已锁定</quote>的错误，运行这个命令可以删除无效的锁定，让你的工作拷贝再次回到可用的状态。</para>
            <para>如果，因为一些原因，运行外置的区别程序(例如，用户输入或是网络错误)有时候会导致一个<command>svn update</command>失败，使用<option>--diff3-cmd</option>选项可以完全清除你的外置区别程序所作的合并，你也可以使用<option>--config-dir</option>指定任何配置目录，但是你应该不会经常使用这些选项。</para>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>无</para>
          </refsection>
          <refsection>
            <info>
              <title>改变</title>
            </info>
            <para>工作拷贝2</para>
          </refsection>
          <refsection>
            <info>
              <title>访问版本库</title>
            </info>
            <para>否</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--diff3-cmd CMD
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para><command>svn cleanup</command>没有输出，没有太多的例子，如果你没有传递<replaceable>PATH</replaceable>，会使用<quote><filename>.</filename></quote>。</para>
            <screen>
$ svn cleanup

$ svn cleanup /var/svn/working-copy
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svn.c.commit">
          <indexterm>
            <primary>svn</primary>
            <secondary>子命令</secondary>
            <tertiary>commit</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svn commit</refname>
            <refpurpose>将修改从工作拷贝发送到版本库。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svn commit [PATH...]</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>将修改从工作拷贝发送到版本库。如果你没有使用<option>--file</option>或<option>--message</option>提供一个提交日志信息，<command>svn</command>会启动你的编辑器来编写一个提交信息，见<xref linkend="svn.advanced.confarea.opts.config"/>的<literal>editor-cmd</literal>小节。</para>
            <para><command>svn commit</command>会返回所有找到的锁定令牌并释放所有提交<replaceable>PATHS</replaceable>的锁定，除非传递<option>--no-unlock</option>参数。</para>
            <tip>
              <para>如果你开始一个提交并且Subversion启动了你的编辑器来编辑提交信息，你仍可以退出而不会提交你的修改，如果你希望取消你的提交，只需要退出编辑器而不保存你的提交信息，Subversion会提示你是选择取消提交、空信息继续还是重新编辑信息。</para>
            </tip>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>ci(<quote>check in</quote>的缩写；不是<quote>checkout</quote>的缩写<quote>co</quote>。)</para>
          </refsection>
          <refsection>
            <info>
              <title>改变</title>
            </info>
            <para>工作拷贝；版本库</para>
          </refsection>
          <refsection>
            <info>
              <title>访问版本库</title>
            </info>
            <para>是</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--changelist ARG
--depth ARG
--editor-cmd ARG
--encoding ENC
--file (-F) FILE
--force-log
--keep-changelists
--message (-m) TEXT
--no-unlock
--quiet (-q)
--targets FILENAME
--with-revprop ARG
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>使用命令行提交一个包含日志信息的文件修改，当前目录(<quote><filename>.</filename></quote>)是没有说明的目标路径：</para>
            <screen>
$ svn commit -m "added howto section."
Sending        a
Transmitting file data .
Committed revision 3.
</screen>
            <para>提交一个修改到<filename>foo.c</filename>(在命令行明确指明)，并且<literal>msg</literal>文件中保存了提交信息：</para>
            <screen>
$ svn commit -F msg foo.c
Sending        foo.c
Transmitting file data .
Committed revision 5.
</screen>
            <para>如果你希望使用在<option>--file</option>选项中使用在版本控制之下的文件作为参数，你需要使用<option>--force-log</option>选项：</para>
            <screen>
$ svn commit --file file_under_vc.txt foo.c
svn: The log message file is under version control
svn: Log message file is a versioned file; use '--force-log' to override

$ svn commit --force-log --file file_under_vc.txt foo.c
Sending        foo.c
Transmitting file data .
Committed revision 6.
</screen>
            <para>提交一个已经预定要删除的文件：</para>
            <screen>
$ svn commit -m "removed file 'c'."
Deleting       c

Committed revision 7.
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svn.c.copy">
          <indexterm>
            <primary>svn</primary>
            <secondary>子命令</secondary>
            <tertiary>copy</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svn copy</refname>
            <refpurpose>拷贝工作拷贝的一个文件或目录到版本库。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svn copy SRC[@REV]... DST</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>拷贝工作拷贝的一个文件或目录到版本库。<replaceable>SRC</replaceable>和<replaceable>DST</replaceable>既可以是工作拷贝(WC)路径也可以是URL：</para>
            <variablelist>
              <varlistentry>
                <term>WC → WC</term>
                <listitem>
                  <para>拷贝并且预定一个添加的项目(包含历史)。</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>WC → URL</term>
                <listitem>
                  <para>将WC或URL的拷贝立即提交。</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>URL → WC</term>
                <listitem>
                  <para>检出URL到WC，并且加入到添加计划。</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>URL → URL</term>
                <listitem>
                  <para>完全的服务器端拷贝，通常用在分支和标签。</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <para>When copying multiple sources, they will be added as
            children of <replaceable>DST</replaceable>, which must be
            a directory.</para>
            <para>If no peg revision (i.e.,
            <replaceable>@REV</replaceable>) is supplied, by default
            the <literal>BASE</literal> revision will be used for
            files copied from the working copy, while the
            <literal>HEAD</literal> revision will be used for files
            copied from a URL.</para>
            <note>
              <para>你只可以在单个版本库中拷贝文件，Subversion还不支持跨版本库的拷贝。</para>
            </note>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>
              <command>cp</command>
            </para>
          </refsection>
          <refsection>
            <info>
              <title>改变</title>
            </info>
            <para>如果目标是WC路径，则是工作拷贝。</para>
          </refsection>
          <refsection>
            <info>
              <title>访问版本库</title>
            </info>
            <para>如果目标是版本库，或者需要查看修订版本号，则会访问版本库。</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--editor-cmd EDITOR
--encoding ENC
--file (-F) FILE
--force-log
--message (-m) TEXT
--parents
--quiet (-q)
--revision (-r) REV
--with-revprop ARG
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>拷贝工作拷贝的一个项目(只是预定要拷贝—在提交之前不会影响版本库)：</para>
            <screen>
$ svn copy foo.txt bar.txt
A         bar.txt
$ svn status
A  +   bar.txt
</screen>
            <para>拷贝工作拷贝的一个文件或目录到版本库：</para>
            <screen>
$ svn cp bat.c baz.c qux.c src
A         src/bat.c
A         src/baz.c
A         src/qux.c
</screen>
            <para>Copy revision 8 of <filename>bat.c</filename> into your
            working copy under a different name:</para>
            <screen>
$ svn cp bat.c ya-old-bat.c
A         ya-old-bat.c
</screen>
            <para>拷贝你的工作拷贝的一个项目到版本库的URL(直接的提交，所以需要提供一个提交信息)：</para>
            <screen>
$ svn copy near.txt file:///var/svn/repos/test/far-away.txt -m "Remote copy."

Committed revision 8.
</screen>
            <para>拷贝版本库的一个项目到你的工作拷贝(只是预定要拷贝—在提交之前不会影响版本库)：</para>
            <screen>
$ svn copy file:///var/svn/repos/test/far-away near-here
A         near-here
</screen>
            <tip>
              <para>这是恢复死掉文件的推荐方式！</para>
            </tip>
            <para>最后，是在URL之间拷贝：</para>
            <screen>
$ svn copy file:///var/svn/repos/test/far-away file:///var/svn/repos/test/over-there -m "remote copy."

Committed revision 9.
</screen>
            <screen>
$ svn copy file:///var/svn/repos/test/trunk \
    file:///var/svn/repos/test/tags/0.6.32-prerelease -m "tag tree"

Committed revision 12.
</screen>
            <tip>
              <para>这是在版本库里作<quote>标签</quote>最简单的方法—<command>svn copy</command>那个修订版本(通常是<literal>HEAD</literal>)到你的tags目录。</para>
            </tip>
            <para>不要担心忘记作标签—你可以在以后任何时候给一个旧版本作标签：</para>
            <screen>
$ svn copy -r 11 file:///var/svn/repos/test/trunk \
     file:///var/svn/repos/test/tags/0.6.32-prerelease -m "Forgot to tag at rev 11"

Committed revision 13.
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svn.c.delete">
          <indexterm>
            <primary>svn</primary>
            <secondary>子命令</secondary>
            <tertiary>delete</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svn delete</refname>
            <refpurpose>从工作拷贝或版本库删除一个项目。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svn delete PATH...</programlisting>
            <programlisting>svn delete URL...</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para><replaceable>PATH</replaceable>指定的项目会在下次提交删除，除非给定<option>--keep-local</option>选项，否则文件(和没有提交的目录)会立即从版本库删除，这个命令不会删除任何未版本化或已经修改的项目；使用<option>--force</option>选项可以覆盖这种行为方式。</para>
            <para>URL指定的项目会在直接提交中从版本库删除，多个URL的提交是原子操作。</para>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>使用<command>svnserve</command>通过<command>inetd</command></para>
          </refsection>
          <refsection>
            <info>
              <title>改变</title>
            </info>
            <para>如果操作对象是文件则是工作拷贝变化；如果对象是URL则会影响版本库。</para>
          </refsection>
          <refsection>
            <info>
              <title>访问版本库</title>
            </info>
            <para>对URL操作时访问</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--editor-cmd EDITOR
--encoding ENC
--file (-F) FILE
--force
--force-log
--keep-local
--message (-m) TEXT
--quiet (-q)
--targets FILENAME
--with-revprop ARG
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>使用<command>svn</command>从工作拷贝删除文件只是预定要删除，当你提交，文件才会从版本库删除。</para>
            <screen>
$ svn delete myfile
D         myfile

$ svn commit -m "Deleted file 'myfile'."
Deleting       myfile
Transmitting file data .
Committed revision 14.
</screen>
            <para>然而直接删除一个URL，你需要提供一个日志信息：</para>
            <screen>
$ svn delete -m "Deleting file 'yourfile'" file:///var/svn/repos/test/yourfile

Committed revision 15.
</screen>
            <para>如下是强制删除本地已修改文件的例子：</para>
            <screen>
$ svn delete over-there 
svn: Attempting restricted operation for modified resource
svn: Use --force to override this restriction
svn: 'over-there' has local modifications

$ svn delete --force over-there 
D         over-there
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svn.c.diff">
          <indexterm>
            <primary>svn</primary>
            <secondary>子命令</secondary>
            <tertiary>diff</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svn diff</refname>
            <refpurpose>比较两条路径的区别。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>diff [-c M | -r N[:M]] [TARGET[@REV]...]</programlisting>
            <programlisting>diff [-r N[:M]] --old=OLD-TGT[@OLDREV] [--new=NEW-TGT[@NEWREV]] [PATH...]</programlisting>
            <programlisting>diff OLD-URL[@OLDREV] NEW-URL[@NEWREV]</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <itemizedlist>
              <listitem>
                <para>显示两条路径的区别，你可以通过下面的方式使用<command>svn diff</command>：</para>
              </listitem>
              <listitem>
                <para>运行<command>svn diff</command>以标准差别格式查看本地工作拷贝修改的内容。</para>
              </listitem>
              <listitem>
                <para>显示<replaceable>TARGET</replaceable>在<replaceable>REV</replaceable>的样子时两个修订版本之间所作的修改，<replaceable>TARGET</replaceable>可以是任何工作拷贝路径或任何<replaceable>URL</replaceable>，如果<replaceable>TARGET</replaceable>是工作拷贝路径，则<replaceable>N</replaceable>缺省是<literal>BASE</literal>，而<replaceable>M</replaceable>是工作拷贝；如果是<replaceable>URL</replaceable>，则必须指定<replaceable>N</replaceable>，而<replaceable>M</replaceable>缺省是<literal>HEAD</literal>。<quote>-c M</quote>选项与<quote>-r N:M</quote>等价，其中<literal>N = M-1</literal>。使用<quote>-c -M</quote>则相反：<quote>-r M:N</quote>的意思是<literal>N = M-1</literal>。</para>
              </listitem>
              <listitem>
                <para>显示在<replaceable>OLDREV</replaceable>的<replaceable>OLD-TGT</replaceable>和<replaceable>NEWREV</replaceable>的<replaceable>NEW-TGT</replaceable>之间的区别。如果提供<replaceable>PATH</replaceable>，则与<replaceable>OLD-TGT</replaceable>和<replaceable>NEW-TGT</replaceable>关联，将输出限制在那些路径。<replaceable>OLD-TGT</replaceable>和<replaceable>NEW-TGT</replaceable>可能是工作拷贝路经或<replaceable>URL[@REV]</replaceable>。如果没有指定，<replaceable>NEW-TGT</replaceable>缺省是<replaceable>OLD-TGT</replaceable>。<quote>-r N</quote>设置OLDREV缺省为N，而-r N:M设置<replaceable>OLDREV</replaceable>缺省为<replaceable>N</replaceable>，而<replaceable>NEWREV</replaceable>缺省为<replaceable>M</replaceable>。</para>
              </listitem>
            </itemizedlist>
            <para><command>diff OLD-URL[@OLDREV] NEW-URL[@NEWREV]</command>是<command>svn diff --old=OLD-URL[@OLDREV] --new=NEW-URL[@NEWREV].</command>的简写。</para>
            <para><command>svn diff -r N:M URL</command>是<command>svn diff -r N:M --old=URL --new=URL</command>的简写。</para>
            <para><command>svn diff [-r N[:M]] URL1[@N] URL2[@M]</command>是 <command>svn diff [-r N[:M]] --old=URL1 --new=URL2</command>的简写。</para>
            <para><replaceable>TARGET</replaceable>是一个URL，然后可以使用前面提到的<option>--revision</option>或<quote>@</quote>符号来指定N和M。</para>
            <para>If <replaceable>TARGET</replaceable> is a working copy
            path, the default behavior (when no
            <option>--revision</option> option is provided) is to
            display the differences between the base and working
            copies of <replaceable>TARGET</replaceable>.  If a
            <option>--revision</option> option is specified in this
            scenario, though, it means:</para>
            <variablelist>
              <varlistentry>
                <term>
                  <option>--revision N:M</option>
                </term>
                <listitem>
                  <para>服务器比较<replaceable>TARGET@N</replaceable>和<replaceable>TARGET<replaceable>TARGET@M</replaceable>。</replaceable></para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                  <option>--revision N</option>
                </term>
                <listitem>
                  <para>客户端比较<replaceable>TARGET@N</replaceable>和工作拷贝。</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <para>如果使用其他语法，服务器会比较<replaceable>URL1</replaceable>和<replaceable>URL2</replaceable>各自的<replaceable>N</replaceable>和<replaceable>M</replaceable>。如果省掉<replaceable>N</replaceable>或<replaceable>M</replaceable>，会假定为<literal>HEAD</literal>。</para>
            <para>缺省情况下，<command>svn diff</command>忽略文件的祖先，只会比较两个文件的内容。如果你使用<option>--notice-ancestry</option>，比较修订版本(也就是，当你运行<command>svn diff</command>比较两个内容相同，但祖先历史不同的对象会看到所有的内容被删除又再次添加)时就会考虑路径的祖先。</para>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>
              <command>di</command>
            </para>
          </refsection>
          <refsection>
            <info>
              <title>改变</title>
            </info>
            <para>无2</para>
          </refsection>
          <refsection>
            <info>
              <title>访问版本库</title>
            </info>
            <para>获得工作拷贝非<literal>BASE</literal>修订版本的区别时会</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--revision (-r) ARG
--change (-c) ARG
--old ARG
--new ARG
--depth ARG
--diff-cmd CMD
--extensions (-x) "ARGS"
--no-diff-deleted
--notice-ancestry
--summarize
--force
--username USER
--password PASS
--no-auth-cache
--non-interactive
--config-dir DIR
--changelist ARG
--xml
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>比较<literal>BASE</literal>和你的工作拷贝(<command>svn diff</command>最经常的用法)：</para>
            <screen>
$ svn diff COMMITTERS 
Index: COMMITTERS
===================================================================
--- COMMITTERS	(revision 4404)
+++ COMMITTERS	(working copy)
</screen>
            <para>查看文件<literal>COMMITTERS</literal>在修订版本9115修改的内容：</para>
            <screen>
$ svn diff -c 9115 COMMITTERS 
Index: COMMITTERS
===================================================================
--- COMMITTERS	(revision 3900)
+++ COMMITTERS	(working copy)
</screen>
            <para>察看你的工作拷贝对旧的修订版本的修改：</para>
            <screen>
$ svn diff -r 3900 COMMITTERS 
Index: COMMITTERS
===================================================================
--- COMMITTERS	(revision 3900)
+++ COMMITTERS	(working copy)
</screen>
            <para>使用<quote>@</quote>语法与修订版本3000和35000比较：</para>
            <screen>
$ svn diff http://svn.collab.net/repos/svn/trunk/COMMITTERS@3000 \
    http://svn.collab.net/repos/svn/trunk/COMMITTERS@3500
Index: COMMITTERS
===================================================================
--- COMMITTERS	(revision 3000)
+++ COMMITTERS	(revision 3500)
…
</screen>
            <para>使用范围符号来比较修订版本3000和3500(在这种情况下只能传递一个URL)：</para>
            <screen>
$ svn diff -r 3000:3500 http://svn.collab.net/repos/svn/trunk/COMMITTERS
Index: COMMITTERS
===================================================================
--- COMMITTERS	(revision 3000)
+++ COMMITTERS	(revision 3500)
</screen>
            <para>使用范围符号比较修订版本3000和3500<filename>trunk</filename>中的所有文件：</para>
            <screen>
$ svn diff -r 3000:3500 http://svn.collab.net/repos/svn/trunk
          </screen>
            <para>使用范围符号比较修订版本3000和3500<filename>trunk</filename>中的三个文件：</para>
            <screen>
$ svn diff -r 3000:3500 --old http://svn.collab.net/repos/svn/trunk COMMITTERS README HACKING
          </screen>
            <para>如果你有工作拷贝，你不必输入这么长的URL：</para>
            <screen>
$ svn diff -r 3000:3500 COMMITTERS 
Index: COMMITTERS
===================================================================
--- COMMITTERS	(revision 3000)
+++ COMMITTERS	(revision 3500)
</screen>
            <para>使用<option>--diff-cmd</option><replaceable>CMD</replaceable><option>-x</option>来指定外部区别程序</para>
            <screen>
$ svn diff --diff-cmd /usr/bin/diff -x "-i -b" COMMITTERS 
Index: COMMITTERS
===================================================================
0a1,2
&gt; This is a test
&gt; 
</screen>
            <para>Lastly, you can use the <option>--xml</option> option
            along with the <option>--summarize</option> option to view
            XML describing the changes that occurred between
            revisions, but not the contents of the diff itself:</para>
            <screen>
$ svn diff --summarize --xml http://svn.red-bean.com/repos/test@r2 \
           http://svn.red-bean.com/repos/test
&lt;?xml version="1.0"?&gt;
&lt;diff&gt;
&lt;paths&gt;
&lt;path
   props="none"
   kind="file"
   item="modified"&amp;gt;http://svn.red-bean.com/repos/test/sandwich.txt&amp;lt;/path&amp;gt;
&lt;path
   props="none"
   kind="file"
   item="deleted"&amp;gt;http://svn.red-bean.com/repos/test/burrito.txt&amp;lt;/path&amp;gt;
&lt;path
   props="none"
   kind="dir"
   item="added"&amp;gt;http://svn.red-bean.com/repos/test/snacks&amp;lt;/path&amp;gt;
&lt;/paths&gt;
&lt;/diff&gt;
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svn.c.export">
          <indexterm>
            <primary>svn</primary>
            <secondary>子命令</secondary>
            <tertiary>export</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svn export</refname>
            <refpurpose>导出一个干净的目录树。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svn export [-r REV] URL[@PEGREV] [PATH]</programlisting>
            <programlisting>svn export [-r REV] PATH1[@PEGREV] [PATH2]</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>第一种从版本库导出干净工作目录树的形式是指定URL，如果指定了修订版本<replaceable>REV</replaceable>，会导出相应的版本，如果没有指定修订版本，则会导出<literal>HEAD</literal>，导出到<replaceable>PATH</replaceable>。如果省略<replaceable>PATH</replaceable>，<replaceable>URL</replaceable>的最后一部分会作为本地目录的名字。</para>
            <para>从工作拷贝导出干净目录树的第二种形式是指定<replaceable>PATH1</replaceable>到<replaceable>PATH2</replaceable>，所有的本地修改将会保留，但是不再版本控制下的文件不会拷贝。</para>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>无</para>
          </refsection>
          <refsection>
            <info>
              <title>改变</title>
            </info>
            <para>本地磁盘</para>
          </refsection>
          <refsection>
            <info>
              <title>访问版本库</title>
            </info>
            <para>只有当从URL导出时会访问</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--depth ARG
--force
--ignore-externals
--native-eol EOL
--quiet (-q)
--revision (-r) REV
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>从你的工作拷贝导出(不会打印每一个文件和目录)：</para>
            <screen>
$ svn export a-wc my-export
Export complete.
</screen>
            <para>从版本库导出目录(打印所有的文件和目录)：</para>
            <screen>
$ svn export file:///var/svn/repos my-export
A  my-export/test
A  my-export/quiz
…
Exported revision 15.
</screen>
            <para>当使用操作系统特定的分发版本，使用特定的EOL字符作为行结束符号导出一棵树会非常有用。<option>--native-eol</option>选项会这样做，但是只会影响拥有<literal>svn:eol-style = native</literal>属性的文件。举个例子，导出一棵使用CRLF作为行结束的树(可能是为了做一个Windows的<literal>.zip</literal>文件分发版本)：</para>
            <screen>
$ svn export file:///var/svn/repos my-export --native-eol CRLF
A  my-export/test
A  my-export/quiz
…
Exported revision 15.
</screen>
            <para>你可以为<option>--native-eol</option>选项指定<literal>LR</literal>、<literal>CR</literal>或<literal>CRLF</literal>作为行结束符。</para>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svn.c.help">
          <indexterm>
            <primary>svn</primary>
            <secondary>子命令</secondary>
            <tertiary>help</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svn help</refname>
            <refpurpose>求助！</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svn help [SUBCOMMAND...]</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>当手边没有这本书时，这是你使用Subversion最好的朋友！</para>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>使用<command>svnserve</command>通过<command>inetd</command></para>
            <para>使用<option>-?</option>、<option>-h</option>和<option>--help</option>选项与使用<command>help</command>子命令效果相同。</para>
          </refsection>
          <refsection>
            <info>
              <title>改变</title>
            </info>
            <para>无2</para>
          </refsection>
          <refsection>
            <info>
              <title>访问版本库</title>
            </info>
            <para>否</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svn.c.import">
          <indexterm>
            <primary>svn</primary>
            <secondary>子命令</secondary>
            <tertiary>import</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svn import</refname>
            <refpurpose>递归提交一个路径的拷贝到版本库。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svn import [PATH] URL</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>递归提交一个<replaceable>PATH</replaceable>到<replaceable>URL</replaceable>。如果省略<replaceable>PATH</replaceable>，默认是<quote><filename>.</filename></quote>。版本库中对应的父目录必须已经创建。未版本化的文件和管道会被忽略，即使设置了<option>--force</option>选项。</para>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>无</para>
          </refsection>
          <refsection>
            <info>
              <title>改变</title>
            </info>
            <para>版本库</para>
          </refsection>
          <refsection>
            <info>
              <title>访问版本库</title>
            </info>
            <para>是</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--auto-props
--depth ARG
--editor-cmd EDITOR
--encoding ENC
--file (-F) FILE
--force
--force-log
--message (-m) TEXT
--no-auto-props
--no-ignore
--quiet (-q)
--with-revprop ARG
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>这将本地目录<filename>myproj</filename>导入到版本库的<filename>trunk/misc</filename>，<filename>trunk/misc</filename>在导入之前不需要存在—<command>svn import</command>会递归的为你创建目录。</para>
            <screen>
$ svn import -m "New import" myproj http://svn.red-bean.com/repos/trunk/misc
Adding         myproj/sample.txt
…
Transmitting file data .........
Committed revision 16.
</screen>
            <para>需要知道这样<emphasis>不</emphasis>会在版本库创建目录<filename>myproj</filename>，如果你希望这样，请在URL后添加<filename>myproj</filename>：</para>
            <screen>
$ svn import -m "New import" myproj http://svn.red-bean.com/repos/trunk/misc/myproj
Adding         myproj/sample.txt
…
Transmitting file data .........
Committed revision 16.
</screen>
            <para>在导入数据之后，你会发现原先的目录树<emphasis>并没有</emphasis>纳入版本控制，为了开始工作，你还是要运行<command>svn checkout</command>得到一个干净的目录树工作拷贝。</para>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svn.c.info">
          <indexterm>
            <primary>svn</primary>
            <secondary>子命令</secondary>
            <tertiary>info</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svn info</refname>
            <refpurpose>显示本地或远程条目的信息。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svn info [TARGET[@REV]...]</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>打印你的工作拷贝路径和URL的信息，包括：</para>
            <itemizedlist>
              <listitem>
                <para>路经</para>
              </listitem>
              <listitem>
                <para>名称</para>
              </listitem>
              <listitem>
                <para>URL</para>
              </listitem>
              <listitem>
                <para>版本库的根</para>
              </listitem>
              <listitem>
                <para>版本库的UUID</para>
              </listitem>
              <listitem>
                <para>Revision</para>
              </listitem>
              <listitem>
                <para>节点类型</para>
              </listitem>
              <listitem>
                <para>最后修改的作者</para>
              </listitem>
              <listitem>
                <para>最后修改的修订版本</para>
              </listitem>
              <listitem>
                <para>最后修改的日期</para>
              </listitem>
              <listitem>
                <para>锁定令牌</para>
              </listitem>
              <listitem>
                <para>锁定拥有者</para>
              </listitem>
              <listitem>
                <para>锁定创建时间(date)</para>
              </listitem>
              <listitem>
                <para>Lock失效时间(date)</para>
              </listitem>
            </itemizedlist>
            <para>Additional kinds of information available only for working copy paths are:</para>
            <itemizedlist>
              <listitem>
                <para>Schedule</para>
              </listitem>
              <listitem>
                <para>拷贝自的URL</para>
              </listitem>
              <listitem>
                <para>拷贝自的修订版本</para>
              </listitem>
              <listitem>
                <para>数据最后更新</para>
              </listitem>
              <listitem>
                <para>属性最后更新</para>
              </listitem>
              <listitem>
                <para>Checksum</para>
              </listitem>
              <listitem>
                <para>Conflict previous base file</para>
              </listitem>
              <listitem>
                <para>Conflict previous working file</para>
              </listitem>
              <listitem>
                <para>Conflict current base file</para>
              </listitem>
              <listitem>
                <para>Conflict properties file</para>
              </listitem>
            </itemizedlist>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>无</para>
          </refsection>
          <refsection>
            <info>
              <title>改变</title>
            </info>
            <para>无2</para>
          </refsection>
          <refsection>
            <info>
              <title>访问版本库</title>
            </info>
            <para>对URL操作时访问</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--changelist ARG
--depth ARG
--incremental
--recursive (-R)
--revision (-r) REV
--targets FILENAME
--xml
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para><command>svn info</command>会展示工作拷贝所有项目的所有有用信息，它会显示文件的信息：</para>
            <screen>
$ svn info foo.c
Path: foo.c
Name: foo.c
URL: http://svn.red-bean.com/repos/test/foo.c
Repository Root: http://svn.red-bean.com/repos/test
Repository UUID: 5e7d134a-54fb-0310-bd04-b611643e5c25
Revision: 4417
Node Kind: file
Schedule: normal
Last Changed Author: sally
Last Changed Rev: 20
Last Changed Date: 2003-01-13 16:43:13 -0600 (Mon, 13 Jan 2003)
Text Last Updated: 2003-01-16 21:18:16 -0600 (Thu, 16 Jan 2003)
Properties Last Updated: 2003-01-13 21:50:19 -0600 (Mon, 13 Jan 2003)
Checksum: /3L38YwzhT93BWvgpdF6Zw==
</screen>
            <para>它也会展示目录的信息：</para>
            <screen>
$ svn info vendors
Path: vendors
URL: http://svn.red-bean.com/repos/test/vendors
Repository Root: http://svn.red-bean.com/repos/test
Repository UUID: 5e7d134a-54fb-0310-bd04-b611643e5c25
Revision: 19
Node Kind: directory
Schedule: normal
Last Changed Author: harry
Last Changed Rev: 19
Last Changed Date: 2003-01-16 23:21:19 -0600 (Thu, 16 Jan 2003)
</screen>
            <para><command>svn info</command>也可以针对URL操作(另外，可以注意一下例子中的<filename>readme.doc</filename>文件已经被锁定，所以也会显示锁定信息)：</para>
            <screen>
$ svn info http://svn.red-bean.com/repos/test/readme.doc
Path: readme.doc
Name: readme.doc
URL: http://svn.red-bean.com/repos/test/readme.doc
Repository Root: http://svn.red-bean.com/repos/test
Repository UUID: 5e7d134a-54fb-0310-bd04-b611643e5c25
Revision: 1
Node Kind: file
Schedule: normal
Last Changed Author: sally
Last Changed Rev: 42
Last Changed Date: 2003-01-14 23:21:19 -0600 (Tue, 14 Jan 2003)
Text Last Updated: 2003-01-14 23:21:19 -0600 (Tue, 14 Jan 2003)
Checksum: d41d8cd98f00b204e9800998ecf8427e
Lock Token: opaquelocktoken:14011d4b-54fb-0310-8541-dbd16bd471b2
Lock Owner: harry
Lock Created: 2003-01-15 17:35:12 -0600 (Wed, 15 Jan 2003)
</screen>
            <para>Lastly, <command>svn info</command> output is
             available in XML format by passing
             the<option>--xml</option> option:</para>
            <screen>
$ svn info --xml http://svn.red-bean.com/repos/test
&lt;?xml version="1.0"?&gt;
&lt;info&gt;
&lt;entry
   kind="dir"
   path="."
   revision="1"&gt;
&lt;url&gt;http://svn.red-bean.com/repos/test&lt;/url&gt;
&lt;repository&gt;
&lt;root&gt;http://svn.red-bean.com/repos/test&lt;/root&gt;
&lt;uuid&gt;5e7d134a-54fb-0310-bd04-b611643e5c25&lt;/uuid&gt;
&lt;/repository&gt;
&lt;wc-info&gt;
&lt;schedule&gt;normal&lt;/schedule&gt;
&lt;depth&gt;infinity&lt;/depth&gt;
&lt;/wc-info&gt;
&lt;commit
   revision="1"&gt;
&lt;author&gt;sally&lt;/author&gt;
&lt;date&gt;2003-01-15T23:35:12.847647Z&lt;/date&gt;
&lt;/commit&gt;
&lt;/entry&gt;
&lt;/info&gt;
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svn.c.list">
          <indexterm>
            <primary>svn</primary>
            <secondary>子命令</secondary>
            <tertiary>list</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svn list</refname>
            <refpurpose>列出版本库目录的条目。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svn list [TARGET[@REV]...]</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>列出每一个<replaceable>TARGET</replaceable>文件和<replaceable>TARGET</replaceable>目录的内容，如果<replaceable>TARGET</replaceable>是工作拷贝路径，会使用对应的版本库URL。</para>
            <para>缺省的<replaceable>TARGET</replaceable>是<quote><filename>.</filename></quote>，意味着当前工作拷贝的版本库URL。</para>
            <para>如果一个客户端连接到<command>svnserve</command>进程，如下事情会发生：</para>
            <itemizedlist>
              <listitem>
                <para>最后一次提交的修订版本号</para>
              </listitem>
              <listitem>
                <para>最后一次提交的作者</para>
              </listitem>
              <listitem>
                <para>如果锁定，字符为<quote>O</quote>(更多细节见<xref linkend="svn.ref.svn.c.info"/>)</para>
              </listitem>
              <listitem>
                <para>大小(单位字节)</para>
              </listitem>
              <listitem>
                <para>最后提交的日期时间</para>
              </listitem>
            </itemizedlist>
            <para>使用选项<option>--xml</option>，输出是XML格式(如果没有指定<option>--incremental</option>，会包括一个头和一个围绕的元素)。会展示所有的信息；不接受<option>--verbose</option>选项。</para>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>
              <command>ls</command>
            </para>
          </refsection>
          <refsection>
            <info>
              <title>改变</title>
            </info>
            <para>无2</para>
          </refsection>
          <refsection>
            <info>
              <title>访问版本库</title>
            </info>
            <para>是</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--depth ARG
--incremental
--recursive (-R)
--revision (-r) REV
--verbose (-v)
--xml
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>如果你希望在没有下载工作拷贝时查看版本库有哪些文件，<command>svn list</command>会非常有用：</para>
            <screen>
$ svn list http://svn.red-bean.com/repos/test/support
README.txt
INSTALL
examples/
…
</screen>
            <para>你也可以传递<option>--verbose</option>选项来得到额外信息，非常类似UNIX的<command>ls -l</command>命令：</para>
            <screen>
$ svn list --verbose file:///var/svn/repos
     16 sally         28361 Jan 16 23:18 README.txt
     27 sally             0 Jan 18 15:27 INSTALL
     24 harry               Jan 18 11:27 examples/
</screen>
            <para>You can also get <command>svn list</command> output in
            XML format with the <option>--xml</option> option:</para>
            <screen>
$ svn list --xml http://svn.red-bean.com/repos/test
&lt;?xml version="1.0"?&gt;
&lt;lists&gt;
&lt;list
   path="http://svn.red-bean.com/repos/test"&gt;
&lt;entry
   kind="dir"&gt;
&lt;name&gt;examples&lt;/name&gt;
&lt;size&gt;0&lt;/size&gt;
&lt;commit
   revision="24"&gt;
&lt;author&gt;harry&lt;/author&gt;
&lt;date&gt;2008-01-18T06:35:53.048870Z&lt;/date&gt;
&lt;/commit&gt;
&lt;/entry&gt;
...
&lt;/list&gt;
&lt;/lists&gt;
</screen>
            <para>更多细节见<xref linkend="svn.tour.history.browsing.list"/>。</para>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svn.c.lock">
          <indexterm>
            <primary>svn</primary>
            <secondary>子命令</secondary>
            <tertiary>lock</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svn lock</refname>
            <refpurpose>锁定版本库的工作拷贝路径或URL，所以没有其他用户可以提交这些文件的修改。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>Synopsis</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>svn lock TARGET...</para>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>无</para>
          </refsection>
          <refsection>
            <info>
              <title>改变</title>
            </info>
            <para>工作拷贝，版本库</para>
          </refsection>
          <refsection>
            <info>
              <title>访问版本库</title>
            </info>
            <para>是</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--encoding ENC
--file (-F) FILE
--force
--force-log
--message (-m) TEXT
--targets FILENAME
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>在工作拷贝锁定两个文件：</para>
            <screen>
$ svn lock tree.jpg house.jpg
'tree.jpg' locked by user 'harry'.
'house.jpg' locked by user 'harry'.
</screen>
            <para>锁定工作拷贝的一个被其它用户锁定的文件：</para>
            <screen>
$ svn lock tree.jpg
svn: warning: Path '/tree.jpg is already locked by user 'sally in \
     filesystem '/var/svn/repos/db'

$ svn lock --force tree.jpg
'tree.jpg' locked by user 'harry'.
</screen>
            <para>没有工作拷贝的情况下锁定文件：</para>
            <screen>
$ svn lock http://svn.red-bean.com/repos/test/tree.jpg
'tree.jpg' locked by user 'harry'.
</screen>
            <para>更多细节见<xref linkend="svn.advanced.locking"/>。</para>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svn.c.log">
          <indexterm>
            <primary>svn</primary>
            <secondary>子命令</secondary>
            <tertiary>log</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svn log</refname>
            <refpurpose>显示提交日志信息。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svn log [PATH]</programlisting>
            <programlisting>svn log URL[@REV] [PATH...]</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>缺省目标是你的当前目录的路径，如果没有提供参数，<command>svn log</command>会显示当前目录下的所有文件和目录的日志信息，你可以通过指定路径来精炼结果，一个或多个修订版本，或者是任何两个的组合。对于本地路径的缺省修订版本范围<literal>BASE:1</literal>。</para>
            <para>如果你只是指定一个URL，就会打印这个URL上所有的日志信息，如果添加部分路径，只有这条路径下的URL信息会被打印，URL缺省的修订版本范围是<literal>HEAD:1</literal>。</para>
            <para><command>svn log</command>使用<option>--verbose</option>选项也会打印所有影响路径的日志信息，使用<option>--quiet</option>选项不会打印日志信息正文本身(这与<option>--verbose</option>协调一致)。</para>
            <para>每个日志信息只会打印一次，即使是那些明确请求不止一次的路径，日志会跟随在拷贝过程中，使用<option>--stop-on-copy</option>可以关闭这个特性，可以用来监测分支点。</para>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>无</para>
          </refsection>
          <refsection>
            <info>
              <title>改变</title>
            </info>
            <para>无2</para>
          </refsection>
          <refsection>
            <info>
              <title>访问版本库</title>
            </info>
            <para>是</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--change (-c) ARG
--incremental
--limit (-l) NUM
--quiet (-q)
--revision (-r) REV
--stop-on-copy
--targets FILENAME
--use-merge-history (-g)
--verbose (-v)
--with-all-revprops
--with-revprop ARG
--xml
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>你可以在顶级目录运行<command>svn log</command>看到工作拷贝中所有修改的路径的日志信息：</para>
            <screen>
$ svn log
------------------------------------------------------------------------
r20 | harry | 2003-01-17 22:56:19 -0600 (Fri, 17 Jan 2003) | 1 line

Tweak.
------------------------------------------------------------------------
r17 | sally | 2003-01-16 23:21:19 -0600 (Thu, 16 Jan 2003) | 2 lines
…
</screen>
            <para>检验一个特定文件所有的日志信息：</para>
            <screen>
$ svn log foo.c
------------------------------------------------------------------------
r32 | sally | 2003-01-13 00:43:13 -0600 (Mon, 13 Jan 2003) | 1 line

Added defines.
------------------------------------------------------------------------
r28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines
…
</screen>
            <para>如果你手边没有工作拷贝，你可以查看一个URL的日志：</para>
            <screen>
$ svn log http://svn.red-bean.com/repos/test/foo.c
------------------------------------------------------------------------
r32 | sally | 2003-01-13 00:43:13 -0600 (Mon, 13 Jan 2003) | 1 line

Added defines.
------------------------------------------------------------------------
r28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines
…
</screen>
            <para>如果你希望查看某个URL下面不同的多个路径，你可以使用<literal>URL [PATH...]</literal>语法。</para>
            <screen>
$ svn log http://svn.red-bean.com/repos/test/ foo.c bar.c
------------------------------------------------------------------------
r32 | sally | 2003-01-13 00:43:13 -0600 (Mon, 13 Jan 2003) | 1 line

Added defines.
------------------------------------------------------------------------
r31 | harry | 2003-01-10 12:25:08 -0600 (Fri, 10 Jan 2003) | 1 line

Added new file bar.c
------------------------------------------------------------------------
r28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines
…
</screen>
            <para>The <option>--verbose</option> option causes
            <command>svn log</command> to include information about
            the paths that were changed in each displayed revision.
            These paths appear, one path per line of output, with
            action codes that indicate what type of change was made to
            the path.</para>
            <screen>
$ svn log -v http://svn.red-bean.com/repos/test/ foo.c bar.c
------------------------------------------------------------------------
r32 | sally | 2003-01-13 00:43:13 -0600 (Mon, 13 Jan 2003) | 1 line
Changed paths:
   M /foo.c

Added defines.
------------------------------------------------------------------------
r31 | harry | 2003-01-10 12:25:08 -0600 (Fri, 10 Jan 2003) | 1 line
Changed paths:
   A /bar.c

Added new file bar.c
------------------------------------------------------------------------
r28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines
…
</screen>
            <para><command>svn log</command> uses just a handful of action codes,
            and they are similar to the
            ones the <command>svn update</command>
            command uses:</para>
            <variablelist>
              <varlistentry>
                <term>
                  <literal>A</literal>
                </term>
                <listitem>
                  <para>The item was added.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                  <literal>D</literal>
                </term>
                <listitem>
                  <para>The item was deleted.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                  <literal>M</literal>
                </term>
                <listitem>
                  <para>条目属性改变了，注意开头的空格。</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                  <literal>R</literal>
                </term>
                <listitem>
                  <para>The item was replaced by a different one
                at the same location.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <para>In addition to the action codes which precede the
            changed paths, <command>svn log</command> with the <option>--verbose</option> option will
            note whether a path was added or replaced as the result of a copy
            operation.  It does so by printing <literal>(from
            <replaceable>COPY-FROM-PATH</replaceable>:<replaceable>COPY-FROM-REV</replaceable>)</literal>
            after such paths.</para>
            <para>当你想连接多个对日志命令的调用结果，你会希望使用<option>--incremental</option>选项。<command>svn log</command>通常会在日志信息的开头和每一小段间打印一行虚线，如果你对一段修订版本运行<command>svn log</command>，你会得到下面的结果：</para>
            <screen>
$ svn log -r 14:15
------------------------------------------------------------------------
r14 | ...

------------------------------------------------------------------------
r15 | ...

------------------------------------------------------------------------
</screen>
            <para>然而，如果你希望收集两个不连续的日志信息到一个文件，你会这样做：</para>
            <screen>
$ svn log -r 14 &gt; mylog
$ svn log -r 19 &gt;&gt; mylog
$ svn log -r 27 &gt;&gt; mylog
$ cat mylog
------------------------------------------------------------------------
r14 | ...

------------------------------------------------------------------------
------------------------------------------------------------------------
r19 | ...

------------------------------------------------------------------------
------------------------------------------------------------------------
r27 | ...

------------------------------------------------------------------------
</screen>
            <para>你可以使用incremental选项来避免两行虚线带来的混乱：</para>
            <screen>
$ svn log --incremental -r 14 &gt; mylog
$ svn log --incremental -r 19 &gt;&gt; mylog
$ svn log --incremental -r 27 &gt;&gt; mylog
$ cat mylog
------------------------------------------------------------------------
r14 | ...

------------------------------------------------------------------------
r19 | ...

------------------------------------------------------------------------
r27 | ...
</screen>
            <para><option>--incremental</option>选项为<option>--xml</option>提供了一个相似的输出控制。</para>
            <screen>
$ svn log --xml --incremental -r 1 sandwich.txt
&lt;logentry
   revision="1"&gt;
&lt;author&gt;harry&lt;/author&gt;
&lt;date&gt;2008-06-03T06:35:53.048870Z&lt;/date&gt;
&lt;msg&gt;Initial Import.&lt;/msg&gt;
&lt;/logentry&gt;
</screen>
            <tip>
              <para>如果你在特定路径和修订版本运行<command>svn log</command>，输出结果为空</para>
              <screen>
$ svn log -r 20 http://svn.red-bean.com/untouched.txt
------------------------------------------------------------------------
</screen>
              <para>这只意味着这条路径在那个修订版本没有修改，如果从版本库的顶级目录运行这个命令，或者是你知道那个修订版本修改了那个文件，你可以明确的指定它：</para>
              <screen>
$ svn log -r 20 touched.txt 
------------------------------------------------------------------------
r20 | sally | 2003-01-17 22:56:19 -0600 (Fri, 17 Jan 2003) | 1 line

Made a change.
------------------------------------------------------------------------
</screen>
            </tip>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svn.c.merge">
          <indexterm>
            <primary>svn</primary>
            <secondary>子命令</secondary>
            <tertiary>merge</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svn merge</refname>
            <refpurpose>应用两组源文件的差别到工作拷贝路径。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svn merge sourceURL1[@N] sourceURL2[@M] [WCPATH]</programlisting>
            <programlisting>svn merge sourceWCPATH1@N sourceWCPATH2@M [WCPATH]</programlisting>
            <programlisting>svn merge [[-c M]... | [-r N:M]...] [SOURCE[@REV] [WCPATH]]</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>第一种形式里，源路径(第一种是URL，第二种是工作拷贝路径)用修订版本号<literal>N</literal>和<literal>M</literal>指定，这是要比较的两组源文件，如果省略修订版本号，缺省是<literal>HEAD</literal>。</para>
            <para>In the second form, the URLs corresponding to the
            source working copy paths define the sources to be
            compared.  The revisions must be specified.</para>
            <para>在第三种形式里，<replaceable>SOURCE</replaceable>可以是URL或工作拷贝路径(会使用对应的URL)，如果没有指定，<replaceable>SOURCE</replaceable>将会与<replaceable>WCPATH</replaceable>相同。修订版本<replaceable>REV</replaceable>的<replaceable>SOURCE</replaceable>会比较存在的<replaceable>N</replaceable>和<replaceable>。如果没有指定<replaceable>REV</replaceable>，则假定是<literal>HEAD</literal>。</replaceable></para>
            <para><literal>-c M</literal> is equivalent to <literal>-r
            &lt;M-1&gt;:M</literal>, and <literal>-c -M</literal> does
            the reverse: <literal>-r M:&lt;M-1&gt;</literal>.  If no
            revision ranges are specified, the default range of
            <literal>1:HEAD</literal> is used.  Multiple
            <literal>-c</literal> and/or <literal>-r</literal>
            instances may be specified, and mixing of forward and
            reverse ranges is allowed—the ranges are internally
            compacted to their minimum representation before merging
            begins (which may result in no-op).</para>
            <para><replaceable>WCPATH</replaceable>是接收变化的工作拷贝路径，如果省略<replaceable>WCPATH</replaceable>，会假定缺省值<quote><filename>.</filename></quote>，除非源有相同基本名称与<quote><filename>.</filename></quote>中的某一文件名字匹配：在这种情况下，区别会应用到那个文件。</para>
            <para>如果两个源是祖先相关的，Subversion只会在合并操作时内部跟踪元数据—如果第一个源是第二个的祖先或相反，这是使用第三种形式时对这种形式的担保。不像<command>svn diff</command>，合并操作在执行时会考虑文件的祖先，当你从一个分支合并到另一个分支，而这两个分支有各自重命名的文件时，这一点会非常重要。</para>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>无</para>
          </refsection>
          <refsection>
            <info>
              <title>改变</title>
            </info>
            <para>工作拷贝2</para>
          </refsection>
          <refsection>
            <info>
              <title>访问版本库</title>
            </info>
            <para>只有在对URL操作时会</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--accept ARG
--change (-c) REV
--depth ARG
--diff3-cmd CMD
--dry-run
--extensions (-x) ARG
--force
--ignore-ancestry
--quiet (-q)
--record-only
--reintegrate
--revision (-r) REV
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>将一个分支合并回主干(假定你有一份主干的最新工作拷贝)：</para>
            <screen>
$ svn merge --reintegrate http://svn.example.com/repos/calc/branches/my-calc-branch
--- Merging differences between repository URLs into '.':
U    button.c
U    integer.c
U    Makefile
 U   .

$ # build, test, verify, ...

$ svn commit -m "Merge my-calc-branch back into trunk!"
Sending        .
Sending        button.c
Sending        integer.c
Sending        Makefile
Transmitting file data ..
Committed revision 391.
</screen>
            <para>合并一个单独文件的修改：</para>
            <screen>
$ cd myproj
$ svn merge -r 30:31 thhgttg.txt 
U  thhgttg.txt
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svn.c.mergeinfo">
          <indexterm>
            <primary>svn</primary>
            <secondary>子命令</secondary>
            <tertiary>mergeinfo</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svn mergeinfo</refname>
            <refpurpose>查询合并相关信息，见<xref linkend="svn.branchmerge.basicmerging.mergeinfo"/>。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svn mergeinfo [TARGET[@REV]...]</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>Query information related to merges (or potential
            merges) between <replaceable>SOURCE-URL</replaceable> and
            <replaceable>TARGET</replaceable>.  If
            the <option>--show-revs</option> option is not provided,
            display revisions which have been merged
            from <replaceable>SOURCE-URL</replaceable>
            to <replaceable>TARGET</replaceable>.  Otherwise, display
            either <literal>merged</literal>
            or <literal>eligible</literal> revisions as specified by
            the <option>--show-revs</option> option.</para>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>无</para>
          </refsection>
          <refsection>
            <info>
              <title>改变</title>
            </info>
            <para>无2</para>
          </refsection>
          <refsection>
            <info>
              <title>访问版本库</title>
            </info>
            <para>是</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--revision (-r) REV
--show-ids
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>Find out which changesets your trunk directory has
            already received as well as what changesets it's still
            eligible to receive:</para>
            <screen>
$ svn mergeinfo branches/test
Path: branches/test
  Source path: /trunk
    Merged ranges: r2:13
    Eligible ranges: r13:15
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svn.c.mkdir">
          <indexterm>
            <primary>svn</primary>
            <secondary>子命令</secondary>
            <tertiary>mkdir</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svn mkdir</refname>
            <refpurpose>创建一个纳入版本控制的新目录。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svn mkdir PATH...</programlisting>
            <programlisting>svn mkdir URL...</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>创建一个目录，名字是提供的<replaceable>PATH</replaceable>或者URL的最后一部分，工作拷贝<replaceable>PATH</replaceable>指定的目录会预定要添加，而通过URL指定的目录会作为一次立即提交在版本库建立。多个目录URL的提交是原子操作，在两种情况下，除非使用<option>--parents</option>选项，中介目录必须已经存在。</para>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>无</para>
          </refsection>
          <refsection>
            <info>
              <title>改变</title>
            </info>
            <para>工作拷贝；如果是对URL操作则会影响版本库</para>
          </refsection>
          <refsection>
            <info>
              <title>访问版本库</title>
            </info>
            <para>只有在对URl操作时会</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--editor-cmd EDITOR
--encoding ENC
--file (-F) FILE
--force-log
--message (-m) TEXT
--parents
--quiet (-q)
--with-revprop ARG
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>在工作拷贝创建一个目录：</para>
            <screen>
$ svn mkdir newdir
A         newdir
</screen>
            <para>在版本库创建一个目录(立即提交，所以需要日志信息)：</para>
            <screen>
$ svn mkdir -m "Making a new dir." http://svn.red-bean.com/repos/newdir

Committed revision 26.
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svn.c.move">
          <indexterm>
            <primary>svn</primary>
            <secondary>子命令</secondary>
            <tertiary>move</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svn move</refname>
            <refpurpose>移动一个文件或目录。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svn move SRC... DST</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>这个命令移动文件或目录到你的工作拷贝或者是版本库。</para>
            <tip>
              <para>这个命令同<command>svn copy</command>加一个<command>svn delete</command>等同。</para>
            </tip>
            <para>When moving multiple sources, they will be added as
            children of <replaceable>DST</replaceable>, which must be
            a directory.</para>
            <note>
              <para>Subversion不支持在工作拷贝和URL之间拷贝，此外，你只可以一个版本库内移动文件—Subversion不支持跨版本库的移动。</para>
            </note>
            <variablelist>
              <varlistentry>
                <term>WC → WC</term>
                <listitem>
                  <para>移动和预订一个文件或目录将要添加(包含历史)。</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>URL → URL</term>
                <listitem>
                  <para>完全服务器端的重命名。</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>使用<command>svnserve</command>通过<command>inetd</command></para>
          </refsection>
          <refsection>
            <info>
              <title>改变</title>
            </info>
            <para>工作拷贝；如果是对URL操作则会影响版本库</para>
          </refsection>
          <refsection>
            <info>
              <title>访问版本库</title>
            </info>
            <para>只有在对URl操作时会</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--editor-cmd EDITOR
--encoding ENC
--file (-F) FILE
--force
--force-log
--message (-m) TEXT
--parents
--quiet (-q)
--revision (-r) REV
--with-revprop ARG
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>移动工作拷bede一个文件：</para>
            <screen>
$ svn move foo.c bar.c
A         bar.c
D         foo.c
</screen>
            <para>移动工作拷贝的一些文件到子目录：</para>
            <screen>
$ svn move baz.c bat.c qux.c src
A         src/baz.c
D         baz.c
A         src/bat.c
D         bat.c
A         src/qux.c
D         qux.c
</screen>
            <para>移动版本库中的一个文件(一个立即提交，所以需要提交信息)：</para>
            <screen>
$ svn move -m "Move a file" http://svn.red-bean.com/repos/foo.c \
                            http://svn.red-bean.com/repos/bar.c

Committed revision 27.
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svn.c.propdel">
          <indexterm>
            <primary>svn</primary>
            <secondary>子命令</secondary>
            <tertiary>propdel</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svn propdel</refname>
            <refpurpose>删除一个项目的一个属性。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svn propdel PROPNAME [PATH...]</programlisting>
            <programlisting>svn propdel PROPNAME --revprop -r REV [TARGET]</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>这会删除文件、目录或修订版本的属性。第一种形式是在工作拷贝删除版本化属性，第二种是在一个版本库修订版本中删除未版本化的属性(<replaceable>TARGET</replaceable>只是用来确定访问哪个版本库)。</para>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>使用<command>svnserve</command>通过<command>inetd</command></para>
          </refsection>
          <refsection>
            <info>
              <title>改变</title>
            </info>
            <para>工作拷贝；对URL操作时是版本库</para>
          </refsection>
          <refsection>
            <info>
              <title>访问版本库</title>
            </info>
            <para>只有在对URl操作时会</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--changelist ARG
--depth ARG
--quiet (-q)
--recursive (-R)
--revision (-r) REV
--revprop
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>删除你的工作拷贝中一个文件的一个属性</para>
            <screen>
$ svn propdel svn:mime-type  some-script
property 'svn:mime-type' deleted from 'some-script'.
</screen>
            <para>删除一个修订版本的属性：</para>
            <screen>
$ svn propdel --revprop -r 26 release-date 
property 'release-date' deleted from repository revision '26'
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svn.c.propedit">
          <indexterm>
            <primary>svn</primary>
            <secondary>子命令</secondary>
            <tertiary>propedit</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svn propedit</refname>
            <refpurpose>修改一个或多个版本控制之下文件的属性。见<xref linkend="svn.ref.svn.c.propset"/>。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svn propedit PROPNAME TARGET...</programlisting>
            <programlisting>svn propedit PROPNAME --revprop -r REV [TARGET]</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>使用喜欢的编辑器编辑一个或多个属性，第一种形式是在工作拷贝编辑版本化的属性，第二种形式是远程编辑未版本化的版本库修订版本属性(<replaceable>TARGET</replaceable>只是用来确定访问哪个版本库)。</para>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>使用<command>svnserve</command>通过<command>inetd</command></para>
          </refsection>
          <refsection>
            <info>
              <title>改变</title>
            </info>
            <para>工作拷贝；对URL操作时是版本库</para>
          </refsection>
          <refsection>
            <info>
              <title>访问版本库</title>
            </info>
            <para>只有在对URl操作时会</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--editor-cmd EDITOR
--encoding ENC
--file (-F) ARG
--force
--force-log
--message (-m) ARG
--revision (-r) REV
--revprop
--with-revprop ARG
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para><command>svn propedit</command>对修改多个值的属性非常简单：</para>
            <screen>
$ svn propedit svn:keywords  foo.c 
    &lt;svn will launch your favorite editor here, with a buffer open
    containing the current contents of the svn:keywords property.  You
    can add multiple values to a property easily here by entering one
    value per line.&gt;
Set new value for property 'svn:keywords' on 'foo.c'
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svn.c.propget">
          <indexterm>
            <primary>svn</primary>
            <secondary>子命令</secondary>
            <tertiary>propget</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svn propget</refname>
            <refpurpose>打印一个属性的值。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svn propget PROPNAME [TARGET[@REV]...]</programlisting>
            <programlisting>svn propget PROPNAME --revprop -r REV [URL]</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>打印一个文件、目录或修订版本的一个属性的值，第一种形式是打印工作拷贝中一个或多个项目的版本化的属性，第二种形式是远程打印版本库修订版本的未版本化的属性。属性的详情见<xref linkend="svn.advanced.props"/>。</para>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>使用<command>svnserve</command>通过<command>inetd</command></para>
          </refsection>
          <refsection>
            <info>
              <title>改变</title>
            </info>
            <para>工作拷贝；对URL操作时是版本库</para>
          </refsection>
          <refsection>
            <info>
              <title>访问版本库</title>
            </info>
            <para>只有在对URl操作时会</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--changelist ARG
--depth ARG
--recursive (-R)
--revision (-r) REV
--revprop
--strict
--xml
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>检查工作拷贝的一个文件的一个属性：</para>
            <screen>
$ svn propget svn:keywords foo.c
Author
Date
Rev
</screen>
            <para>对于修订版本属性相同：</para>
            <screen>
$ svn propget svn:log --revprop -r 20 
Began journal.
</screen>
            <para>Lastly, you can get <command>svn propget</command>
            output in XML format with the <option>--xml</option>
            option:</para>
            <screen>
$ svn propget --xml svn:ignore .
&lt;?xml version="1.0"?&gt;
&lt;properties&gt;
&lt;target
   path=""&gt;
&lt;property
   name="svn:ignore"&gt;*.o
&lt;/property&gt;
&lt;/target&gt;
&lt;/properties&gt;
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svn.c.proplist">
          <indexterm>
            <primary>svn</primary>
            <secondary>子命令</secondary>
            <tertiary>proplist</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svn proplist</refname>
            <refpurpose>列出所有的属性。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svn proplist [TARGET[@REV]...]</programlisting>
            <programlisting>svn proplist --revprop -r REV [TARGET]</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>列出文件、目录或修订版本的属性，第一种形式是列出工作拷贝的所有版本化的属性，第二种形式是列出版本库修订版本的未版本化的属性(<replaceable>TARGET</replaceable>只是用来确定访问哪个版本库)。</para>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>使用<command>svnserve</command>通过<command>inetd</command></para>
          </refsection>
          <refsection>
            <info>
              <title>改变</title>
            </info>
            <para>工作拷贝；对URL操作时是版本库</para>
          </refsection>
          <refsection>
            <info>
              <title>访问版本库</title>
            </info>
            <para>只有在对URl操作时会</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--changelist ARG
--depth ARG
--quiet (-q)
--recursive (-R)
--revision (-r) REV
--revprop
--verbose (-v)
--xml
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>你可以使用proplist察看你的工作拷贝的一个项目的属性：</para>
            <screen>
$ svn proplist foo.c
Properties on 'foo.c':
  svn:mime-type
  svn:keywords
  owner
</screen>
            <para>通过<option>--verbose</option>选项，svn proplist也可以非常便利的显示属性的值：</para>
            <screen>
$ svn proplist --verbose foo.c
Properties on 'foo.c':
  svn:mime-type : text/plain
  svn:keywords : Author Date Rev
  owner : sally
</screen>
            <para>Lastly, you can get <command>svn proplist</command>
            output in xml format with the <option>--xml</option>
            option:</para>
            <screen>
$ svn proplist --xml 
&lt;?xml version="1.0"?&gt;
&lt;properties&gt;
&lt;target
   path="."&gt;
&lt;property
   name="svn:ignore"/&gt;
&lt;/target&gt;
&lt;/properties&gt;
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svn.c.propset">
          <indexterm>
            <primary>svn</primary>
            <secondary>子命令</secondary>
            <tertiary>propset</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svn propset</refname>
            <refpurpose><replaceable>NAME</replaceable>。删除工作拷贝文件或目录的<replaceable>NAME</replaceable>状态。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svn propset PROPNAME [PROPVAL | -F VALFILE] PATH...</programlisting>
            <programlisting>svn propset PROPNAME --revprop -r REV [PROPVAL | -F VALFILE] [TARGET]</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>设置文件、目录或者修订版本的属性<replaceable>PROPNAME</replaceable>为<replaceable>PROPVAL</replaceable>。第一个例子在工作拷贝创建了一个版本化的本地属性修改，第二个例子创建了一个未版本化的远程的对版本库修订版本的属性修改(<replaceable>TARGET</replaceable>只是用来确定访问哪个版本库)。</para>
            <tip>
              <para>Subversion有一系列<quote>特殊的</quote>影响行为方式的属性，关于这些属性的详情请见<xref linkend="svn.ref.properties"/>。</para>
            </tip>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>服务器比较<replaceable>TARGET@N</replaceable>和<replaceable>TARGET<replaceable>TARGET@M</replaceable>。</replaceable></para>
          </refsection>
          <refsection>
            <info>
              <title>改变</title>
            </info>
            <para>工作拷贝；对URL操作时是版本库</para>
          </refsection>
          <refsection>
            <info>
              <title>访问版本库</title>
            </info>
            <para>只有在对URl操作时会</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--changelist ARG
--depth ARG
--encoding ENC
--file (-F) FILE
--force
--quiet (-q)
--recursive (-R)
--revision (-r) REV
--revprop
--targets FILENAME
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>设置文件的mimetype：</para>
            <screen>
$ svn propset svn:mime-type image/jpeg foo.jpg 
property 'svn:mime-type' set on 'foo.jpg'
</screen>
            <para>在UNIX系统，如果你希望一个文件设置执行权限：</para>
            <screen>
$ svn propset svn:executable ON somescript
property 'svn:executable' set on 'somescript'
</screen>
            <para>或许为了合作者的利益你有一个内部的属性设置：</para>
            <screen>
$ svn propset owner sally foo.c
property 'owner' set on 'foo.c'
</screen>
            <para>如果你在特定修订版本的日志信息里有一些错误，并且希望修改，可以使用<option>--revprop</option>设置<literal>svn:log</literal>为新的日志信息：</para>
            <screen>
$ svn propset --revprop -r 25 svn:log "Journaled about trip to New York."
property 'svn:log' set on repository revision '25'
</screen>
            <para>或者，你没有工作拷贝，你可以提供一个URL：</para>
            <screen>
$ svn propset --revprop -r 26 svn:log "Document nap." http://svn.red-bean.com/repos
property 'svn:log' set on repository revision '25'
</screen>
            <para>最后，你可以告诉propset从一个文件得到输入，你甚至可以使用这个方式来设置一个属性为二进制内容：</para>
            <screen>
$ svn propset owner-pic -F sally.jpg moo.c 
property 'owner-pic' set on 'moo.c'
</screen>
            <note>
              <para>缺省，你不可以在Subversion版本库修改修订版本属性，你的版本库管理员必须显示的通过创建一个名字为<literal>pre-revprop-change</literal>的钩子来允许修订版本属性修改，关于钩子脚本的详情请见<xref linkend="svn.reposadmin.create.hooks"/>。</para>
            </note>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svn.c.resolve">
          <indexterm>
            <primary>svn</primary>
            <secondary>子命令</secondary>
            <tertiary>resolve</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svn resolved</refname>
            <refpurpose>解决工作拷贝文件或目录的冲突。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svn resolve PATH...</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>解决工作拷贝文件或目录的<quote>conflicted</quote>状态。这个程序不是语义上的改变冲突标志，而且，它使用<option>--accept</option>参数指定的版本来替换<replaceable>PATH</replaceable>，然后删除冲突相关的人造文件，从而重新允许<replaceable>PATH</replaceable>提交—也就是说，它告诉Subversion冲突已经<quote>解决了</quote>。根据你的期望解决办法，你可以为 <option>--accept</option>命令传递如下参数：</para>
            <variablelist>
              <varlistentry>
                <term>
                  <literal>base</literal>
                </term>
                <listitem>
                  <para>这是你的做更新操作以前的<literal>BASE</literal>版本文件，就是你在上次更新之后未作更改的版本。</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                  <literal>working</literal>
                </term>
                <listitem>
                  <para>Assuming that you've manually handled the
                conflict resolution, choose the version of the file as
                it currently stands in your working copy.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                  <literal>mine-full</literal>
                </term>
                <listitem>
                  <para>Resolve all conflicted files with copies of the
                files as they stood immediately before you
                ran <command>svn update</command>.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                  <literal>theirs-full</literal>
                </term>
                <listitem>
                  <para>Resolve all conflicted files with copies of the
                files that were fetched from the server when you
                ran <command>svn update</command>.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <para>关于解决冲突的深入介绍可以看<xref linkend="svn.tour.cycle.resolve"/>。</para>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>无</para>
          </refsection>
          <refsection>
            <info>
              <title>改变</title>
            </info>
            <para>工作拷贝2</para>
          </refsection>
          <refsection>
            <info>
              <title>访问版本库</title>
            </info>
            <para>否</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--targets FILENAME
--depth ARG
--quiet (-q)
--config-dir DIR
--changelist ARG
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>Here's an example where, after a postponed conflict
            resolution during update, <command>svn resolve</command>
            replaces the all conflicts in
            file <filename>foo.c</filename> with your edits:</para>
            <screen>
$ svn up
Conflict discovered in 'foo.c'.
Select: (p) postpone, (df) diff-full, (e) edit,
        (h) help for more options: p
C    foo.c
Updated to revision 5.

$ svn resolve --accept mine-full foo.c
Resolved conflicted state of 'foo.c'
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svn.c.resolved">
          <indexterm>
            <primary>svn</primary>
            <secondary>子命令</secondary>
            <tertiary>resolved</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svn resolved</refname>
            <refpurpose><emphasis>废弃的</emphasis>。删除工作拷贝文件或目录的<emphasis>废弃的</emphasis>状态。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svn resolved PATH...</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>This command has been deprecated in favor of
            running <userinput>svn resolve --accept working <replaceable>PATH</replaceable></userinput>.
            See <xref linkend="svn.ref.svn.c.resolve"/> in the preceding section for
            details.</para>
            <para>删除工作拷贝文件或目录的<quote>conflicted</quote>状态。这个程序不是语义上的改变冲突标志，它只是删除冲突相关的人造文件，从而重新允许<replaceable>PATH</replaceable>提交；也就是说，它告诉Subversion冲突已经<quote>解决了</quote>。关于解决冲突更深入的考虑可以查看<xref linkend="svn.tour.cycle.resolve"/>。</para>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>无</para>
          </refsection>
          <refsection>
            <info>
              <title>改变</title>
            </info>
            <para>工作拷贝2</para>
          </refsection>
          <refsection>
            <info>
              <title>访问版本库</title>
            </info>
            <para>否</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--depth ARG
--quiet (-q)
--recursive (-R)
--targets FILENAME
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>如果你在更新时得到冲突，你的工作拷贝会产生三个新的文件：</para>
            <screen>
$ svn update
C  foo.c
Updated to revision 31.
$ ls
foo.c
foo.c.mine
foo.c.r30
foo.c.r31
</screen>
            <para>当你解决了<filename>foo.c</filename>的冲突，并且准备提交，运行<command>svn resolved</command>让你的工作拷贝知道你已经完成了所有事情。</para>
            <warning>
              <para>你<emphasis>可以</emphasis>仅仅删除冲突的文件并且提交，但是<command>svn resolved</command>除了删除冲突文件，还修正了一些记录在工作拷贝管理区域的记录数据，所以我们推荐你使用这个命令。</para>
            </warning>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svn.c.revert">
          <indexterm>
            <primary>svn</primary>
            <secondary>子命令</secondary>
            <tertiary>revert</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svn revert</refname>
            <refpurpose>取消所有的本地编辑。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svn revert PATH...</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>恢复所有对文件和目录的修改，并且解决所有的冲突状态。<command>svn revert</command>不会只是恢复工作拷贝中一个项目的内容，也包括了对属性修改的恢复。最终，你可以使用它来取消所有已经做过的预定操作(例如，文件预定要添加或删除可以<quote>恢复</quote>)。</para>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>无</para>
          </refsection>
          <refsection>
            <info>
              <title>改变</title>
            </info>
            <para>工作拷贝2</para>
          </refsection>
          <refsection>
            <info>
              <title>访问版本库</title>
            </info>
            <para>否</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--targets FILENAME
--depth ARG
--quiet (-q)
--config-dir DIR
--changelist ARG
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>丢弃对一个文件的修改：</para>
            <screen>
$ svn revert foo.c
Reverted foo.c
</screen>
            <para>如果你希望恢复一整个目录的文件，可以使用<option>--depth=infinity</option>选项：</para>
            <screen>
$ svn revert --depth=infinity .
Reverted newdir/afile
Reverted foo.c
Reverted bar.txt
</screen>
            <para>最后，你可以取消预定的操作：</para>
            <screen>
$ svn add mistake.txt whoops
A         mistake.txt
A         whoops
A         whoops/oopsie.c

$ svn revert mistake.txt whoops
Reverted mistake.txt
Reverted whoops

$ svn status
?      mistake.txt
?      whoops
</screen>
            <warning>
              <para><command>svn revert</command>本身有固有的危险，因为它的目的是放弃数据—未提交的修改。一旦你选择了恢复，Subversion<emphasis>没有方法</emphasis>找回未提交的修改。</para>
              <para>如果你没有给<command>svn revert</command>提供了目标，它不会做任何事情—为了保护你不小心失去对工作拷贝的修改，<command>svn revert</command>需要你提供至少一个目标。</para>
            </warning>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svn.c.status">
          <indexterm>
            <primary>svn</primary>
            <secondary>子命令</secondary>
            <tertiary>status</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svn status</refname>
            <refpurpose>打印工作拷贝文件和目录的状态。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svn status [PATH...]</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>打印工作拷贝文件和目录的状态。如果没有参数，只会打印本地修改的项目(不会访问版本库)，使用<option>--show-updates</option>选项，会添加工作修订版本和服务器过期信息。使用<option>--verbose</option>会打印每个项目的完全修订版本信息，使用<option>--quiet</option>，会打印本地修改条目的总结信息。</para>
            <para>输出的前六列都是一个字符宽，每一列给出了工作拷贝项目的每一方面的信息。</para>
            <para>第一列指出一个项目的是添加、删除还是其它的修改。</para>
            <variablelist>
              <varlistentry>
                <term>
                  <literal>' '</literal>
                </term>
                <listitem>
                  <para>没有修改。</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                  <literal>'A'</literal>
                </term>
                <listitem>
                  <para>预定要添加的项目。</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                  <literal>'D'</literal>
                </term>
                <listitem>
                  <para>预定要删除的项目。</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                  <literal>'M'</literal>
                </term>
                <listitem>
                  <para>项目已经修改了。</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                  <literal>'R'</literal>
                </term>
                <listitem>
                  <para>项目在工作拷贝中已经被替换了。这意味着文件预定要删除，然后有一个同样名称的文件要在同一个位置替换它。</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                  <literal>'C'</literal>
                </term>
                <listitem>
                  <para>项目的内容(相对于属性)与更新得到的数据冲突了。</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                  <literal>'X'</literal>
                </term>
                <listitem>
                  <para>项目与外部定义相关。</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                  <literal>'I'</literal>
                </term>
                <listitem>
                  <para>项目被忽略(例如使用<literal>svn:ignore</literal>属性)。</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                  <literal>'?'</literal>
                </term>
                <listitem>
                  <para>项目不在版本控制之下。</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                  <literal>'!'</literal>
                </term>
                <listitem>
                  <para>项目已经丢失(例如，你使用<command>svn</command>移动或者删除了它)。这也说明了一个目录不是完整的(一个检出或更新中断)。</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                  <literal>'~'</literal>
                </term>
                <listitem>
                  <para>项目作为一种对象(文件、目录或链接)纳入版本控制，但是已经被另一种对象替代。</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <para>第二列告诉一个文件或目录的属性的状态。</para>
            <variablelist>
              <varlistentry>
                <term>
                  <literal>' '</literal>
                </term>
                <listitem>
                  <para>没有修改。</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                  <literal>'M'</literal>
                </term>
                <listitem>
                  <para>这个项目的属性已经修改。</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                  <literal>'C'</literal>
                </term>
                <listitem>
                  <para>这个项目的属性与从版本库得到的更新有冲突。</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <para>第三列只在工作拷贝锁定时才会出现。(见<xref linkend="svn.tour.cleanup"/>。)</para>
            <variablelist>
              <varlistentry>
                <term>
                  <literal>' '</literal>
                </term>
                <listitem>
                  <para>项目没有锁定。</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                  <literal>'L'</literal>
                </term>
                <listitem>
                  <para>项目已经锁定。</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <para>第四列只在预定包含历史添加的项目出现。</para>
            <variablelist>
              <varlistentry>
                <term>
                  <literal>' '</literal>
                </term>
                <listitem>
                  <para>没有历史预定要提交。</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                  <literal>'+'</literal>
                </term>
                <listitem>
                  <para>历史预定要伴随提交。</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <para>第五列只在项目跳转到相对于它的父目录时出现(见<xref linkend="svn.branchmerge.switchwc"/>)。</para>
            <variablelist>
              <varlistentry>
                <term>
                  <literal>' '</literal>
                </term>
                <listitem>
                  <para>项目是它的父目录的孩子。</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                  <literal>'S'</literal>
                </term>
                <listitem>
                  <para>项目已经转换。</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <para>第六列显示锁定信息。</para>
            <variablelist>
              <varlistentry>
                <term>
                  <literal>' '</literal>
                </term>
                <listitem>
                  <para>当使用<option>--show-updates</option>，文件没有锁定。如果<emphasis>不</emphasis>使用<option>--show-updates</option>，这意味着文件在工作拷贝被锁定。</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>K</term>
                <listitem>
                  <para>文件锁定在工作拷贝。</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>O</term>
                <listitem>
                  <para>文件被另一个用户或另一个工作拷贝锁定，只有在使用<option>--show-updates</option>时显示。</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>T</term>
                <listitem>
                  <para>文件锁定在工作拷贝，但是锁定被<quote>窃取</quote>而不可用。文件当前锁定在版本库，只有在使用<option>--show-updates</option>时显示。</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>B</term>
                <listitem>
                  <para>文件锁定在工作拷贝，但是锁定被<quote>破坏</quote>而不可用。文件当前锁定在版本库，只有在使用<option>--show-updates</option>时显示。</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <para>过期信息出现在第七列(只在使用<option>--show-updates</option>选项时出现)。</para>
            <variablelist>
              <varlistentry>
                <term>
                  <literal>' '</literal>
                </term>
                <listitem>
                  <para>这个项目在工作拷贝是最新的。</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                  <literal>'*'</literal>
                </term>
                <listitem>
                  <para>在服务器这个项目有了新的修订版本。</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <para>余下的字段是可变得宽度且使用空格分隔，如果使用<option>--show-updates</option>或<option>--verbose</option>选项，工作修订版本是下一个字段。</para>
            <para>如果传递<option>--verbose</option>选项，最后提交的修订版本和最后的提交作者会在后面显示。</para>
            <para>工作拷贝路径永远是最后一个字段，所以它可以包括空格。</para>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>使用<command>svnserve</command>通过<command>inetd</command></para>
          </refsection>
          <refsection>
            <info>
              <title>改变</title>
            </info>
            <para>无2</para>
          </refsection>
          <refsection>
            <info>
              <title>访问版本库</title>
            </info>
            <para>只有使用<option>--show-updates</option>时会访问</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--changelist ARG
--depth ARG
--ignore-externals
--incremental
--no-ignore
--quiet (-q)
--show-updates (-u)
--verbose (-v)
--xml
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>这是查看你在工作拷贝所做的修改的最简单的方法。</para>
            <screen>
$ svn status wc
 M     wc/bar.c
A  +   wc/qax.c
</screen>
            <para>如果你希望找出工作拷贝哪些文件是最新的，使用<option>--show-updates</option>选项(这不会对工作拷贝有任何修改)。这里你会看到<filename>wc/foo.c</filename>在上次更新后有了修改：</para>
            <screen>
$ svn status --show-updates wc
 M           965    wc/bar.c
       *     965    wc/foo.c
A  +         965    wc/qax.c
Status against revision:    981
</screen>
            <note>
              <para><option>--show-updates</option><emphasis>只会</emphasis>在过期的项目(如果你运行<command>svn update</command>，就会更新的项目)旁边安置一个星号。<option>--show-updates</option>不会导致状态列表反映项目的版本库版本(尽管你可以通过<option>--verbose</option>选项查看版本库的修订版本号)。</para>
            </note>
            <para>最后，是你能从status子命令得到的所有信息：</para>
            <screen>
$ svn status --show-updates --verbose wc
 M           965       938 sally        wc/bar.c
       *     965       922 harry        wc/foo.c
A  +         965       687 harry        wc/qax.c
             965       687 harry        wc/zig.c
Head revision:   981
</screen>
            <para>Lastly, you can get <command>svn status</command>
            output in XML format with the <option>--xml</option>
            option:</para>
            <screen>
$ svn status --xml wc
&lt;?xml version="1.0"?&gt;
&lt;status&gt;
&lt;target
   path="wc"&gt;
&lt;entry
   path="qax.c"&gt;
&lt;wc-status
   props="none"
   item="added"
   revision="0"&gt;
&lt;/wc-status&gt;
&lt;/entry&gt;
&lt;entry
   path="bar.c"&gt;
&lt;wc-status
   props="normal"
   item="modified"
   revision="965"&gt;
&lt;commit
   revision="965"&gt;
&lt;author&gt;sally&lt;/author&gt;
&lt;date&gt;2008-05-28T06:35:53.048870Z&lt;/date&gt;
&lt;/commit&gt;
&lt;/wc-status&gt;
&lt;/entry&gt;
&lt;/target&gt;
&lt;/status&gt;
</screen>
            <para>关于<command>svn status</command>的更多例子可以见<xref linkend="svn.tour.cycle.examine.status"/>。</para>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svn.c.switch">
          <indexterm>
            <primary>svn</primary>
            <secondary>子命令</secondary>
            <tertiary>switch</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svn switch</refname>
            <refpurpose>把工作拷贝更新到别的URL。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svn switch URL[@PEGREV] [PATH]</programlisting>
            <programlisting>switch --relocate FROM TO [PATH...]</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>这个子命令(没有<option>--relocate</option>选项)更新你的工作拷贝来反映新的URL—通常是一个与你的工作拷贝分享共同祖先的URL，尽管这不是必需的。这是Subversion移动工作拷贝到分支的方式。更深入的了解请见<xref linkend="svn.branchmerge.switchwc"/>。</para>
            <para>If <option>--force</option> is used, unversioned
            obstructing paths in the working copy do not automatically
            cause a failure if the switch attempts to add the same
            path.  If the obstructing path is the same type (file or
            directory) as the corresponding path in the repository, it
            becomes versioned but its contents are left untouched in
            the working copy.  This means that an obstructing
            directory's unversioned children may also obstruct and
            become versioned.  For files, any content differences
            between the obstruction and the repository are treated
            like a local modification to the working copy.  All
            properties from the repository are applied to the
            obstructing path.</para>
            <para>As with most subcommands, you can limit the scope of
            the switch operation to a particular tree depth using the
            <option>--depth</option> option.  Alternatively, you can
            use the <option>--set-depth</option> option to set a new
            <quote>sticky</quote> working copy depth on the switch
            target.  Currently, the depth of a working copy directory
            can only be increased (telescoped more deeply); you cannot
            make a directory more shallow.</para>
            <para><option>--relocate</option>选项导致<command>svn switch</command>做不同的事情：它更新你的工作拷贝指向到<emphasis>同一个</emphasis>版本库目录，但是不同的URL(通常因为管理员将版本库转移了服务器，或到了同一个服务器的另一个URL)。</para>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>
              <command>sw</command>
            </para>
          </refsection>
          <refsection>
            <info>
              <title>改变</title>
            </info>
            <para>工作拷贝2</para>
          </refsection>
          <refsection>
            <info>
              <title>访问版本库</title>
            </info>
            <para>是</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--accept ARG
--depth ARG
--diff3-cmd CMD
--force
--ignore-externals
--quiet (-q)
--relocate
--revision (-r) REV
--set-depth ARG
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>如果你目前所在目录<filename>vendors</filename>分支到<filename>vendors-with-fix</filename>，你希望转移到那个分支：</para>
            <screen>
$ svn switch http://svn.red-bean.com/repos/branches/vendors-with-fix .
U  myproj/foo.txt
U  myproj/bar.txt
U  myproj/baz.c
U  myproj/qux.c
Updated to revision 31.
</screen>
            <para>为了跳转回来，只需要提供最初取出工作拷贝的版本库URL：</para>
            <screen>
$ svn switch http://svn.red-bean.com/repos/trunk/vendors .
U  myproj/foo.txt
U  myproj/bar.txt
U  myproj/baz.c
U  myproj/qux.c
Updated to revision 31.
</screen>
            <tip>
              <para>如果你不希望跳转所有的工作拷贝，你可以只跳转一部分。</para>
            </tip>
            <para>有时候管理员会修改版本库的<quote>基本位置</quote>—换句话说，版本库的内容并不改变，但是访问根的主URL变了。举个例子，主机名变了、URL模式变了或者是URL中的任何一部分改变了。我们不选择重新检出一个工作拷贝，你可以使用<command>svn switch</command>来重写版本库所有URL的开头。如果使用带<option>--relocate</option>选项的<command>svn switch</command>来做这种替换，Subversion会访问版本库来验证重定位请求(当然是查看新URL的版本库)，然后重写元数据。此类switch操作不会修改文件内容—是一个只修改元数据的工作拷贝修改。</para>
            <screen>
$ svn checkout file:///var/svn/repos test
A  test/a
A  test/b
…

$ mv repos newlocation
$ cd test/

$ svn update
svn: Unable to open an ra_local session to URL
svn: Unable to open repository 'file:///var/svn/repos'

$ svn switch --relocate file:///var/svn/repos file:///tmp/newlocation .
$ svn update
At revision 3.
</screen>
            <warning>
              <para>小心使用<option>--relocate</option>选项，如果你输入了错误的选项，你会在工作拷贝创建无意义的URL，会导致整个工作区不可用并且难于修复。理解何时应该使用<option>--relocate</option>也是非常重要的，下面是一些规则：</para>
              <itemizedlist>
                <listitem>
                  <para>如果工作拷贝需要反映一个版本库的新目录，只需要使用<command>svn switch</command>。</para>
                </listitem>
                <listitem>
                  <para>如果你的工作拷贝还是反映相同的版本库目录，但是版本库本身的位置改变了，使用<command>svn switch --relocate</command>。</para>
                </listitem>
              </itemizedlist>
            </warning>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svn.c.unlock">
          <indexterm>
            <primary>svn</primary>
            <secondary>子命令</secondary>
            <tertiary>unlock</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svn unlock</refname>
            <refpurpose>解锁工作拷贝路径或URL。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svn unlock TARGET...</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>解锁每个<replaceable>TARGET</replaceable>。如果任何另一个用户锁定了<replaceable>TARGET</replaceable>，或者没有正确工作拷贝的锁定令牌，打印警告并继续解锁余下的<replaceable>TARGET</replaceable>。使用<option>--force</option>可以打破其它用户或工作拷贝的锁定。</para>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>无</para>
          </refsection>
          <refsection>
            <info>
              <title>改变</title>
            </info>
            <para>工作拷贝，版本库</para>
          </refsection>
          <refsection>
            <info>
              <title>访问版本库</title>
            </info>
            <para>是</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--force
--targets FILENAME
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>解锁工作拷贝中的两个文件：</para>
            <screen>
$ svn unlock tree.jpg house.jpg
'tree.jpg' unlocked.
'house.jpg' unlocked.
</screen>
            <para>解锁工作拷贝的一个被其他用户锁定的文件：</para>
            <screen>
$ svn unlock tree.jpg
svn: 'tree.jpg' is not locked in this working copy
$ svn unlock --force tree.jpg
'tree.jpg' unlocked.
</screen>
            <para>没有工作拷贝时解锁一个文件：</para>
            <screen>
$ svn unlock http://svn.red-bean.com/repos/test/tree.jpg
'tree.jpg unlocked.
</screen>
            <para>更多细节见<xref linkend="svn.advanced.locking"/>。</para>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svn.c.update">
          <indexterm>
            <primary>svn</primary>
            <secondary>子命令</secondary>
            <tertiary>update</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svn update</refname>
            <refpurpose>更新你的工作拷贝。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svn update [PATH...]</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para><command>svn update</command>会把版本库的修改带到工作拷贝，如果没有给定修订版本，它会把你的工作拷贝更新到<literal>HEAD</literal>修订版本，否则，它会把工作拷贝更新到你用<option>--revision</option>指定的修订版本。为了保持同步，<command>svn update</command>也会删除所有在工作拷贝发现的无效锁定(见<xref linkend="svn.tour.cleanup"/>)。</para>
            <para>对于每一个更新的项目开头都有一个表示所做动作的字符，这些字符有下面的意思：</para>
            <variablelist>
              <varlistentry>
                <term>
                  <literal>A</literal>
                </term>
                <listitem>
                  <para>添加</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                  <literal>B</literal>
                </term>
                <listitem>
                  <para>Broken lock (third column only)</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                  <literal>D</literal>
                </term>
                <listitem>
                  <para>删除</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                  <literal>U</literal>
                </term>
                <listitem>
                  <para>更新</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                  <literal>C</literal>
                </term>
                <listitem>
                  <para>冲突</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                  <literal>G</literal>
                </term>
                <listitem>
                  <para>合并</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                  <literal>E</literal>
                </term>
                <listitem>
                  <para>Existed</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <para>第一列的字符反映文件本身的更新，而第二列会反映文件属性的更新，锁定信息打印在第三列。</para>
            <para>As with most subcommands, you can limit the scope of
            the update operation to a particular tree depth using the
            <option>--depth</option> option.  Alternatively, you can
            use the <option>--set-depth</option> option to set a new
            <quote>sticky</quote> working copy depth on the update
            target.  Currently, the depth of a working copy directory
            can only be increased (telescoped more deeply); you cannot
            make a directory more shallow.</para>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>
              <command>up</command>
            </para>
          </refsection>
          <refsection>
            <info>
              <title>改变</title>
            </info>
            <para>工作拷贝2</para>
          </refsection>
          <refsection>
            <info>
              <title>访问版本库</title>
            </info>
            <para>是</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--accept ARG
--changelist
--depth ARG
--diff3-cmd CMD
--editor-cmd ARG
--force
--ignore-externals
--quiet (-q)
--revision (-r) REV
--set-depth ARG
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>获取你上次更新之后版本库的修改：</para>
            <screen>
$ svn update
A  newdir/toggle.c
A  newdir/disclose.c
A  newdir/launch.c
D  newdir/README
Updated to revision 32.
</screen>
            <para>你也可以将工作拷贝更新到旧的修订版本(Subversion没有CVS的<quote>sticky</quote>文件的概念；见<xref linkend="svn.forcvs"/>)：</para>
            <screen>
$ svn update -r30
A  newdir/README
D  newdir/toggle.c
D  newdir/disclose.c
D  newdir/launch.c
U  foo.c
Updated to revision 30.
</screen>
            <tip>
              <para>如果你希望检查单个文件的旧的修订版本，你会希望使用<command>svn cat</command>。</para>
            </tip>
          </refsection>
        </refentry>
      </section>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.ref.svnadmin">
      <info>
        <title>svnadmin</title>
      </info>
      <para><command>svnadmin</command>是一个用来监控和修改Subversion版本库的管理工具，详情请见<xref linkend="svn.reposadmin.maint.tk.svnadmin"/>。</para>
      <para>因为<command>svnadmin</command>直接访问版本库(因此只可以在存放版本库的机器上使用)，它通过路径访问版本库，而不是URL。</para>
      <!-- =============================================================== -->
      <section xml:id="svn.ref.svnadmin.sw">
        <info>
          <title><command>svnadmin</command> 选项</title>
        </info>
        <para>这个命令同<command>svn copy</command>加一个<command>svn delete</command>等同。</para>
        <variablelist>
          <varlistentry>
            <term>
              <option>--bdb-log-keep</option>
            </term>
            <listitem>
              <para>(Berkeley DB特定)关闭数据库日志文件的自动删除，保留这些文件可以帮助你在灾难性版本库故障时更加便利。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--bdb-txn-nosync</option>
            </term>
            <listitem>
              <para>(Berkeley DB特定)在提交数据库事务时关闭fsync。可以在<command>svnadmin create</command>命令创建Berkeley DB后端时开启<literal>DB_TXN_NOSYNC</literal>(可以改进速度，但是有相关的风险)。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--bypass-hooks</option>
            </term>
            <listitem>
              <para>绕过版本库钩子系统。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--clean-logs</option>
            </term>
            <listitem>
              <para>删除不使用的Berkeley DB日志。</para>
            </listitem>
          </varlistentry>
          <!-- TODO config-dir?  Only 'svnadmin create' accepts it, and -->
          <!-- the underlying logic doesn't even use it.                -->
          <varlistentry>
            <term>
              <option>--force-uuid</option>
            </term>
            <listitem>
              <para>缺省情况下，当版本库加载已经包含修订版本的数据时<command>svnadmin</command>会忽略流中的<literal>UUID</literal>，这个选项会导致版本库的<literal>UUID</literal>设置为流的<literal>UUID</literal>。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--ignore-uuid</option>
            </term>
            <listitem>
              <para>缺省情况下，当加载空版本库时，<command>svnadmin</command>会使用来自流中的<literal>UUID</literal>，这个选项会导致忽略UUID(如果你的配置文件已经设置了<option>--force-uuid</option>，将会用于将其覆盖)。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--incremental</option>
            </term>
            <listitem>
              <para>导出一个修订版本针对前一个修订版本的区别，而不是通常的完全结果。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--parent-dir <replaceable>DIR</replaceable></option>
            </term>
            <listitem>
              <para>当加载一个转储文件时，根路径为<replaceable>DIR</replaceable>而不是<filename>/</filename>。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--pre-1.4-compatible</option>
            </term>
            <listitem>
              <para>When creating a new repository, use a format that is
            compatible with versions of Subversion earlier than
            Subversion 1.4.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--pre-1.5-compatible</option>
            </term>
            <listitem>
              <para>When creating a new repository, use a format that is
            compatible with versions of Subversion earlier than
            Subversion 1.5.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><option>--revision</option> (<option>-r</option>) <replaceable>ARG</replaceable></term>
            <listitem>
              <para>指定一个操作的修订版本。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--quiet</option>
            </term>
            <listitem>
              <para>不显示通常的过程—只显示错误。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--use-post-commit-hook</option>
            </term>
            <listitem>
              <para>当导入使用一个转储文件时，在每次新的修订版本产生时运行版本库post-commit钩子。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--use-post-revprop-change-hook</option>
            </term>
            <listitem>
              <para>当修改一个修订版本属性时，在每次修改修订版本产生后运行版本库post-revprop-change钩子。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--use-pre-commit-hook</option>
            </term>
            <listitem>
              <para>当加载一个转储文件时，每次新加修订版本之前运行版本库的pre-commit钩子。如果钩子失败，终止提交并中断加载进程。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--use-pre-revprop-change-hook</option>
            </term>
            <listitem>
              <para>当修改一个修订版本属性，在修改修订版本之前运行版本库的pre-revprop-change钩子，如果钩子失败，中断修改并终止。</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.ref.svnadmin.c">
        <info>
          <title>svnadmin 子命令</title>
        </info>
        <para>有许多不同方法运行<command>svnserve</command>：</para>
        <refentry xml:id="svn.ref.svnadmin.c.crashtest">
          <indexterm>
            <primary>svnadmin</primary>
            <secondary>子命令</secondary>
            <tertiary>crashtest</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svnadmin crashtest</refname>
            <refpurpose>Simulate a process that crashes.</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svnadmin crashtest REPOS_PATH</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>Open the repository at <replaceable>REPOS_PATH</replaceable>, then abort, thus
              simulating a process that crashes while holding an open
              repository handle.  This is used for testing automatic
              repository recovery (a new feature in Berkeley DB 4.4).
              It's unlikely that you'll need to run this
              command.</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <para>无</para>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <screen>
$ svnadmin crashtest /var/svn/repos
Aborted
</screen>
            <para>Exciting, isn't it?</para>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svnadmin.c.create">
          <indexterm>
            <primary>svnadmin</primary>
            <secondary>子命令</secondary>
            <tertiary>create</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svnadmin create</refname>
            <refpurpose>创建一个新的空的版本库。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svnadmin create REPOS_PATH</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>在提供的路径上创建一个新的空的版本库，如果提供的目录不存在，它会为你创建。<footnote><para>记住<command>svnadmin</command>只工作在本地<emphasis>路径</emphasis>，而不是<emphasis>URL</emphasis>。</para></footnote>对于Subversion 1.2，<command>svnadmin</command>缺省使用<literal>fsfs</literal>文件系统后端创建版本库。</para>
            <para>While <command>svnadmin create</command> will create
              the base directory for a new repository, it will not
              create intermediate directories.  For example, if you
              have an empty directory named
              <filename>/var/svn</filename>, creating
              <filename>/var/svn/repos</filename> will work, while
              attempting to create
              <filename>/var/svn/subdirectory/repos</filename> will
              fail with an error.</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--bdb-log-keep
--bdb-txn-nosync
--config-dir DIR
--fs-type TYPE
--pre-1.4-compatible
--pre-1.5-compatible
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>创建一个版本库就是这样简单：</para>
            <screen>
$ svnadmin create /var/svn/repos
</screen>
            <para>在Subversion 1.0，一定会创建一个Berkeley DB版本库，在Subversion 1.1，Berkeley DB版本库是缺省类型，但是一个FSFS版本库也是可以创建，使用<option>--fs-type</option>选项：</para>
            <screen>
$ svnadmin create /var/svn/repos --fs-type fsfs
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svnadmin.c.deltify">
          <indexterm>
            <primary>svnadmin</primary>
            <secondary>子命令</secondary>
            <tertiary>deltify</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svnadmin deltify</refname>
            <refpurpose>修订版本范围的路径的增量变化。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svnadmin deltify [-r LOWER[:UPPER]] REPOS_PATH</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para><command>svnadmin deltify</command>因为历史原因而存在，这个命令已经废弃，不再需要。</para>
            <para>它开始于当Subversion提供了管理员控制版本库压缩策略的能力，结果是复杂工作得到了<emphasis>非常</emphasis>小的收益，所以这个<quote>特性</quote>被废弃了。</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--revision (-r) REV
--show-ids
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svnadmin.c.dump">
          <indexterm>
            <primary>svnadmin</primary>
            <secondary>子命令</secondary>
            <tertiary>dump</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svnadmin dump</refname>
            <refpurpose>将文件系统的内容转储到标准输出。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svnadmin dump REPOS_PATH [-r LOWER[:UPPER]] [--incremental]</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>使用<quote>dumpfile</quote>可移植格式将文件系统的内容转储到标准输出，将反馈发送到标准错误，导出的修订版本从<replaceable>LOWER</replaceable>到<replaceable>UPPER</replaceable>。如果没有提供修订版本，会导出所有的修订版本树，如果只提供<replaceable>LOWER</replaceable>，导出一个修订版本树，通常的用法见<xref linkend="svn.reposadmin.maint.migrate"/>。</para>
            <para>缺省情况下，Subversion的转储流包含了一个包括所有文件和目录的单独修订版本(请求的修订版本范围的第一个)，后面是其它的只包含本修订所修改的文件和目录的修订版本(请求范围的其它版本)。对于修改的文件，转储文件包括所有的内容和属性，对于目录，包括所有的属性。</para>
            <para>有一对有用的选项可以改变转储文件产生的方式，第一个是<option>--incremental</option>，使得第一个修订版本只显示其修改的文件和目录，而不是战士为添加整个目录树，就同转储文件中的其它修订版本一样。这对产生一个准备导入到已经有数据的版本库时非常有用。</para>
            <para>第二个有用的选项是<option>--deltas</option>，这个选项导致<command>svnadmin dump</command>不会保留修改文件的所有内容，而只是记录修改的部分。这样减少(有些情况下是非常大的)了<command>svnadmin dump</command>产生的转储文件的大小。然而，也有缺点—增量转储文件需要更多的CPU来创建，也不可以用<command>svndumpfilter</command>操作，也不如非增量文件容易被如<command>gzip</command>和<command>bzip2</command>等第三方工具压缩。</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--revision (-r) REV
--incremental
--quiet (-q)
--deltas
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>转储整个版本库：</para>
            <screen>
$ svnadmin dump /var/svn/repos &gt; repos-dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
* Dumped revision 3.
…
$
</screen>
            <para>从版本库增量转储一个单独的事务：</para>
            <screen>
$ svnadmin verify /var/svn/repos/ 
* Verified revision 1729.
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svnadmin.c.help">
          <indexterm>
            <primary>svnadmin</primary>
            <secondary>子命令</secondary>
            <tertiary>help</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svnadmin help</refname>
            <refpurpose>求助！</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svnadmin help [SUBCOMMAND...]</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>当你困于一个没有网络连接和本书的沙漠岛屿时，这个子命令非常有用。</para>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>使用<command>svnserve</command>通过<command>inetd</command></para>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svnadmin.c.hotcopy">
          <indexterm>
            <primary>svnadmin</primary>
            <secondary>子命令</secondary>
            <tertiary>hotcopy</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svnadmin hotcopy</refname>
            <refpurpose>制作一个版本库的热备份。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svnadmin hotcopy REPOS_PATH NEW_REPOS_PATH</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>这个子命令会制作一个版本库的完全<quote>热</quote>拷贝，包括所有的钩子，配置文件，当然还有数据库文件。如果你传递<option>--clean-logs</option>选项，<command>svnadmin</command>会执行热拷贝操作，然后删除不用的Berkeley DB日志文件。你可以在任何时候运行这个命令得到一个版本库的安全拷贝，不管其它进程是否使用这个版本库。</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--clean-logs
</screen>
            <warning>
              <para>就像<xref linkend="svn.reposadmin.basics.backends.bdb"/>描述的，热拷贝的Berkeley DB版本库<emphasis>不能</emphasis>跨操作系统移植，也不能在不同<quote>字节续</quote>的主机上工作。</para>
            </warning>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svnadmin.c.list-dblogs">
          <indexterm>
            <primary>svnadmin</primary>
            <secondary>子命令</secondary>
            <tertiary>list-dblogs</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svnadmin list-dblogs</refname>
            <refpurpose>询问Berkeley DB在给定的Subversion版本库有哪些日志文件存在(只有在版本库使用<literal>bdb</literal>作为后端时使用)。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svnadmin list-dblogs REPOS_PATH</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>Berkeley DB创建了记录所有版本库修改的日志，允许我们在面对大灾难时恢复。除非你开启了<literal>DB_LOG_AUTOREMOVE</literal>，否则日志文件会累积，尽管大多数是不再使用可以从磁盘删除得到空间。详情见<xref linkend="svn.reposadmin.maint.diskspace"/>。</para>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svnadmin.c.list-unused-dblogs">
          <indexterm>
            <primary>svnadmin</primary>
            <secondary>子命令</secondary>
            <tertiary>list-unused-dblogs</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svnadmin list-unused-dblogs</refname>
            <refpurpose>询问Berkeley DB哪些日志文件可以安全的删除(只有在版本库使用<literal>bdb</literal>作为后端时使用)。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svnadmin list-unused-dblogs REPOS_PATH</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>Berkeley DB创建了记录所有版本库修改的日志，允许我们在面对大灾难时恢复。除非你开启了<literal>DB_LOG_AUTOREMOVE</literal>，否则日志文件会累积，尽管大多数是不再使用可以从磁盘删除得到空间。详情见<xref linkend="svn.reposadmin.maint.diskspace"/>。</para>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>从版本库删除所有的未用日志文件：</para>
            <screen>
$ svnadmin list-unused-dblogs /var/svn/repos
/var/svn/repos/log.0000000031
/var/svn/repos/log.0000000032
/var/svn/repos/log.0000000033

$ svnadmin list-unused-dblogs /var/svn/repos | xargs rm
## disk space reclaimed!
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svnadmin.c.load">
          <indexterm>
            <primary>svnadmin</primary>
            <secondary>子命令</secondary>
            <tertiary>load</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svnadmin load</refname>
            <refpurpose>打印版本库的<filename>svnadmin</filename>。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svnadmin load REPOS_PATH</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>从标准输入读取格式化流<quote>dumpfile</quote>，提交新修订版本到版本库的文件系统，在标准输出返回进度。</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--quiet (-q)
--ignore-uuid
--force-uuid
--use-pre-commit-hook
--use-post-commit-hook
--parent-dir
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>这里显示了加载一个备份文件到版本库(当然，使用<command>svnadmin dump</command>)：</para>
            <screen>
$ svnadmin load /var/svn/restored &lt; repos-backup
&lt;&lt;&lt; Started new txn, based on original revision 1
     * adding path : test ... done.
     * adding path : test/a ... done.
…
</screen>
            <para>或者你希望加载到一个子目录：</para>
            <screen>
$ svnadmin load --parent-dir new/subdir/for/project /var/svn/restored &lt; repos-backup
&lt;&lt;&lt; Started new txn, based on original revision 1
     * adding path : test ... done.
     * adding path : test/a ... done.
…
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svnadmin.c.lslocks">
          <indexterm>
            <primary>svnadmin</primary>
            <secondary>子命令</secondary>
            <tertiary>lslocks</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svnadmin lslocks</refname>
            <refpurpose>打印所有锁定的描述。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svnlook lock REPOS_PATH PATH_IN_REPOS</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>打印<replaceable>PATH_IN_REPOS</replaceable>锁定的所有信息，如果<replaceable>PATH_IN_REPOS</replaceable>没有锁定，则不打印任何内容。</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <para>无</para>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>显示了版本库<filename>/var/svn/repos</filename>中一个锁定的文件：</para>
            <screen>
$ svnadmin lslocks /var/svn/repos
Path: /tree.jpg
UUID Token: opaquelocktoken:ab00ddf0-6afb-0310-9cd0-dda813329753
Owner: harry
Created: 2005-07-08 17:27:36 -0500 (Fri, 08 Jul 2005)
Expires: 
Comment (1 line):
Rework the uppermost branches on the bald cypress in the foreground.
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svnadmin.c.lstxns">
          <indexterm>
            <primary>svnadmin</primary>
            <secondary>子命令</secondary>
            <tertiary>lstxns</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svnadmin lstxns</refname>
            <refpurpose>打印所有未提交的事物名称。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svnadmin lstxns REPOS_PATH</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>打印所有未提交的事物名称。关于未提交事物是怎样创建和如何使用的信息见<xref linkend="svn.reposadmin.maint.diskspace.deadtxns"/>。</para>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>列出版本库所有突出的事物。</para>
            <screen>
$ svnadmin lstxns /var/svn/repos/ 
1w
1x
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svnadmin.c.recover">
          <indexterm>
            <primary>svnadmin</primary>
            <secondary>子命令</secondary>
            <tertiary>recover</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svnadmin recover</refname>
            <refpurpose>将版本库数据库恢复到稳定状态(只有在版本库使用<literal>bdb</literal>作为后端时使用)，此外，如果<filename>repos/conf/passwd</filename>不存在，它会创建一个默认的密码文件。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svnadmin recover REPOS_PATH</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>在你得到的错误说明你需要恢复版本库时运行这个命令。</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--wait
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>恢复挂起的版本库：</para>
            <screen>
$ svnadmin recover /var/svn/repos/ 
Repository lock acquired.
Please wait; recovering the repository may take some time...

Recovery completed.
The latest repos revision is 34.
</screen>
            <para>恢复数据库需要一个版本库的独占锁(这是一个<quote>数据库锁</quote>；见<xref linkend="svn.advanced.locking.meanings"/>)，如果另一个进程访问版本库，<command>svnadmin recover</command>会出错：</para>
            <screen>
$ svnadmin recover /var/svn/repos
svn: Failed to get exclusive repository access; perhaps another process
such as httpd, svnserve or svn has it open?

$
</screen>
            <para><option>--wait</option>选项可以导致<command>svnadmin recover</command>一直等待其它进程断开连接：</para>
            <screen>
$ svnadmin recover /var/svn/repos --wait
Waiting on repository lock; perhaps another process has it open?

### time goes by…

Repository lock acquired.
Please wait; recovering the repository may take some time...

Recovery completed.
The latest repos revision is 34.
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svnadmin.c.rmlocks">
          <indexterm>
            <primary>svnadmin</primary>
            <secondary>子命令</secondary>
            <tertiary>rmlocks</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svnadmin rmlocks</refname>
            <refpurpose>无条件的删除版本库的一个或多个锁定。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svnadmin rmlocks REPOS_PATH LOCKED_PATH...</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>从<replaceable>LOCKED_PATH</replaceable>删除没个锁定。</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <para>无</para>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>这删除了版本库<filename>/var/svn/repos</filename>里<filename>tree.jpg</filename>和<filename>house.jpg</filename>文件上的锁定：</para>
            <screen>
$ svnadmin rmlocks /var/svn/repos tree.jpg house.jpg
Removed lock on '/tree.jpg.
Removed lock on '/house.jpg.
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svnadmin.c.rmtxns">
          <indexterm>
            <primary>svnadmin</primary>
            <secondary>子命令</secondary>
            <tertiary>rmtxns</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svnadmin rmtxns</refname>
            <refpurpose>从版本库删除事物。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svnadmin rmtxns REPOS_PATH TXN_NAME...</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>删除版本库的事物，更多细节在<xref linkend="svn.reposadmin.maint.diskspace.deadtxns"/>。</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--quiet (-q)
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>删除命名的事物：</para>
            <screen>
$ svnadmin rmtxns /var/svn/repos/ 1w 1x
</screen>
            <para>很幸运，<command>lstxns</command>的输出作为<command>rmtxns</command>输入工作良好：</para>
            <screen>
$ svnadmin rmtxns /var/svn/repos/  `svnadmin lstxns /var/svn/repos/`
</screen>
            <para>从版本库删除所有未提交的事务。</para>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svnadmin.c.setlog">
          <indexterm>
            <primary>svnadmin</primary>
            <secondary>子命令</secondary>
            <tertiary>setlog</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svnadmin setlog</refname>
            <refpurpose>设置某个修订版本的日志信息。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svnadmin setlog REPOS_PATH -r REVISION FILE</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>设置修订版本<replaceable>REVISION</replaceable>的日志信息为<replaceable>FILE</replaceable>的内容。</para>
            <para>这与使用<command>svn propset --revprop</command>设置某一修订版本的<literal>svn:log</literal>属性效果一样，除了你也可以使用<option>--bypass-hooks</option>选项绕过的所有pre-或post-commit的钩子脚本，这在pre-revprop-change钩子脚本中禁止修改修订版本属性时非常有用。</para>
            <warning>
              <para>修订版本属性不在版本控制之下的，所以这个命令会永久覆盖前一个日志信息。</para>
            </warning>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--revision (-r) REV
--show-ids
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>设置修订版本19的日志信息为文件<filename>msg</filename>的内容：</para>
            <screen>
$ svnadmin setlog /var/svn/repos/ -r 19 msg
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svnadmin.c.setrevprop">
          <indexterm>
            <primary>svnadmin</primary>
            <secondary>子命令</secondary>
            <tertiary>setrevprop</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svnadmin setrevprop</refname>
            <refpurpose>设置某个修订版本的属性名。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svnadmin setrevprop REPOS_PATH -r REVISION NAME FILE</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>Set the property <replaceable>NAME</replaceable> on
              revision <replaceable>REVISION</replaceable> to the
              contents of <replaceable>FILE</replaceable>. Use
              <option>--use-pre-revprop-change-hook</option>
              or <option>--use-post-revprop-change-hook</option> to
              trigger the revision property-related hooks (e.g., if
              you want an email notification sent from your <literal>post-revprop-change-hook</literal>).</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--revision (-r) ARG
--use-post-revprop-change-hook
--use-pre-revprop-change-hook
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>设置修订版本19的日志信息为文件<filename>msg</filename>的内容：</para>
            <screen>
$svnadmin setrevprop /var/svn/repos -r 0 repository-photo sandwich.png
</screen>
            <para>As you can see, <command>svnadmin setrevprop</command>
            has no output upon success.</para>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svnadmin.c.setuuid">
          <indexterm>
            <primary>svnadmin</primary>
            <secondary>子命令</secondary>
            <tertiary>setuuid</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svnadmin setuuid</refname>
            <refpurpose>重置版本库的UUID。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svnadmin setuuid REPOS_PATH [NEW_UUID]</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>Reset the repository UUID for the repository located
              at <replaceable>REPOS_PATH</replaceable>.
              If <replaceable>NEW_UUID</replaceable> is provided, use
              that as the new repository UUID; otherwise, generate a
              brand-new UUID for the repository.</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <para>无</para>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>If you've <command>svnsync</command>ed <filename>/var/svn/repos</filename>
            to <filename>/var/svn/repos-new</filename> and intend to use <filename>repos-new</filename> as your
            canonical repository, you may want to change the UUID for
            <filename>repos-new</filename> to the UUID of <filename>repos</filename> so that your users don't
            have to check out a new working copy to accommodate the
            change:</para>
            <screen>
$ svnadmin setuuid /var/svn/repos-new 2109a8dd-854f-0410-ad31-d604008985ab
</screen>
            <para>As you can see, <command>svnadmin setuuid</command>
            has no output upon success.</para>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svnadmin.c.upgrade">
          <indexterm>
            <primary>svnadmin</primary>
            <secondary>子命令</secondary>
            <tertiary>upgrade</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svnadmin upgrade</refname>
            <refpurpose>Upgrade a repository to the latest supported
            schema version.</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svnadmin upgrade REPOS_PATH</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>Upgrade the repository located
              at <replaceable>REPOS_PATH</replaceable> to the latest
              supported schema version.</para>
            <para>This functionality is provided as a convenience for
              repository administrators who wish to make use of new
              Subversion functionality without having to undertake a
              potentially costly full repository dump and load
              operation.  As such, the upgrade performs only the
              minimum amount of work needed to accomplish this while
              still maintaining the integrity of the repository.
              While a dump and subsequent load guarantee the most
              optimized repository state, <command>svnadmin
              upgrade</command> does not.</para>
            <warning>
              <para>You should <emphasis>always</emphasis> back up your
                repository before upgrading.</para>
            </warning>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <para>无</para>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>升级路径<filename>/var/repos/svn</filename>的版本库</para>
            <screen>
$ svnadmin upgrade /var/repos/svn
Repository lock acquired.
Please wait; upgrading the repository may take some time...

Upgrade completed.
</screen>
          </refsection>
        </refentry>
        <!-- this could use a lot more explanation.  When should I use
      it?  What do I do if it fails? -->
        <refentry xml:id="svn.ref.svnadmin.c.verify">
          <indexterm>
            <primary>svnadmin</primary>
            <secondary>子命令</secondary>
            <tertiary>verify</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svnadmin verify</refname>
            <refpurpose>验证版本库保存的数据。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svnadmin verify REPOS_PATH</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>如果你希望验证版本库的完整性可以运行这个命令，这样会遍历版本库的所有的修订版本，导出修订版本并丢弃输出—有规律的执行这个命令来防止磁盘失败会是一个好方法，如果这个命令失败了—这是发生问题的第一个征兆—这表明你的版本库至少有一个损坏的修订版本，你必须从备份恢复损坏的修订版本(你需要备份，你没有吗？)。</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--quiet (-q)
--revision (-r) ARG
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>检验挂起的版本库：</para>
            <screen>
$ svnadmin verify /var/svn/repos/ 
* Verified revision 1729.
</screen>
          </refsection>
        </refentry>
      </section>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.ref.svnlook">
      <info>
        <title>svnlook</title>
      </info>
      <para><command>svnlook</command>是检验Subversion版本库不同方面的命令行工具，它不会对版本库有任何修改—它只是用来<quote>看</quote>—<command>svnlook</command>通常被版本库钩子使用，但是版本库管理也会发现它在诊断目的上也非常有用。</para>
      <para>因为<command>svnlook</command>通过直接版本库访问(因此只可以在保存版本库的机器上工作)工作，所以他通过版本库的路径访问，而不是URL。</para>
      <para>如果没有指定修订版本或事物，<command>svnlook</command>缺省的是版本库最年轻的(最新的)修订版本。</para>
      <!-- =============================================================== -->
      <section xml:id="svn.ref.svnlook.sw">
        <info>
          <title>svnlook 选项</title>
        </info>
        <para><command>svnlook</command>的选项是全局的，就像<command>svn</command>和<command>svnadmin</command>；然而，大多数选项只会应用到一个子命令，因为<command>svnlook</command>的功能是(有意的)限制在一定范围的。</para>
        <variablelist>
          <varlistentry>
            <term>
              <option>--copy-info</option>
            </term>
            <listitem>
              <para>Causes <command>svnlook changed</command> to show
              detailed copy source information.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--no-diff-deleted</option>
            </term>
            <listitem>
              <para>防止<command>svnlook diff</command>打印删除文件的区别，缺省的行为方式是当一个文件在一次事物/修订版本中删除后，得到的结果与保留这个文件的内容变成空相同。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--no-diff-added</option>
            </term>
            <listitem>
              <para>防止<command>svnlook diff</command>打印添加文件的区别。缺省的行为方式是，当添加一个文件时，<command>svn diff</command>打印的信息和比较一个空白文件相同。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><option>--revision</option> (<option>-r</option>)</term>
            <listitem>
              <para>指定要进行检查的特定修订版本。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--revprop</option>
            </term>
            <listitem>
              <para>操作针对修订版本属性，而不是Subversion文件或目录的属性。这个选项需要你传递<option>--revision</option>(<option>-r</option>)参数。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><option>--transaction</option> (<option>-t</option>)</term>
            <listitem>
              <para>指定一个希望检查的特定事物ID。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--show-ids</option>
            </term>
            <listitem>
              <para>显示文件系统树中每条路径的文件系统节点修订版本ID。</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.ref.svnlook.c">
        <info>
          <title>svnlook 子命令</title>
        </info>
        <para>有许多不同方法运行<command>svnserve</command>：</para>
        <refentry xml:id="svn.ref.svnlook.c.author">
          <indexterm>
            <primary>svnlook</primary>
            <secondary>子命令</secondary>
            <tertiary>author</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svnlook author</refname>
            <refpurpose>打印作者。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svnlook author REPOS_PATH</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>打印版本库一个修订版本或者事物的作者。</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--revision (-r) REV
--transaction (-t)
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para><command>svnlook author</command>垂手可得，但是并不令人激动：</para>
            <screen>
$ svnlook author -r 40 /var/svn/repos 
sally
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svnlook.c.cat">
          <indexterm>
            <primary>svnlook</primary>
            <secondary>子命令</secondary>
            <tertiary>cat</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svnlook cat</refname>
            <refpurpose>打印一个文件的内容。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svnlook cat REPOS_PATH PATH_IN_REPOS</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>打印一个文件的内容。</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--revision (-r) REV
--transaction (-t)
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>这会显示事物<literal>ax8</literal>中一个文件的内容，位于<filename>/trunk/README</filename>：</para>
            <screen>
$ svnlook cat -t ax8 /var/svn/repos /trunk/README

               Subversion, a version control system.
               =====================================

$LastChangedDate: 2003-07-17 10:45:25 -0500 (Thu, 17 Jul 2003) $

Contents:

     I. A FEW POINTERS
    II. DOCUMENTATION
   III. PARTICIPATING IN THE SUBVERSION COMMUNITY
…
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svnlook.c.changed">
          <indexterm>
            <primary>svnlook</primary>
            <secondary>子命令</secondary>
            <tertiary>changed</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svnlook changed</refname>
            <refpurpose>打印修改的路径。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svnlook changed REPOS_PATH</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>打印在特定修订版本或事物修改的路径，也是在前两列使用<quote>svn update样式的</quote>状态字符：</para>
            <variablelist>
              <varlistentry>
                <term>
                  <literal>'A '</literal>
                </term>
                <listitem>
                  <para>条目添加到版本库</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                  <literal>'D '</literal>
                </term>
                <listitem>
                  <para>条目从版本库删除</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                  <literal>'U '</literal>
                </term>
                <listitem>
                  <para>文件内容改变了</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                  <literal>'U '</literal>
                </term>
                <listitem>
                  <para>条目属性改变了；注意开头的空格。</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                  <literal>'UU'</literal>
                </term>
                <listitem>
                  <para>文件内容和属性修改了</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <para>文件和目录可以区分，目录路径后面会显示字符<quote><literal>/</literal></quote>。</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--revision (-r) REV
--transaction (-t)
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>这里显示了在测试版本库中修订版本39改变的文件和目录，注意修改的第一个项目是一个目录，证据就是结尾的<literal>/</literal>：</para>
            <screen>
$ svnlook changed -r 39 /var/svn/repos
A   trunk/vendors/deli/
A   trunk/vendors/deli/chips.txt
A   trunk/vendors/deli/sandwich.txt
A   trunk/vendors/deli/pickle.txt
U   trunk/vendors/baker/bagel.txt
 U  trunk/vendors/baker/croissant.txt
UU  trunk/vendors/baker/pretzel.txt
D   trunk/vendors/baker/baguette.txt
</screen>
            <para>如下是显示文件重命名修订版本的例子：</para>
            <screen>
$ svnlook changed -r 64 /var/svn/repos
A   trunk/vendors/baker/toast.txt
D   trunk/vendors/baker/bread.txt
</screen>
            <para>Unfortunately, nothing in the preceding output reveals
            the connection between the deleted and added files.  Use
            the <option>--copy-info</option> option to make this
            relationship more apparent:</para>
            <screen>
$ svnlook changed -r 64 /var/svn/repos
A   trunk/vendors/baker/toast.txt
D   trunk/vendors/baker/bread.txt
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svnlook.c.date">
          <indexterm>
            <primary>svnlook</primary>
            <secondary>子命令</secondary>
            <tertiary>date</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svnlook date</refname>
            <refpurpose>打印时间戳。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svnlook date REPOS_PATH</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>打印版本库一个修订版本或事物的时间戳。</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--revision (-r) REV
--transaction (-t)
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>显示测试版本库修订版本40的日期：</para>
            <screen>
$ svnlook date -r 40 /var/svn/repos/
2003-02-22 17:44:49 -0600 (Sat, 22 Feb 2003)
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svnlook.c.diff">
          <indexterm>
            <primary>svnlook</primary>
            <secondary>子命令</secondary>
            <tertiary>diff</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svnlook diff</refname>
            <refpurpose>打印修改的文件和属性的区别。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svnlook diff REPOS_PATH</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>打印版本库中GNU样式的文件和属性修改区别。</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--diff-copy-from
--no-diff-added
--no-diff-deleted
--revision (-r) REV
--transaction (-t) TXN
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>这显示了一个新添加的(空的)文件，一个删除的文件和一个拷贝的文件：</para>
            <screen>
$ svnlook diff -r 40 /var/svn/repos/
Copied: egg.txt (from rev 39, trunk/vendors/deli/pickle.txt)

Added: trunk/vendors/deli/soda.txt
==============================================================================

Modified: trunk/vendors/deli/sandwich.txt
==============================================================================
--- trunk/vendors/deli/sandwich.txt	(original)
+++ trunk/vendors/deli/sandwich.txt	2003-02-22 17:45:04.000000000 -0600
@@ -0,0 +1 @@
+Don't forget the mayo!

Modified: trunk/vendors/deli/logo.jpg
==============================================================================
(Binary files differ)

Deleted: trunk/vendors/deli/chips.txt
==============================================================================

Deleted: trunk/vendors/deli/pickle.txt
==============================================================================
</screen>
            <para>如果一个文件有非文本的<literal>svn:mime-type</literal>属性，区别不会明确显示。</para>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svnlook.c.dirs-changed">
          <indexterm>
            <primary>svnlook</primary>
            <secondary>子命令</secondary>
            <tertiary>dirs-changed</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svnlook dirs-changed</refname>
            <refpurpose>打印本身修改的目录。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svnlook dirs-changed REPOS_PATH</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>打印本身修改(属性编辑)或子文件修改的目录。</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--revision (-r) REV
--transaction (-t)
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>这显示了在我们的实例版本库中在修订版本40修改的目录：</para>
            <screen>
$ svnlook dirs-changed -r 40 /var/svn/repos
trunk/vendors/deli/
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svnlook.c.help">
          <indexterm>
            <primary>svnlook</primary>
            <secondary>子命令</secondary>
            <tertiary>help</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svnlook help</refname>
            <refpurpose>求助！</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>也可以是svnlook -h和svnlook -?。</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>显示<command>svnlook</command>的帮助信息，这个命令如同<command>svn help</command>的兄弟，也是你的朋友，即使你从不调用它，并且忘掉了邀请它加入你的上一次聚会。</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <para>无</para>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>使用<command>svnserve</command>通过<command>inetd</command></para>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svnlook.c.history">
          <indexterm>
            <primary>svnlook</primary>
            <secondary>子命令</secondary>
            <tertiary>history</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svnlook history</refname>
            <refpurpose>打印版本库(如果没有路径，则是根目录)某一个路径的历史。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svnlook history REPOS_PATH
            [PATH_IN_REPOS]</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>打印版本库(如果没有路径，则是根目录)某一个路径的历史。</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--revision (-r) REV
--show-ids
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>这显示了实例版本库中作为修订版本20的路径<filename>/tags/1.0</filename>的历史输出。</para>
            <screen>
$ svnlook history -r 20 /var/svn/repos /tags/1.0 --show-ids
REVISION   PATH &lt;ID&gt;
--------   ---------
      19   /tags/1.0 &lt;1.2.12&gt;
      17   /branches/1.0-rc2 &lt;1.1.10&gt;
      16   /branches/1.0-rc2 &lt;1.1.x&gt;
      14   /trunk &lt;1.0.q&gt;
      13   /trunk &lt;1.0.o&gt;
      11   /trunk &lt;1.0.k&gt;
       9   /trunk &lt;1.0.g&gt;
       8   /trunk &lt;1.0.e&gt;
       7   /trunk &lt;1.0.b&gt;
       6   /trunk &lt;1.0.9&gt;
       5   /trunk &lt;1.0.7&gt;
       4   /trunk &lt;1.0.6&gt;
       2   /trunk &lt;1.0.3&gt;
       1   /trunk &lt;1.0.2&gt;
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svnlook.c.info">
          <indexterm>
            <primary>svnlook</primary>
            <secondary>子命令</secondary>
            <tertiary>info</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svnlook info</refname>
            <refpurpose>打印作者、时间戳、日志信息大小和日志信息。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svnlook info REPOS_PATH</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>打印作者、时间戳、日志信息大小(字节)和日志信息，然后是一个换行符。</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--revision (-r) REV
--transaction (-t)
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>显示了你的实例版本库在修订版本40的信息输出：</para>
            <screen>
$ svnlook info -r 40 /var/svn/repos
sally
2003-02-22 17:44:49 -0600 (Sat, 22 Feb 2003)
16
Rearrange lunch.
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svnlook.c.lock">
          <indexterm>
            <primary>svnlook</primary>
            <secondary>子命令</secondary>
            <tertiary>lock</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svnlook lock</refname>
            <refpurpose>如果版本库路径已经被锁定，描述它。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svnlook lock REPOS_PATH PATH_IN_REPOS</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>打印<replaceable>PATH_IN_REPOS</replaceable>锁定的所有信息，如果<replaceable>PATH_IN_REPOS</replaceable>没有锁定，则不打印任何内容。</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <para>无</para>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>这描述了文件<filename>tree.jpg</filename>的锁定。</para>
            <screen>
$ svnlook lock /var/svn/repos tree.jpg
UUID Token: opaquelocktoken:ab00ddf0-6afb-0310-9cd0-dda813329753
Owner: harry
Created: 2005-07-08 17:27:36 -0500 (Fri, 08 Jul 2005)
Expires: 
Comment (1 line):
Rework the uppermost branches on the bald cypress in the foreground.
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svnlook.c.log">
          <indexterm>
            <primary>svnlook</primary>
            <secondary>子命令</secondary>
            <tertiary>log</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svnlook log</refname>
            <refpurpose>日志信息本身， 后接换行。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svnlook log REPOS_PATH</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>打印日志信息。</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--revision (-r) REV
--transaction (-t)
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>这显示了实例版本库在修订版本40的日志输出：</para>
            <screen>
$ svnlook log /var/svn/repos/
Rearrange lunch.
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svnlook.c.propget">
          <indexterm>
            <primary>svnlook</primary>
            <secondary>子命令</secondary>
            <tertiary>propget</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svnlook propget</refname>
            <refpurpose>打印版本库中一个路径一个属性的原始值。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svnlook propget REPOS_PATH PROPNAME [PATH_IN_REPOS]</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>列出版本库中一个路径一个属性的值。</para>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>使用<command>svnserve</command>通过<command>inetd</command></para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--revision (-r) REV
--transaction (-t)
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>这显示了<literal>HEAD</literal>修订版本中文件<filename>/trunk/sandwich</filename>的<quote>seasonings</quote>属性的值：</para>
            <screen>
$ svnlook pg /var/svn/repos seasonings /trunk/sandwich
mustard
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svnlook.c.proplist">
          <indexterm>
            <primary>svnlook</primary>
            <secondary>子命令</secondary>
            <tertiary>proplist</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svnlook proplist</refname>
            <refpurpose>打印版本化的文件和目录的属性名称和值。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svnlook proplist REPOS_PATH [PATH_IN_REPOS]</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>列出版本库中一个路径的属性，使用<option>--verbose</option>选项也会显示所有的属性值。</para>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>使用<command>svnserve</command>通过<command>inetd</command></para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--revision (-r) REV
--transaction (-t)
--verbose (-v)
--revprop
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>这显示了<literal>HEAD</literal>修订版本中<filename>/trunk/README</filename>的属性名称：</para>
            <screen>
$ svnlook proplist /var/svn/repos /trunk/README
  original-author
  svn:mime-type
</screen>
            <para>这与前一个例子是同一个命令，但是同时显示了属性值：</para>
            <screen>
$ svnlook --verbose proplist /var/svn/repos /trunk/README
  original-author : harry
  svn:mime-type : text/plain
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svnlook.c.tree">
          <indexterm>
            <primary>svnlook</primary>
            <secondary>子命令</secondary>
            <tertiary>tree</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svnlook tree</refname>
            <refpurpose>打印树。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svnlook tree REPOS_PATH [PATH_IN_REPOS]</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>打印树，从<replaceable>PATH_IN_REPOS</replaceable>(如果提供，会作为树的根)开始，可以选择显示节点修订版本ID。</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--revision (-r) REV
--transaction (-t)
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>这会显示实例版本库中修订版本40的树输出(包括节点ID(nodeIDs))：</para>
            <screen>
$ svnlook tree -r 40 /var/svn/repos --show-ids
/ &lt;0.0.2j&gt;
 trunk/ &lt;p.0.2j&gt;
  vendors/ &lt;q.0.2j&gt;
   deli/ &lt;1g.0.2j&gt;
    egg.txt &lt;1i.e.2j&gt;
    soda.txt &lt;1k.0.2j&gt;
    sandwich.txt &lt;1j.0.2j&gt;
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svnlook.c.uuid">
          <indexterm>
            <primary>svnlook</primary>
            <secondary>子命令</secondary>
            <tertiary>uuid</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svnlook uuid</refname>
            <refpurpose>打印版本库的<literal>UUID</literal>。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svnlook uuid REPOS_PATH</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>打印版本库的<literal>UUID</literal>，UUID是版本库的<emphasis>u</emphasis>niversal <emphasis>u</emphasis>nique<emphasis>id</emphasis>entifier(全局唯一标示)，Subversion客户端可以使用这个标示区分不同的版本库。</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <para>无</para>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <screen>
$ svnlook uuid /var/svn/repos
e7fe1b91-8cd5-0310-98dd-2f12e793c5e8
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svnlook.c.youngest">
          <indexterm>
            <primary>svnlook</primary>
            <secondary>子命令</secondary>
            <tertiary>youngest</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svnlook youngest</refname>
            <refpurpose>显示最年轻的修订版本号。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svnlook youngest REPOS_PATH</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>打印一个版本库最年轻的修订版本号。</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <para>无</para>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>这显示了在实例版本库显示最年轻的修订版本：</para>
            <screen>
$ svnlook youngest /var/svn/repos/ 
42
</screen>
          </refsection>
        </refentry>
      </section>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.ref.svnsync">
      <info>
        <title>svnsync</title>
      </info>
      <para><command>svnsync</command>是Subversion的远程版本库镜像工具，它允许你把一个版本库的内容录入到另一个。</para>
      <para>在任何镜像场景中，有两个版本库：源版本库，镜像(或<quote>sink</quote>)版本库，源版本库就是<command>svnsync</command>获取修订版本的库，镜像版本库是源版本库修订版本的目标，两个版本库可以是在本地或远程—它们只是通过URL跟踪。</para>
      <para><command>svnsync</command>进程只需要对源版本库有读权限；它不会尝试修改它。但是很明显，<command>svnsync</command>可以读写访问镜像版本库。</para>
      <warning>
        <para><command>svnsync</command>对于不能作为镜像操作一部分的修改非常敏感，为了防止发生这个情况，最好保证<command>svnsync</command>是唯一可以修改镜像版本库的进程。</para>
      </warning>
      <!-- =============================================================== -->
      <section xml:id="svn.ref.svnsync.sw">
        <info>
          <title>svnsync 选项</title>
        </info>
        <para>这个命令同<command>svn copy</command>加一个<command>svn delete</command>等同。</para>
        <variablelist>
          <varlistentry>
            <term>
              <option>--config-dir</option>
              <replaceable>DIR</replaceable>
            </term>
            <listitem>
              <para>指导Subversion从指定目录而不是默认位置(用户主目录的<filename>.subversion</filename>)读取配置信息。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--no-auth-cache</option>
            </term>
            <listitem>
              <para>阻止在Subversion管理区缓存认证信息(如用户名密码)。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--non-interactive</option>
            </term>
            <listitem>
              <para>如果认证失败，或者是不充分的凭证时，防止出现要求凭证的提示(例如用户名和密码)。这在运行自动脚本时非常有用，只是让Subversion失败而不是提示更多的信息。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><option>--quiet</option> (<option>-q</option>)</term>
            <listitem>
              <para>请求客户端在执行操作时只显示重要信息。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>store-passwords</option>
              <replaceable>PASS</replaceable>
            </term>
            <listitem>
              <para>Specifies the password for the Subversion server
              from which you are syncing.  If not provided, or if
              incorrect, Subversion will prompt you for this
              information as needed.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--username</option>
              <replaceable>NAME</replaceable>
            </term>
            <listitem>
              <para>Specifies the username for the Subversion server
              from which you are syncing.  If not provided, or if
              incorrect, Subversion will prompt you for this
              information as needed.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--password</option>
              <replaceable>PASS</replaceable>
            </term>
            <listitem>
              <para>Specifies the password for the Subversion server to
              which you are syncing.  If not provided, or if
              incorrect, Subversion will prompt you for this
              information as needed.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--username</option>
              <replaceable>NAME</replaceable>
            </term>
            <listitem>
              <para>Specifies the username for the Subversion server to
              which you are syncing.  If not provided, or if
              incorrect, Subversion will prompt you for this
              information as needed.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.ref.svnsync.c">
        <info>
          <title>svnsync 子命令</title>
        </info>
        <para>有许多不同方法运行<command>svnserve</command>：</para>
        <refentry xml:id="svn.ref.svnsync.c.copy-revprops">
          <indexterm>
            <primary>svnsync</primary>
            <secondary>子命令</secondary>
            <tertiary>copy-revprops</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svnsync copy-revprops</refname>
            <refpurpose>从源版本库拷贝所有的修订版本属性到镜像版本库。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svnsync copy-revprops DEST_URL REV</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>因为Subversion修订版本属性可以在任何时候修改，很有可能有一些修订版本的属性会在已经同步后改变，因为<command>svnsync synchronize</command>不会对没有同步的修订版本范围进行操作，而不会注意修改范围之外的属性修改。这样导致了修订版本属性在源版本库与目标版本库的偏离，<command>svnsync copy-revprops</command>是这个问题的答案，用它可以同步特定修订版本的属性。</para>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>无</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--config-dir DIR
--no-auth-cache
--non-interactive
--quiet (-q)
--source-password ARG
--source-username ARG
--sync-password ARG
--sync-username ARG
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>为单个修订版本重新同步修订版本属性：</para>
            <screen>
$ svnsync copy-revprops file:///var/svn/repos-mirror 6
Copied properties for revision 6.
$
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svnsync.c.help">
          <indexterm>
            <primary>svnsync</primary>
            <secondary>子命令</secondary>
            <tertiary>help</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svnsync help</refname>
            <refpurpose>求助！</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svnsync help</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>This subcommand is useful when you're trapped in a
            foreign prison with neither a Net connection nor a copy of
            this book, but you do have a local Wi-Fi network running
            and you'd like to sync a copy of your repository over to
            the backup server that Ira The Knife is running over in
            cell block D.</para>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>无</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <para>无</para>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svnsync.c.init">
          <indexterm>
            <primary>svnsync</primary>
            <secondary>子命令</secondary>
            <tertiary>initialize</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svnsync initialize</refname>
            <refpurpose>为与另一个版本库的同步初而始化目标版本库。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svnsync initialize DEST_URL SOURCE_URL</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para><command>svnsync initialize</command>检验版本库是否满足了新镜像版本库的需求—它必须没有存在的版本历史，并允许修订版本修改—记录镜像版本库与源版本库关联的初始管理信息，这是对即将镜像的版本库的第一个<command>svnsync</command>操作。</para>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>
              <command>init</command>
            </para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--config-dir DIR
--no-auth-cache
--non-interactive
--quiet (-q)
--source-password ARG
--source-username ARG
--sync-password ARG
--sync-username ARG
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>因为无法修改修订版本属性而初始化镜像版本库失败：</para>
            <screen>
$ svnsync initialize file:///var/svn/repos-mirror http://svn.example.com/repos
svnsync: Repository has not been enabled to accept revision propchanges;
ask the administrator to create a pre-revprop-change hook
$
</screen>
            <para>以镜像初始化版本库，包含已创建允许所有修订版本属性修改的<literal>pre-revprop-change</literal>钩子：</para>
            <screen>
$ svnsync initialize file:///var/svn/repos-mirror http://svn.example.com/repos
Copied properties for revision 0.
$
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svnsync.c.sync">
          <indexterm>
            <primary>svnsync</primary>
            <secondary>子命令</secondary>
            <tertiary>synchronize</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svnsync synchronize</refname>
            <refpurpose>将所有未完成的修订版本从源版本库转移到镜像版本库。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svnsync synchronize DEST_URL</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para><command>svnsync synchronize</command>命令做了版本库镜像工作的所有体力活，通过讯问镜像版本库来查看已经拷贝的修订版本，然后开始拷贝未镜像修订版本到镜像版本库。</para>
            <para><command>svnsync synchronize</command>可以优雅的取消并重新开始。</para>
            <para>As of Subversion 1.5, you can limit <command>svnsync</command> to a
            subdirectory of the source repository by specifying the
            subdirectory as part of
            the <replaceable>SOURCE_URL</replaceable>.</para>
          </refsection>
          <refsection>
            <info>
              <title>别名</title>
            </info>
            <para>
              <command>sync</command>
            </para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--config-dir DIR
--no-auth-cache
--non-interactive
--quiet (-q)
--source-password ARG
--source-username ARG
--sync-password ARG
--sync-username ARG
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>从源版本库拷贝未同步修订版本到镜像版本库：</para>
            <screen>
$ svnsync synchronize file:///var/svn/repos-mirror
Committed revision 1.
Copied properties for revision 1.
Committed revision 2.
Copied properties for revision 2.
Committed revision 3.
Copied properties for revision 3.
…
Committed revision 45.
Copied properties for revision 45.
Committed revision 46.
Copied properties for revision 46.
Committed revision 47.
Copied properties for revision 47.
$
</screen>
          </refsection>
        </refentry>
      </section>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.ref.svnserve">
      <info>
        <title>svnserve</title>
      </info>
      <para>当对远程源版本库使用<command>svnsync</command>时，使用Subversion的自定义网络协议。</para>
      <para><command>svnserve</command>允许Subversion版本库使用<literal>svn</literal>网络协议，你可以作为独立服务器进程运行svnserve，或者是使用其它进程，如<command>inetd</command>、<command>xinetd</command>(也是<literal>svn://</literal>)或使用<literal>svn+ssh://</literal>访问方法的<command>sshd</command>为你启动进程。</para>
      <para>一旦客户端已经选择了一个版本库来传递它的URL，<command>svnserve</command>会读取版本库目录的<filename>conf/svnserve.conf</filename>文件，来检测版本库特定的设置，如使用哪个认证数据库和应用怎样的授权策略。关于<filename>svnserve.conf</filename>文件的详情见<xref linkend="svn.serverconfig.svnserve"/>。</para>
      <!-- =============================================================== -->
      <section xml:id="svn.ref.svnserve.sw">
        <info>
          <title>svnserve 选项</title>
        </info>
        <para>不象前面描述的命令，<command>svnserve</command>没有子命令—<command>svnserve</command>完全通过选项控制。</para>
        <variablelist>
          <varlistentry>
            <term><option>--daemon</option> (<option>-d</option>)</term>
            <listitem>
              <para>导致<command>svnserve</command>以守护进程方式运行，<command>svnserve</command>维护本身并且接受和服务svn端口(缺省3690)的TCP/IP连接。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--foreground</option>
            </term>
            <listitem>
              <para>当与<option>-d</option>一起使用，会导致<command>svnserve</command>停留在前台，主要用来调试。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><option>--inetd</option> (<option>-i</option>)</term>
            <listitem>
              <para>导致<command>svnserve</command>使用标准输出/标准输入文件描述符，更准确的是使用<command>inetd</command>作为守护进程。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><option>--help</option> (<option>-h</option>)</term>
            <listitem>
              <para>显示有用的摘要和选项。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><option>--listen-host</option>=<replaceable>HOST</replaceable></term>
            <listitem>
              <para><command>svnserve</command>监听的<replaceable>HOST</replaceable>，可能是一个主机名或是一个IP地址。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><option>--listen-once</option> (<option>-X</option>)</term>
            <listitem>
              <para>导致<command>svnserve</command>在svn端口接受一个连接，并为之服务，完成后退出。这个选项主要用来调试。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><option>--listen-port</option>=<replaceable>PORT</replaceable></term>
            <listitem>
              <para>在守护进程模式时导致svnserve监听<replaceable>PORT</replaceable>端口。(FreeBSD守护进程缺省只监听tcp6—这个选项告诉他们监听tcp4。)</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--pid-file <replaceable>FILENAME</replaceable></option>
            </term>
            <listitem>
              <para>导致<command>svnserve</command>将进程ID写入<replaceable>FILENAME</replaceable>，必须对于运行的<command>svnserve</command>的用户可写。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><option>--root</option>=<replaceable>ROOT</replaceable> (<option>-r</option>=<replaceable>ROOT</replaceable>)</term>
            <listitem>
              <para>设置<command>svnserve</command>服务的版本库的虚拟根，客户端提供的URL中显示的路径会解释为这个根的相对路径，不会允许离开这个根。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><option>--threads</option> (<option>-T</option>)</term>
            <listitem>
              <para>当以守护进程模式运行，导致<command>svnserve</command>为每个连接产生一个线程而不是一个进程(例如在Windows中运行时)，<command>svnserve</command>进程本身在启动后会一直在后台。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><option>--tunnel</option> (<option>-t</option>)</term>
            <listitem>
              <para>导致<command>svnserve</command>以管道模式运行，很像<command>inetd</command>操作的模式(两种模式都维护标准输入/标准输出的连接)，除了连接是用当前UID的用户名预先认证过的这一点。这个选项在客户端使用如<command>ssh</command>之类的管道时自动传递，这意味着你很少有必要再去传递这个参数给<command>svnserve</command>，所以如果你发现在命令行输入了<literal>svnserve --tunnel</literal>，并想知道接下来怎么做，可以看<xref linkend="svn.serverconfig.svnserve.sshauth"/>。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--tunnel-user NAME</option>
            </term>
            <listitem>
              <para>与<option>--tunnel</option>选项结合使用；告诉svnserve假定<replaceable>NAME</replaceable>就是认证用户，而不是svnserve进程的UID用户，当希望多个用户通过SSH共享同一个系统帐户，但是维护各自的提交标示符时非常有用。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--version</option>
            </term>
            <listitem>
              <para>显示版本信息，版本库后端存在和可用的模块列表，然后退出。</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.ref.svndumpfilter">
      <info>
        <title>svndumpfilter</title>
      </info>
      <para><command>svnadmin</command>是一个用来监控和修改Subversion版本库的管理工具，详情请见<xref linkend="svn.reposadmin.maint.tk.svnadmin"/>。</para>
      <!-- =============================================================== -->
      <section xml:id="svn.ref.svndumpfilter.options">
        <info>
          <title>svndumpfilter 选项</title>
        </info>
        <para>这个命令同<command>svn copy</command>加一个<command>svn delete</command>等同。</para>
        <variablelist>
          <varlistentry>
            <term>
              <option>--drop-empty-revs</option>
            </term>
            <listitem>
              <para>If filtering causes any revision to be empty (i.e.,
              causes no change to the repository), removes these
              revisions from the final dump file.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--renumber-revs</option>
            </term>
            <listitem>
              <para>Renumbers revisions that remain after
              filtering.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--skip-missing-merge-sources</option>
            </term>
            <listitem>
              <para>Skips merge sources that have been removed as part of
              the filtering.  Without this
              option, <command>svndumpfilter</command> will exit with
              an error if the merge source for a retained path is
              removed by filtering.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--preserve-revprops</option>
            </term>
            <listitem>
              <para>If all nodes in a revision are removed by filtering
              and <option>--drop-empty-revs</option> is not passed,
              the default behavior of <command>svndumpfilter</command>
              is to remove all revision properties except for the date
              and the log message (which will merely indicate that the
              revision is empty).  Passing this option will preserve
              existing revision properties (which may or may not make
              sense since the related content is no longer present in
              the dump file).</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>--quiet</option>
            </term>
            <listitem>
              <para>Does not display filtering statistics.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.ref.svndumpfilter.c">
        <info>
          <title>svndumpfilter 子命令</title>
        </info>
        <para>有许多不同方法运行<command>svnserve</command>：</para>
        <refentry xml:id="svn.ref.svndumpfilter.commands.c.exclude">
          <indexterm>
            <primary>svndumpfilter</primary>
            <secondary>子命令</secondary>
            <tertiary>exclude</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svndumpfilter</refname>
            <refpurpose>将指定路径的数据从转储数据流中排除。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svndumpfilter exclude PATH_PREFIX...</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>This can be used to exclude nodes that begin with one or
            more <replaceable>PATH_PREFIX</replaceable>es from a
            filtered dump file.</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--drop-empty-revs
--preserve-revprops
--quiet
--renumber-revs
--skip-missing-merge-sources
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>If we have a dump file from a repository with a number of
          different picnic-related directories in it, but we want to keep
          everything <emphasis>except</emphasis>
          the <filename>sandwiches</filename> part of the repository,
          we'll exclude only that path:</para>
            <screen>
$ svndumpfilter exclude sandwiches &lt; dumpfile &gt; filtered-dumpfile
Excluding prefixes:
   '/sandwiches'

Revision 0 committed as 0.
Revision 1 committed as 1.
Revision 2 committed as 2.
Revision 3 committed as 3.
Revision 4 committed as 4.

Dropped 1 node(s):
   '/sandwiches'
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svndumpfilter.commands.c.include">
          <indexterm>
            <primary>svndumpfilter</primary>
            <secondary>子命令</secondary>
            <tertiary>include</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svndumpfilter</refname>
            <refpurpose>将指定路径的数据从转储数据流中排除。</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svndumpfilter include PATH_PREFIX...</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>Can be used to include nodes that begin with one or
            more <replaceable>PATH_PREFIX</replaceable>es in a
            filtered dump file (thus excluding all other paths).</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <screen>
--drop-empty-revs
--preserve-revprops
--quiet
--renumber-revs
--skip-missing-merge-sources
</screen>
          </refsection>
          <refsection>
            <info>
              <title>例子</title>
            </info>
            <para>If we have a dump file from a repository with a number of
          different picnic-related directories in it, but want to
          keep only the <filename>sandwiches</filename> part of the
          repository, we'll include only that path:</para>
            <screen>
$ svndumpfilter include sandwiches &lt; dumpfile &gt; filtered-dumpfile
Including prefixes:
   '/sandwiches'

Revision 0 committed as 0.
Revision 1 committed as 1.
Revision 2 committed as 2.
Revision 3 committed as 3.
Revision 4 committed as 4.

Dropped 3 node(s):
   '/drinks'
   '/snacks'
   '/supplies'
</screen>
          </refsection>
        </refentry>
        <refentry xml:id="svn.ref.svndumpfilter.commands.c.help">
          <indexterm>
            <primary>svndumpfilter</primary>
            <secondary>子命令</secondary>
            <tertiary>help</tertiary>
          </indexterm>
          <refnamediv>
            <refname>svndumpfilter</refname>
            <refpurpose>求助！</refpurpose>
          </refnamediv>
          <refsection>
            <info>
              <title>概要</title>
            </info>
            <programlisting>svnadmin help [SUBCOMMAND...]</programlisting>
          </refsection>
          <refsection>
            <info>
              <title>描述</title>
            </info>
            <para>Displays the help message
            for <command>svndumpfilter</command>.  Unlike other help
            commands documented in this chapter, there is no witty
            commentary for this help command.  The authors of this
            book deeply regret the omission.</para>
          </refsection>
          <refsection>
            <info>
              <title>选项</title>
            </info>
            <para>无</para>
          </refsection>
        </refentry>
      </section>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.ref.svnversion">
      <info>
        <title>svnversion</title>
      </info>
      <refentry xml:id="svn.ref.svnversion.re">
        <indexterm>
          <primary>svnversion</primary>
        </indexterm>
        <refnamediv>
          <refname>svnversion</refname>
          <refpurpose>总结工作拷贝的本地修订版本。</refpurpose>
        </refnamediv>
        <refsection xml:id="svn.ref.svnversion.re.syn">
          <info>
            <title>概要</title>
          </info>
          <programlisting>svnversion [OPTIONS] [WC_PATH [TRAIL_URL]]</programlisting>
        </refsection>
        <refsection xml:id="svn.ref.svnversion.re.desc">
          <info>
            <title>描述</title>
          </info>
          <para><command>svnversion</command>是用来总结工作拷贝修订版本混合的程序，结果修订版本号或范围会写到标准输出。</para>
          <para>通常在构建过程中利用其输出定义程序的版本号码。</para>
          <para>如果提供<replaceable>TRAIL_URL</replaceable>，URL的尾端部分用来监测是否<replaceable>WC_PATH</replaceable>本身已经跳转(监测<replaceable>WC_PATH</replaceable>的跳转不需要依赖<replaceable>TRAIL_URL</replaceable>)。</para>
          <para>当没有定义<replaceable>WC_PATH</replaceable>，会使用当前路径作为工作拷贝路径，如果没有显式定义<replaceable>WC_PATH</replaceable>，<replaceable>TRAIL_URL</replaceable>将无法定义。</para>
        </refsection>
        <refsection xml:id="svn.ref.svnversion.re.sw">
          <info>
            <title>选项</title>
          </info>
          <para>像<command>svnserve</command>，<command>svnversion</command>没有子命令—只有选项。</para>
          <variablelist>
            <varlistentry>
              <term><option>--no-newline</option> (<option>-n</option>)</term>
              <listitem>
                <para>忽略输出的尾端新行。.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>--committed</option> (<option>-c</option>)</term>
              <listitem>
                <para>使用最后修改修订版本而不是当前的(例如，本地存在的最高修订版本)修订版本。</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>--help</option> (<option>-h</option>)</term>
              <listitem>
                <para>打印帮助摘要。</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <option>--version</option>
              </term>
              <listitem>
                <para>打印<command>svnversion</command>，如果没有错误则退出。</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </refsection>
        <refsection xml:id="svn.ref.svnversion.re.examples">
          <info>
            <title>例子</title>
          </info>
          <para>如果工作拷贝都是一样的修订版本(例如，在更新后那一刻)，会打印修订版本：</para>
          <screen>
$ svnversion
4168
</screen>
          <para>添加<replaceable>TRAIL_URL</replaceable>来展示工作拷贝不是从你希望的地方跳转过来的，注意这个命令需要<replaceable>WC_PATH</replaceable>：</para>
          <screen>
$ svnversion . /var/svn/trunk
4168
</screen>
          <para>对于混合修订版本的工作拷贝，修订版本的范围会被打印：</para>
          <screen>
$ svnversion
4123:4168
</screen>
          <para>如果工作拷贝包含修改，后面会紧跟一个"M"：</para>
          <screen>
$ svnversion
4168M
</screen>
          <para>如果工作拷贝已经跳转，后面会有一个"S"：</para>
          <screen>
$ svnversion
4168S
</screen>
          <para>因此，这里是一个混合修订版本，跳转的工作拷贝包含了一些本地修改：</para>
          <screen>
$ svnversion
4212:4168MS
</screen>
          <para>如果从一个目录而不是工作拷贝调用，<command>svnversion</command>假定它是一个导出的工作拷贝并且打印"exported"：</para>
          <screen>
$ svnversion
exported
</screen>
        </refsection>
      </refentry>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.ref.mod_dav_svn">
      <info>
        <title>mod_dav_svn</title>
      </info>
      <refentry xml:id="svn.ref.mod_dav_svn.conf">
        <refnamediv>
          <refname><placeholder-1/> Configuration Directives</refname>
          <refpurpose>Apache通过Apache HTTP服务器用来维护Subversion版本库配置指示。</refpurpose>
        </refnamediv>
        <refsection xml:id="svn.ref.mod_dav_svn.conf.desc">
          <info>
            <title>描述</title>
          </info>
          <para>这个小节主要描述了Subversion Apache配置的每个指示，关于Apache配置Subversion的更多信息见<xref linkend="svn.serverconfig.httpd"/>。</para>
        </refsection>
        <refsection xml:id="svn.ref.mod_dav_svn.conf.directives">
          <info>
            <title>指示</title>
          </info>
          <para>These are the <filename>httpd.conf</filename> directives
          that apply to <command>mod_dav_svn</command>:</para>
          <variablelist>
            <varlistentry>
              <term>
                <literal>DAV svn</literal>
              </term>
              <listitem>
                <para>这个指示必须包含在所有Subversion版本库的<literal>Directory</literal>或<literal>Location</literal>块中，它告诉httpd使用Subversion的后端，用<literal>mod_dav</literal>来处理所有的请求。</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>SVNAllowBulkUpdates On|Off</literal>
              </term>
              <listitem>
                <para>Toggles support for all-inclusive
                responses to update-style <literal>REPORT</literal>
                requests.  Subversion clients use
                <literal>REPORT</literal> requests to get information
                about directory tree checkouts and updates from
                <command>mod_dav_svn</command>.  They can ask the
                server to send that information in one of two ways:
                with the entirety of the tree's information in one
                massive response, or with a
                <firstterm>skelta</firstterm> (a skeletal
                representation of a tree delta) which contains just
                enough information for the client to know what
                <emphasis>additional</emphasis> data to request from
                the server.  When this directive is included with a
                value of <literal>Off</literal>,
                <command>mod_dav_svn</command> will only ever respond
                to these <literal>REPORT</literal> requests with
                skelta responses, regardless of the type of responses
                requested by the client.</para>
                <para>Most folks won't need to use this directive at
                all.  It primarily exists for administrators who
                wish—for security or auditing reasons—to
                force Subversion clients to fetch individually all the
                files and directories needed for updates and
                checkouts, thus leaving an audit trail of
                <literal>GET</literal> and <literal>PROPFIND</literal>
                requests in Apache's logs.  The default value of this
                directive is <literal>On</literal>.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>SVNAutoversioning On|Off</literal>
              </term>
              <listitem>
                <para>这个指示允许WebDAV客户端的请求导致自动提交，每个修订版本会产生一个普通的日志信息。如果你开启了自动版本化，你很可能需要设置<literal>ModMimeUsePathInfo On</literal>，这样<literal>mod_mime</literal>可以自动的(像<literal>mod_mime</literal>一样好，当然)将<literal>svn:mime-type</literal>设置为正确的<literal>svn:mime-type</literal>值。更多信息见<xref linkend="svn.webdav"/>。这个指示的缺省值是<literal>off</literal>。</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>SVNPath <replaceable>directory-path</replaceable></literal>
              </term>
              <listitem>
                <para>这个指示指定Subversion版本库文件文件系统的位置，在一个Subversion版本库的配置块里，必须提供这个指示或<literal>SVNParentPath</literal>，但不能同时存在。</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>SVNSpecialURI <replaceable>component</replaceable></literal>
              </term>
              <listitem>
                <para>指定特定Subversion资源的URI部分(命名空间)，缺省是<quote><literal>!svn</literal></quote>，大多数管理员不会用到这个指示。只有那些必须要在版本库中放一个名字为<filename>!svn</filename>的文件时需要设置。如果你在一个已经使用中的服务器上这样修改，它会破坏所有的工作拷贝，你的用户会拿着叉子和火把追杀你。</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>SVNReposName <replaceable>名称</replaceable></literal>
              </term>
              <listitem>
                <para>指定Subversion版本库在<literal>HTTP GET</literal>请求中使用的名字，这个值会作为所有目录列表(当你用web浏览器察看Subversion版本库时会看到)的标题，这个指示是可选的。</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>SVNIndexXSLT <replaceable>directory-path</replaceable></literal>
              </term>
              <listitem>
                <para>目录列表所使用的XSL转化的URI，这个指示可选。</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>SVNParentPath <replaceable>directory-path</replaceable></literal>
              </term>
              <listitem>
                <para>指定子目录会是版本库的父目录在文件系统的位置，在一个Subversion版本库的配置块里，必须提供这个指示或<literal>SVNPath</literal>，但不能同时存在。</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>SVNPathAuthz On|Off|short_circuit</literal>
              </term>
              <listitem>
                <para>Controls path-based authorization by enabling
                subrequests (<literal>On</literal>), disabling
                subrequests (<literal>Off</literal>; see <xref linkend="svn.serverconfig.httpd.authz.pathauthzoff"/>),
                or querying <command>mod_authz_svn</command> directly
                (<literal>short_circuit</literal>).  The default
                value of this directive is <literal>On</literal>.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>SVNListParentPath On|Off</literal>
              </term>
              <listitem>
                <para>When set to <literal>On</literal>, allows
                a <literal>GET</literal>
                of <literal>SVNParentPath</literal>, which results in
                a listing of all repositories under that path.  The
                default setting is
                <literal>Off</literal>.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>SVNMasterURI <replaceable>url</replaceable></literal>
              </term>
              <listitem>
                <para>Specifies a URI to the master Subversion
                repository (used for a write-through proxy).</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>SVNActivitiesDB <replaceable>directory-path</replaceable></literal>
              </term>
              <listitem>
                <para>Specifies the location in the filesystem where the
                activities database should be stored.  By default,
                <command>mod_dav_svn</command> creates and uses a directory in the
                repository
                called <filename>dav/activities.d</filename>.  The
                path specified with this option must be an absolute
                path.</para>
                <para>If specified for
                an <literal>SVNParentPath</literal> area, <command>mod_dav_svn</command>
                appends the basename of the repository to the path
                specified here.  For example:</para>
                <screen>
&lt;Location /svn&gt;
  DAV svn

  # any "/svn/foo" URL will map to a repository in 
  # /net/svn.nfs/repositories/foo
  SVNParentPath         "/net/svn.nfs/repositories"

  # any "/svn/foo" URL will map to an activities db in
  #  /var/db/svn/activities/foo
  SVNActivitiesDB       "/var/db/svn/activities"
&lt;/Location&gt;
</screen>
              </listitem>
            </varlistentry>
          </variablelist>
        </refsection>
        <refsection xml:id="svn.ref.mod_dav_svn.conf.logging">
          <info>
            <title>高级日志</title>
          </info>
          <para>This is a list of Subversion action log messages
          produced by Apache's high-level logging mechanism, followed
          by an example of the log message.  See <xref linkend="svn.serverconfig.httpd.extra.logging"/> for details
          on logging.</para>
          <variablelist>
            <varlistentry>
              <term>Checkout or export</term>
              <listitem>
                <para>
                  <literal>checkout-or-export /path r62
            depth=infinity</literal>
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>Commit</term>
              <listitem>
                <para>
                  <literal>commit harry r100</literal>
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>Diffs</term>
              <listitem>
                <para>
                  <literal>diff /path r15:20 depth=infinity ignore-ancestry</literal>
                </para>
                <para>
                  <literal>diff /path1@15 /path2@20 depth=infinity ignore-ancestry</literal>
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>移动一个文件或目录。</term>
              <listitem>
                <para>
                  <literal>get-dir /trunk r17 text</literal>
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>Fetch a file</term>
              <listitem>
                <para>
                  <literal>get-file /path r20 props</literal>
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>最后修改的修订版本</term>
              <listitem>
                <para>
                  <literal>get-file-revs /path r12:15 include-merged-revisions</literal>
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>获取合并信息</term>
              <listitem>
                <para>
                  <literal>get-mergeinfo (/path1 /path2)</literal>
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>Lock</term>
              <listitem>
                <para>
                  <literal>lock /path steal</literal>
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>Log</term>
              <listitem>
                <para>
                  <literal>log (/path1,/path2,/path3) r20:90
            discover-changed-paths revprops=()</literal>
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>Replay revisions (svnsync)</term>
              <listitem>
                <para>
                  <literal>replay /path r19</literal>
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>修订版本属性修改</term>
              <listitem>
                <para>
                  <literal>change-rev-prop r50
            propertyname</literal>
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>修订版本属性列表</term>
              <listitem>
                <para>
                  <literal>rev-proplist r34</literal>
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>状态</term>
              <listitem>
                <para>
                  <literal>status /path r62
                depth=infinity</literal>
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>Switch</term>
              <listitem>
                <para>
                  <literal>switch /pathA /pathB@50 depth=infinity</literal>
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>Unlock</term>
              <listitem>
                <para>
                  <literal>unlock /path break</literal>
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>更新</term>
              <listitem>
                <para>
                  <literal>update /path r17 send-copyfrom-args</literal>
                </para>
              </listitem>
            </varlistentry>
          </variablelist>
        </refsection>
      </refentry>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.ref.mod_authz_svn">
      <info>
        <title>mod_authz_svn</title>
      </info>
      <refentry xml:id="svn.ref.mod_authz_svn.conf">
        <refnamediv>
          <refname><placeholder-1/> Configuration Directives</refname>
          <refpurpose>Apache通过Apache HTTP服务器用来维护Subversion版本库配置指示。</refpurpose>
        </refnamediv>
        <refsection xml:id="svn.ref.mod_authz_svn.conf.desc">
          <info>
            <title>描述</title>
          </info>
          <para>这个小节主要描述了Subversion Apache配置的每个指示，关于Apache配置Subversion的更多信息见<xref linkend="svn.serverconfig.httpd"/>。</para>
        </refsection>
        <refsection xml:id="svn.ref.mod_authz_svn.conf.directives">
          <info>
            <title>指示</title>
          </info>
          <para>These are the <filename>httpd.conf</filename> directives
          that apply to <command>mod_authz_svn</command>:</para>
          <variablelist>
            <varlistentry>
              <term>
                <literal>SVNReposName <replaceable>file-path</replaceable></literal>
              </term>
              <listitem>
                <para>Consult <replaceable>file-path</replaceable> for
                access rules describing the permissions for paths in
                Subversion repository.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>AuthzSVNAnonymous On|Off</literal>
              </term>
              <listitem>
                <para>Set to <literal>Off</literal> to disable two
                special-case behaviours of this module: interaction
                with the <literal>Satisfy Any</literal> directive and
                enforcement of the authorization policy even when no
                <literal>Require</literal> directives are present.
                The default value of this directive is
                <literal>On</literal>.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>SVNAutoversioning On|Off</literal>
              </term>
              <listitem>
                <para>Set to <literal>Off</literal> to allow access
                control to be passed along to lower modules.  The
                default value of this directive is
                <literal>On</literal>.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>AuthzSVNNoAuthWhenAnonymousAllowed On|Off</literal>
              </term>
              <listitem>
                <para>Set to <literal>On</literal> to suppress
                authentication and authorization for requests which
                anonymous users are allowed to perform.  The default
                value of this directive is
                <literal>On</literal>.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </refsection>
      </refentry>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.ref.properties">
      <info>
        <title>Subversion 属性</title>
      </info>
      <para>Subversion允许用户在文件或目录上发明任意名称的版本化属性和非版本化属性，唯一的限制就是<quote>svn:</quote>是Subversion本身的保留前缀，用户可以设置这些属性来改变Subversion的行为方式，用户不能发明新的<quote>svn:</quote>属性。</para>
      <section xml:id="svn.ref.properties.versioned-props">
        <info>
          <title>版本控制的属性</title>
        </info>
        <para>These are the versioned properties that Subversion reserves
        for its own use:</para>
        <variablelist>
          <varlistentry>
            <term>
              <literal>svn:executable</literal>
            </term>
            <listitem>
              <para>如果出现在一个文件上，客户端会将此文件在Unix工作拷贝中设置为可执行，见<xref linkend="svn.advanced.props.special.executable"/>。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>svn:mime-type</literal>
            </term>
            <listitem>
              <para>如果出现在一个文件，这个值表示了文件的mime-type，这允许客户端在执行更新时决定以行为依据的合并是否安全，同时也会影响使用浏览器浏览文件时的行为方式。见<xref linkend="svn.advanced.props.special.mime-type"/>。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>svn:ignore</literal>
            </term>
            <listitem>
              <para>如果出现在目录上，这是一组<command>svn status</command>和其它命令可以忽略的未版本化文件的名称模式，见<xref linkend="svn.advanced.props.special.ignore"/>。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>svn:keywords</literal>
            </term>
            <listitem>
              <para>如果出现在一个文件上，这个值告诉客户端如何扩展文件的特定关键字，见<xref linkend="svn.advanced.props.special.keywords"/>。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>svn:eol-style</literal>
            </term>
            <listitem>
              <para>如果出现在一个文件上，这个值告诉客户端如何处理工作拷贝中的文件的行结束符，见<xref linkend="svn.advanced.props.special.eol-style"/>和<xref linkend="svn.ref.svn.c.export"/>。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>svn:externals</literal>
            </term>
            <listitem>
              <para>如果出现在一个目录上，则这个值就是客户端必须要检出的路径和URL列表。见<xref linkend="svn.advanced.externals"/>。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>svn:special</literal>
            </term>
            <listitem>
              <para>如果出现在一个文件上，表示了那个文件不是一个普通的文件，而是一个符号链或者是其他特殊的对象<footnote><para>此时，符号链是唯一的<quote>特别</quote>对象，但是以后，也许Subversion会有更多的特别对象。</para></footnote>。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>svn:needs-lock</literal>
            </term>
            <listitem>
              <para>如果出现在一个文件上，告诉客户端在工作拷贝将文件置为只读，可以提醒我们在修改以前必须解锁。见<xref linkend="svn.advanced.locking.lock-communication"/>。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>svn:mergeinfo</literal>
            </term>
            <listitem>
              <para>Used by Subversion to track merge data.  See
              <xref linkend="svn.branchmerge.basicmerging.mergeinfo"/>
              for details, but you should never edit this property
              unless you <emphasis>really</emphasis> know what you're
              doing.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
      <section xml:id="svn.ref.properties.unversioned-props">
        <info>
          <title>未版本控制的属性</title>
        </info>
        <para>These are the unversioned properties that Subversion reserves
        for its own use:</para>
        <variablelist>
          <varlistentry>
            <term>
              <literal>svn:author</literal>
            </term>
            <listitem>
              <para>如果出现，则保存了创建这个修订版本的认证用户名。(如果没有出现，则修订版本是匿名提交的。)</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>svn:date</literal>
            </term>
            <listitem>
              <para>保存了ISO 8601格式的修订版本创建UTC时间，这个值来自服务器主机时钟，不是客户端的。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>svn:log</literal>
            </term>
            <listitem>
              <para>保存了描述修订版本的日志信息。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>svn:autoversioned</literal>
            </term>
            <listitem>
              <para>如果出现，则修订版本是通过自动版本化特性创建，见<xref linkend="svn.webdav.autoversioning"/>。</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.ref.reposhooks">
      <info>
        <title>版本库钩子</title>
      </info>
      <para>These are the repository hooks that Subversion provides:</para>
      <!-- =============================================================== -->
      <refentry xml:id="svn.ref.reposhooks.start-commit">
        <indexterm>
          <primary>版本库</primary>
          <secondary>hooks</secondary>
          <tertiary>start-commit</tertiary>
        </indexterm>
        <refnamediv>
          <refname>start-commit</refname>
          <refpurpose>开始提交的通知</refpurpose>
        </refnamediv>
        <refsection>
          <info>
            <title>描述</title>
          </info>
          <para> start-commit在开始事务之前执行，通常是用来确定用户是否有提交权限。</para>
          <para>如果start-commit钩子程序返回非零值，提交就会在创建之前停止，标准错误的任何输出都会返回到客户端。</para>
        </refsection>
        <refsection>
          <info>
            <title>输入参数</title>
          </info>
          <para>传递给你钩子程序的命令行参数，按照顺序是：</para>
          <orderedlist inheritnum="ignore" continuation="restarts">
            <listitem>
              <para>版本库路径</para>
            </listitem>
            <listitem>
              <para>认证过的尝试提交的用户名</para>
            </listitem>
            <listitem>
              <para>Colon-separated list of
              capabilities that a client passes to the server,
              including <literal>depth</literal>,
              <literal>mergeinfo</literal>, and
              <literal>log-revprops</literal> (new in Subversion 1.5).</para>
            </listitem>
          </orderedlist>
        </refsection>
        <refsection>
          <info>
            <title>普通用户</title>
          </info>
          <para>Access control (e.g., temporarily lock out commits for
          some reason).</para>
          <para>A means to allow access only from clients that have
          certain capabilities.</para>
        </refsection>
      </refentry>
      <!-- =============================================================== -->
      <refentry xml:id="svn.ref.reposhooks.pre-commit">
        <indexterm>
          <primary>版本库</primary>
          <secondary>hooks</secondary>
          <tertiary>pre-commit</tertiary>
        </indexterm>
        <refnamediv>
          <refname>pre-commit</refname>
          <refpurpose>在提交结束之前提醒。</refpurpose>
        </refnamediv>
        <refsection>
          <info>
            <title>描述</title>
          </info>
          <para><literal>pre-commit</literal>钩子在事务完成提交之前运行，通常这个钩子是用来保护因为内容或位置(例如，你要求所有到一个特定分支的提交必须包括一个bug追踪的ticket号，或者是要求日志信息不为空)而不允许的提交。</para>
          <para>如果<literal>pre-commit</literal>钩子返回非零值，提交会退出，提交事务被删除，所有标准错误的输出返回到客户端。</para>
        </refsection>
        <refsection>
          <info>
            <title>输入参数</title>
          </info>
          <para>传递给你钩子程序的命令行参数，按照顺序是：</para>
          <orderedlist inheritnum="ignore" continuation="restarts">
            <listitem>
              <para>版本库路径</para>
            </listitem>
            <listitem>
              <para>提交事务的名称</para>
            </listitem>
          </orderedlist>
        </refsection>
        <refsection>
          <info>
            <title>普通用户</title>
          </info>
          <para>修改确认和控制</para>
        </refsection>
      </refentry>
      <!-- =============================================================== -->
      <refentry xml:id="svn.ref.reposhooks.post-commit">
        <indexterm>
          <primary>版本库</primary>
          <secondary>hooks</secondary>
          <tertiary>post-commit</tertiary>
        </indexterm>
        <refnamediv>
          <refname>post-commit</refname>
          <refpurpose>成功提交的通知。</refpurpose>
        </refnamediv>
        <refsection>
          <info>
            <title>描述</title>
          </info>
          <para><literal>post-commit</literal>钩子在事务完成后运行，创建一个新的修订版本。大多数人用这个钩子来发送关于提交的描述性电子邮件，或者用来提醒其它工具(例如问题跟踪)。一些配置也使用这个钩子触发版本库的备份进程。</para>
          <para>如果<literal>pre-commit</literal>钩子返回非零值，提交会退出，提交事务被删除，所有标准错误的输出返回到客户端。</para>
        </refsection>
        <refsection>
          <info>
            <title>输入参数</title>
          </info>
          <para>传递给你钩子程序的命令行参数，按照顺序是：</para>
          <orderedlist inheritnum="ignore" continuation="restarts">
            <listitem>
              <para>版本库路径</para>
            </listitem>
            <listitem>
              <para>提交创建的修订版本号</para>
            </listitem>
          </orderedlist>
        </refsection>
        <refsection>
          <info>
            <title>普通用户</title>
          </info>
          <para>提交通知；工具集成</para>
        </refsection>
      </refentry>
      <!-- =============================================================== -->
      <refentry xml:id="svn.ref.reposhooks.pre-revprop-change">
        <indexterm>
          <primary>版本库</primary>
          <secondary>hooks</secondary>
          <tertiary>pre-revprop-change</tertiary>
        </indexterm>
        <refnamediv>
          <refname>pre-revprop-change</refname>
          <refpurpose>修订版本属性修改的通知。</refpurpose>
        </refnamediv>
        <refsection>
          <info>
            <title>描述</title>
          </info>
          <para><literal>pre-revprop-change</literal>钩子在修订版本属性修改之前，正常提交范围之外被执行，不象其他钩子，这个钩子默认是拒绝所有的属性修改，钩子必须实际存在并且返回一个零值，这样属性修改才能实现。</para>
          <para>如果<literal>pre-revprop-change</literal>钩子没有实现或返回一个非零值，对属性的修改就不会成功，所有的标准错误输出会返回到客户端。</para>
        </refsection>
        <refsection>
          <info>
            <title>输入参数</title>
          </info>
          <para>传递给你钩子程序的命令行参数，按照顺序是：</para>
          <orderedlist inheritnum="ignore" continuation="restarts">
            <listitem>
              <para>版本库路径</para>
            </listitem>
            <listitem>
              <para>要修改属性的修订版本</para>
            </listitem>
            <listitem>
              <para>企图修改属性的认证用户名</para>
            </listitem>
            <listitem>
              <para>属性名称已修改</para>
            </listitem>
            <listitem>
              <para>变更描述：<literal>A</literal> (添加的)，<literal>D</literal> (删除的)或<literal>M</literal> (修改的)</para>
            </listitem>
          </orderedlist>
          <para>此外，Subversion通过标准输入将属性值传递给钩子程序。</para>
        </refsection>
        <refsection>
          <info>
            <title>普通用户</title>
          </info>
          <para>访问控制；变更确认和控制</para>
        </refsection>
      </refentry>
      <!-- =============================================================== -->
      <refentry xml:id="svn.ref.reposhooks.post-revprop-change">
        <indexterm>
          <primary>版本库</primary>
          <secondary>hooks</secondary>
          <tertiary>post-revprop-change</tertiary>
        </indexterm>
        <refnamediv>
          <refname>post-revprop-change</refname>
          <refpurpose>修订版本属性修改成功的通知</refpurpose>
        </refnamediv>
        <refsection>
          <info>
            <title>描述</title>
          </info>
          <para><literal>post-revprop-change</literal>钩子会在修订版本属性修改后立即执行，在提交范围之外。可以从其对应物<literal>pre-revprop-change</literal>知道，如果没有实现<literal>pre-revprop-change</literal>钩子就不会执行。它通常用来在属性修改后发送邮件通知。</para>
          <para>如果<literal>pre-commit</literal>钩子返回非零值，提交会退出，提交事务被删除，所有标准错误的输出返回到客户端。</para>
        </refsection>
        <refsection>
          <info>
            <title>输入参数</title>
          </info>
          <para>传递给你钩子程序的命令行参数，按照顺序是：</para>
          <orderedlist inheritnum="ignore" continuation="restarts">
            <listitem>
              <para>版本库路径</para>
            </listitem>
            <listitem>
              <para>已经修改属性的修订版本</para>
            </listitem>
            <listitem>
              <para>做出修改的认证用户名</para>
            </listitem>
            <listitem>
              <para>属性名称已修改</para>
            </listitem>
            <listitem>
              <para>变更描述：<literal>A</literal> (添加的)，<literal>D</literal> (删除的)或<literal>M</literal> (修改的)</para>
            </listitem>
          </orderedlist>
          <para>此外，Subversion通过标准输入将属性的前一个值传递给钩子。</para>
        </refsection>
        <refsection>
          <info>
            <title>普通用户</title>
          </info>
          <para>属性修改通知</para>
        </refsection>
      </refentry>
      <!-- =============================================================== -->
      <refentry xml:id="svn.ref.reposhooks.pre-lock">
        <indexterm>
          <primary>版本库</primary>
          <secondary>hooks</secondary>
          <tertiary>pre-lock</tertiary>
        </indexterm>
        <refnamediv>
          <refname>pre-lock</refname>
          <refpurpose>路径锁定尝试的通知。</refpurpose>
        </refnamediv>
        <refsection>
          <info>
            <title>描述</title>
          </info>
          <para><literal>pre-lock</literal>钩子会在每次有人尝试锁定文件时执行，可以防止完全的锁定，或者用来指定控制哪些用户可以锁定特定路径的复杂策略，如果钩子发现已存在的钩子，也可以决定是否<quote>窃取</quote>这个钩子。</para>
          <para>如果<literal>pre-lock</literal>钩子返回非零值，锁定动作会退出，并将标准错误返回到客户端。</para>
        </refsection>
        <refsection>
          <info>
            <title>输入参数</title>
          </info>
          <para>传递给你钩子程序的命令行参数，按照顺序是：</para>
          <orderedlist inheritnum="ignore" continuation="restarts">
            <listitem>
              <para>版本库路径</para>
            </listitem>
            <listitem>
              <para>将要锁定的版本化路径</para>
            </listitem>
            <listitem>
              <para>尝试锁定的认证用户名</para>
            </listitem>
          </orderedlist>
        </refsection>
        <refsection>
          <info>
            <title>普通用户</title>
          </info>
          <para>访问控制</para>
        </refsection>
      </refentry>
      <!-- =============================================================== -->
      <refentry xml:id="svn.ref.reposhooks.post-lock">
        <indexterm>
          <primary>版本库</primary>
          <secondary>hooks</secondary>
          <tertiary>post-lock</tertiary>
        </indexterm>
        <refnamediv>
          <refname>post-lock</refname>
          <refpurpose>成功锁定路径的通知。</refpurpose>
        </refnamediv>
        <refsection>
          <info>
            <title>描述</title>
          </info>
          <para><literal>post-lock</literal>在路径锁定后执行，通常用来发送锁定事件邮件通知。</para>
          <para>如果<literal>pre-lock</literal>钩子返回非零值，锁定动作会退出，并将标准错误返回到客户端。</para>
        </refsection>
        <refsection>
          <info>
            <title>输入参数</title>
          </info>
          <para>传递给你钩子程序的命令行参数，按照顺序是：</para>
          <orderedlist inheritnum="ignore" continuation="restarts">
            <listitem>
              <para>版本库路径</para>
            </listitem>
            <listitem>
              <para>锁定路径的认证用户名</para>
            </listitem>
          </orderedlist>
          <para>此外，锁定路径通过标准输入传递给钩子程序，每行一个路径。</para>
        </refsection>
        <refsection>
          <info>
            <title>普通用户</title>
          </info>
          <para>锁定通知</para>
        </refsection>
      </refentry>
      <!-- =============================================================== -->
      <refentry xml:id="svn.ref.reposhooks.pre-unlock">
        <indexterm>
          <primary>版本库</primary>
          <secondary>hooks</secondary>
          <tertiary>pre-unlock</tertiary>
        </indexterm>
        <refnamediv>
          <refname>pre-unlock</refname>
          <refpurpose>路径解锁尝试的通知。</refpurpose>
        </refnamediv>
        <refsection>
          <info>
            <title>描述</title>
          </info>
          <para><literal>pre-unlock</literal>钩子在某人企图删除一个文件上的钩子时发生，可以用来制定哪些用户可以解除文件锁定的策略。制定破坏锁定的策略非常重要，如果一个用户A锁定了一个文件，允许用户B打开这个锁？如果这个锁已经一周了呢？这种事情可以通过钩子决定并执行。</para>
          <para>如果<literal>pre-unlock</literal>返回非零值，解锁过程就会退出，标准错误返回到客户端。</para>
        </refsection>
        <refsection>
          <info>
            <title>输入参数</title>
          </info>
          <para>传递给你钩子程序的命令行参数，按照顺序是：</para>
          <orderedlist inheritnum="ignore" continuation="restarts">
            <listitem>
              <para>版本库路径</para>
            </listitem>
            <listitem>
              <para>将要锁定的版本化路径</para>
            </listitem>
            <listitem>
              <para>尝试锁定的认证用户名</para>
            </listitem>
          </orderedlist>
        </refsection>
        <refsection>
          <info>
            <title>普通用户</title>
          </info>
          <para>访问控制</para>
        </refsection>
      </refentry>
      <!-- =============================================================== -->
      <refentry xml:id="svn.ref.reposhooks.post-unlock">
        <indexterm>
          <primary>版本库</primary>
          <secondary>hooks</secondary>
          <tertiary>post-unlock</tertiary>
        </indexterm>
        <refnamediv>
          <refname>post-unlock</refname>
          <refpurpose>路径成功解锁的通知。</refpurpose>
        </refnamediv>
        <refsection>
          <info>
            <title>描述</title>
          </info>
          <para><literal>post-unlock</literal>在一个或多个路径已经被解锁后执行，通常用来发送解锁事件通知邮件。</para>
          <para>如果<literal>pre-unlock</literal>返回非零值，解锁过程就会退出，标准错误返回到客户端。</para>
        </refsection>
        <refsection>
          <info>
            <title>输入参数</title>
          </info>
          <para>传递给你钩子程序的命令行参数，按照顺序是：</para>
          <orderedlist inheritnum="ignore" continuation="restarts">
            <listitem>
              <para>版本库路径</para>
            </listitem>
            <listitem>
              <para>路径解锁的认证用户名</para>
            </listitem>
          </orderedlist>
          <para>此外，解锁路径通过标准输入传递给钩子程序，每行一个路径。</para>
        </refsection>
        <refsection>
          <info>
            <title>普通用户</title>
          </info>
          <para>解锁通知</para>
        </refsection>
      </refentry>
    </section>
  </chapter>
  <!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
  <appendix xml:id="svn.intro">
    <info>
      <title>Subversion 快速入门指南</title>
    </info>
    <para>如果你渴望快速配置Subversion并运行(而且你喜欢通过实验学习)，本章会展示如何创建版本库，导入代码，然后以工作拷贝检出，继续我们会给出本书的相关章节的链接。</para>
    <warning>
      <para>如果读者还不熟悉版本控制，以及在Subversion和CVS中使用的<quote>拷贝-修改-合并</quote>模型这些基础的概念，那么建议在进一步学习之前，首先阅读<xref linkend="svn.basic"/>。</para>
    </warning>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.intro.install">
      <info>
        <title>安装 Subversion</title>
      </info>
      <para>Subversion是基于APR构建的。APR全称为Apache Portable Runtime library，是一个移植性很好的程序库。APR库提供了全部与操作系统相关的操作接口，如磁盘访问、内存管理等等，这使得Subversion自身能够在不加修改的情况下运行于不同的操作系统之上。Subversion对APR的依赖并不意味着必须使用Apache作为它的网络服务器程序，相反，Apache只是Subversion支持的网络服务器程序之一。APR是一个独立的程序库，任何应用程序都可以使用它(Apache也是基于它开发的)。这就是说，Subversion能够在所有可运行Apache服务器的操作系统上运转，如Windows、Linux、各种BSD、Mac OS X、Netware等等。</para>
      <para>最简单的安装Subversion的方法就是下载与你的操作系统对应的二进制程序包。在Subversion的网站(<uri href="http://subversion.tigris.org">http://subversion.tigris.org</uri>)上通常可以找到由志愿者提供下载的程序包。在这个网站上，会提供微软操作系统上的图形化应用程序安装包。而对于类Unix系统，则可以使用其自身的程序包系统(PRMs、DEBs、ports tree等等)来获取Subversion。</para>
      <para>此外，还可以通过编译源代码包直接生成Subversion程序，尽管这不是一件简单的任务(如果你没有构建过开源软件包，你最好下载二进制发布版本)。首先，从Subversion网站下载最新的源代码包，然后解压缩。然后，根据<filename>INSTALL</filename>文件的指示进行编译。需要注意的是，正式发布的源代码包中可能没有包含构建命令行客户端工具所需的全部内容，从Subversion1.4开始，所有依赖的库(如apr，apr-util和neno库)以<filename>-deps</filename>为名称单独发布，这些库应该可以满足你在你的系统上的安装，你需要将依赖库解压缩到Subversion源程序相同的目录。但是一些可选的组件则依赖于其它一些程序库，如Berkeley DB和Apache httpd。因此，如果想要进行完整的编译，请根据<filename>INSTALL</filename>文件中的内容确认这些程序库是否可用。</para>
      <para>如果你是一个喜欢使用最新软件的人，你可以从Subversion本身的版本库得到Subversion最新的源代码，显然，你首先需要一个Subversion客户端，有了之后，你就可以从<uri href="http://svn.collab.net/repos/svn/trunk/">http://svn.collab.net/repos/svn/trunk/</uri>检出一个Subversion源代码的工作拷贝：<footnote><para>注意上面例子中检出的URL并不是以<literal>svn</literal>结尾，而是它的一个叫做<literal>trunk</literal>的子目录，可以看我们对Subversion的分支和标签模型的讨论来理解背后的原因。</para></footnote></para>
      <screen>
$ svn checkout http://svn.collab.net/repos/svn/trunk subversion
A    subversion/HACKING
A    subversion/INSTALL
A    subversion/README
A    subversion/autogen.sh
A    subversion/build.conf
…
</screen>
      <para>上面的命令会检出一个流血的，最新的Subversion源代码版本到你的叫做<filename>subversion</filename>的当前工作目录。很明显，你可以调整最后的参数改为你需要的。不管你怎么称呼你的新的工作拷贝目录，在操作之后，你现在已经有了Subversion的源代码。当然，你还是需要得到一些帮助库(apr，apr-util等等)—见工作拷贝根目录的<filename>INSTALL</filename>来得到更多细节。</para>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.intro.quickstart">
      <info>
        <title>快速指南</title>
      </info>
      <blockquote>
        <para>
          <quote>请确定你坐在了正确的位置，你的盘桌已经关闭，乘务员们，准备起飞…。</quote>
        </para>
      </blockquote>
      <para>这是一个非常高层次的教程，能够帮助你熟悉Subversion的基本配置和操作，在结束这个教程时，你一定能够对Subversion的典型使用有了一个基础的认识。</para>
      <note>
        <para>运行下面的例子需要首先正确安装Subversion客户端程序<command>svn</command>以及管理工具<command>svnadmin</command>，并且必须为1.2或更新版本的Subversion程序(可以运行<command>svn --version</command>来检查Subversion的版本。)</para>
      </note>
      <para>Subversion的所有版本化数据都储存在中心版本库中。因此首先，我们需要创建一个版本库：</para>
      <screen>
$ svnadmin create /var/svn/repos
$ ls /var/svn/repos
conf/  dav/  db/  format  hooks/  locks/  README.txt
</screen>
      <para>这个命令创建了一个新目录<filename>/var/svn/repos</filename>，并在其中创建了一个Subversion版本库。这个目录里主要保存了一些数据库文件(还有其它一些文件)，而不像CVS那样保存着版本化的文件。需要更多版本库创建和维护方面的内容，参见<xref linkend="svn.reposadmin"/>。</para>
      <para>在Subversion没有<quote>项目</quote>的概念。Subversion的版本库只是一个虚拟的版本化文件系统，可以存放你想要存放的任何文件。有些管理员喜欢为每个项目建立一个独立的版本库，而另外一些管理员则喜欢将多个项目存放到同一个版本库的不同目录里。这两种方式各有各的优点，关于这方面内容的叙述，参见<xref linkend="svn.reposadmin.projects.chooselayout"/>。不论是哪一种方式，版本库都只是负责管理文件和目录，而<quote>项目</quote>则是人为指定的概念。因此，尽管本书中遍布着项目这个词，但是请记住我们只不过是在谈论版本库中的某些特定目录(或者是一组目录)。</para>
      <para>在这个例子中，我们假定已经有一些需要导入到Subversion版本库的条目(一组文件和目录)。接下来，我们需要把这些条目整理到一个名为<filename>myproject</filename>的目录(或者其它任意目录)里。在这个目录下，创建三个顶级子目录：<filename>branches</filename>、<filename>tags</filename>和<filename>trunk</filename>，这样做的原因将在后文中阐述。之后，将所有需版本化的数据保存到<filename>trunk</filename>目录下，同时保持<filename>branches</filename>和<filename>tags</filename>目录为空：</para>
      <screen>
/tmp/myproject/branches/
/tmp/myproject/tags/
/tmp/myproject/trunk/
                     foo.c
                     bar.c
                     Makefile
                     …
</screen>
      <para><filename>branches</filename>、<filename>tags</filename>和<filename>trunk</filename>这三个子目录不是Subversion必须的。但这样做是Subversion的习惯用法，我们还是遵守这个约定吧。</para>
      <para>准备好了数据之后，就可以使用<command>svn import</command>命令(参见<xref linkend="svn.tour.importing"/>)将其导入到版本库中：</para>
      <screen>
$ svn import /tmp/myproject file:///var/svn/repos/myproject -m "initial import"
Adding         /tmp/myproject/branches
Adding         /tmp/myproject/tags
Adding         /tmp/myproject/trunk
Adding         /tmp/myproject/trunk/foo.c
Adding         /tmp/myproject/trunk/bar.c
Adding         /tmp/myproject/trunk/Makefile
…
Committed revision 1.
$ 
</screen>
      <para>现在版本库中已经保存了目录中的数据。如前所述，直接查看版本库是看不到文件和目录的；它们存放在数据库之中。但是版本库的虚拟文件系统中则包含了一个名为<filename>myproject</filename>的顶级目录，其中依此保存了所有的数据。</para>
      <para>注意我们在一开始创建的那个<filename>/tmp/myproject</filename>目录并没有改变，Subversion并不在意它(事实上，完全可以删除这个目录)。要开始使用版本库数据，我们还要创建一个新的用于存储数据的<quote>工作拷贝</quote>，这是一个私有工作区。从Subversion版本库里<quote>检出</quote>一个<filename>myproject/trunk</filename>目录工作拷贝的操作如下：</para>
      <screen>
$ svn checkout file:///var/svn/repos/myproject/trunk myproject
A  myproject/foo.c
A  myproject/bar.c
A  myproject/Makefile
…
Checked out revision 1.
</screen>
      <para>现在，在<filename>myproject</filename>目录下生成了一个版本库数据的独立拷贝。我们可以在这个工作拷贝中编辑文件，并将修改提交到版本库中。</para>
      <itemizedlist>
        <listitem>
          <para>进入工作拷贝目录，编辑某个文件的内容。</para>
        </listitem>
        <listitem>
          <para>运行<command>svn diff</command>以标准差别格式查看修改的内容。</para>
        </listitem>
        <listitem>
          <para>运行<command>svn commit</command>将更改提交到版本库中。</para>
        </listitem>
        <listitem>
          <para>运行<command>svn update</command><quote>更新</quote>工作拷贝。</para>
        </listitem>
      </itemizedlist>
      <para>完整的工作拷贝操作指南，请参见<xref linkend="svn.tour"/>。</para>
      <para>现在，Subversion版本库可以通过网络方式访问。参考<xref linkend="svn.serverconfig"/>，了解不同服务器软件的使用以及配置方法。</para>
      <!-- ### TODO: Let's make this into a full tutorial, rather than
             simply referring off to other sections. ### -->
    </section>
  </appendix>
  <!--
local variables: 
sgml-parent-document: ("book.xml" "appendix")
end:
-->
  <appendix xml:id="svn.forcvs">
    <info>
      <title>CVS 用户的 Subversion 指南</title>
    </info>
    <para>这个附录可以作为CVS用户开始使用Subversion的指南，实质上就是鸟瞰这两个系统之间的区别列表，在每一小节，我们会尽可能提供相关章节的引用。</para>
    <para>尽管Subversion的目标是接管当前和未来的CVS用户基础，需要一些新的特性设计来修正一些CVS<quote>不好的</quote>行为习惯，这意味着，作为一个CVS用户，你或许需要打破习惯—忘记一些奇怪的习惯来作为开始。</para>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.forcvs.revnums">
      <info>
        <title>版本号现在不同了</title>
      </info>
      <para>在CVS中，修订版本号是每文件的，这是因为CVS使用RCS文件保存数据，每个文件都在版本库有一个对应的RCS文件，版本库几乎就是根据项目树的结构创建。</para>
      <para>在Subversion，版本库看起来像是一个单独的文件系统，每次提交导致一个新的文件系统；本质上，版本库是一堆树，每棵树都有一个单独的修订版本号。当有人谈论<quote>修订版本54</quote>时，他们是在讨论一个特定的树(并且间接来说，文件系统在提交54次之后的样子)。</para>
      <para>技术上讲，谈论<quote>文件<filename>foo.c</filename>的修订版本5</quote>是不正确的，相反，一个人会说<quote><filename>foo.c</filename>在修订版本5出现</quote>。同样，我们在假定文件的进展时也要小心，在CVS，文件<filename>foo.c</filename>的修订版本5和6一定是不同的，在Subversion，<filename>foo.c</filename>可能在修订版本5和6之间<emphasis>没有</emphasis>改变。</para>
      <para>类似的，在CVS中标签或分支是文件的一种标注，或者是单个文件的版本信息，而在Subversion中，标签和分支是整个目录树的拷贝(为了方便，进入版本库顶级目录的<filename>/branches</filename>或<filename>/tags</filename>子目录，<filename>/trunk</filename>旁边)。版本库作为一个整体，每个文件的许多版本可见：每个分支的最新版本，每个标签的最新版本以及trunk本身的最新版本。所以，我们再精炼一下术语，我们说<quote><filename>foo.c</filename>在修订版本5出现在<filename>/branches/REL1</filename>。</quote></para>
      <para>更多细节见<xref linkend="svn.basic.in-action.revs"/>.</para>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.forcvs.directories">
      <info>
        <title>目录的版本</title>
      </info>
      <para>Subversion会记录目录树的结构，不仅仅是文件的内容。这是编写Subversion替代CVS最重要的一个原因。</para>
      <para>以下是对你这意味着什么的说明，作为一个前CVS用户：</para>
      <itemizedlist>
        <listitem>
          <para><command>svn add</command>和<command>svn delete</command>现在也工作在目录上了，就像在文件上一样，还有<command>svn copy</command>和<command>svn move</command>也一样。然而，这些命令<emphasis>不</emphasis>会导致版本库即时的变化，相反，工作的项目只是<quote>预定要</quote>添加和删除，在运行<command>svn commit</command>之前没有版本库的修改。</para>
        </listitem>
        <listitem>
          <para>目录不再是哑容器了；它们也有文件一样的修订版本号。(更准确一点，谈论<quote>修订版本5的目录<filename>foo/</filename></quote>是正确的。)</para>
        </listitem>
      </itemizedlist>
      <para>让我们再讨论一下最后一点，目录版本化是一个困难的问题；因为我们希望允许混合修订版本的工作拷贝，有一些防止我们滥用这个模型的限制。</para>
      <para>从理论观点，我们定义<quote>目录<filename>foo</filename>的修订版本5</quote>意味着一组目录条目和属性。现在假定我们从<filename>foo</filename>开始添加和删除文件，然后提交。如果说我们还有<filename>foo</filename>的修订版本5就是一个谎言。然而，如果说我们在提交之后增加了一位<filename>foo</filename>的修订版本号码，这也是一个谎言；<filename>foo</filename>还有一些修改我们没有得到，因为我们还没有更新。</para>
      <para>Subversion通过在<filename>.svn</filename>区域偷偷的纪录添加和删除来处理这些问题，当你最后运行<command>svn update</command>，所有的账目会到版本库结算，并且目录的新修订版本号会正确设置。<emphasis>因此，只有在更新之后才可以真正安全地说我们有了一个<quote>完美的</quote>修订版本目录。</emphasis>在大多数时候，你的工作拷贝会保存<quote>不完美的</quote>目录修订版本。</para>
      <para>同样的，如果你尝试提交目录的属性修改会有一个问题，通常情况下，提交应该会提高工作目录的本地修订版本号，但是再一次，这还是一个谎言，因为这个目录还没有添加和删除发生，因为还没有更新发生。<emphasis>因此，在你的目录不是最新的时候不允许你提交属性修改。</emphasis></para>
      <para>关于目录版本的更多讨论见<xref linkend="svn.basic.in-action.mixedrevs"/>。</para>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.forcvs.disconnected">
      <info>
        <title>更多离线操作</title>
      </info>
      <para>近些年来，磁盘空间变得异常便宜和丰富，但是网络带宽还没有，因此Subversion工作拷贝为紧缺资源进行了优化。</para>
      <para><filename>.svn</filename>管理目录维护者与<filename>CVS</filename>同样的功能，除了它还保存了只读的文件<quote>原始</quote>拷贝，这允许你做许多离线操作：</para>
      <variablelist>
        <varlistentry>
          <term>
            <command>svn status</command>
          </term>
          <listitem>
            <para>显示你所做的本地修改(见<xref linkend="svn.tour.cycle.examine.status"/>)</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <command>svn diff</command>
          </term>
          <listitem>
            <para>显示修改的详细信息(见see <xref linkend="svn.tour.cycle.examine.diff"/>)</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <command>svn revert</command>
          </term>
          <listitem>
            <para>删除你的本地修改(见<xref linkend="svn.tour.cycle.revert"/>)</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>另外，原始文件的缓存允许Subversion客户端在提交时只提交区别，这是CVS做不到的。</para>
      <para>列表中最后一个子命令—<command>svn revert</command>—是新的；它不仅仅删除本地修改，也会取消如增加和删除的预定操作，这是恢复文件推荐的方式；删除文件，然后运行<command>svn update</command>还可以工作，但是这样侮辱了更新操作的作用，而且，我们在这个主题…</para>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.forcvs.status-vs-update">
      <info>
        <title>区分状态和更新</title>
      </info>
      <para>在Subversion，我们已经设法抹去<command>cvs status</command>和<command>cvs update</command>之间的混乱。</para>
      <para><command>cvs status</command>命令有两个目的：第一，显示用户在工作拷贝的所有本地修改，第二，显示给用户哪些文件是最新的。很不幸，因为CVS难以阅读的状态输出，许多CVS用户并没有充分利用这个命令的好处。相反，他们慢慢习惯运行<command>cvs update</command>或<command>cvs -n update</command>来快速查看区别，如果用户忘记使用<option>-n</option>选项，副作用就是将还没有准备好处理的版本库修改合并到工作拷贝。</para>
      <para>对于Subversion，我们通过修改<command>svn status</command>的输出使之同时满足阅读和解析的需要来努力消除这种混乱，同样，<command>svn update</command>只会打印将要更新的文件信息，而<emphasis>不是</emphasis>本地修改。</para>
      <section xml:id="svn.forcvs.status-vs-update.status">
        <info>
          <title>状态</title>
        </info>
        <para><command>svn status</command>打印所有本地修改的文件，缺省情况下，不会联系版本库，然而这个命令接受一些选项，如下是一些最常用的：</para>
        <variablelist>
          <varlistentry>
            <term>
              <option>-u</option>
            </term>
            <listitem>
              <para>访问版本库检测并显示过期的信息。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>-v</option>
            </term>
            <listitem>
              <para>显示<emphasis>所有</emphasis>版本控制下的文件。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <option>-N</option>
            </term>
            <listitem>
              <para>非递归方式运行(不会访问子目录)。</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <para><command>status</command>命令有两种输出格式，缺省是<quote>短</quote>格式，本地修改像这样：</para>
        <screen>
$ svn status
M      foo.c
M      bar/baz.c
</screen>
        <para>如果你指定<option>--show-updates</option>(<option>-u</option>)选项，就会使用较长的格式输出：</para>
        <screen>
$ svn status -u
M            1047   foo.c
       *     1045   faces.html
       *            bloo.png
M            1050   bar/baz.c
Status against revision:   1066
</screen>
        <para>在这个例子里，出现了两列，第二列的星号表示了文件或目录是否过期，第三列显示了工作拷贝修订版本号，在上面的例子里，星号表示如果进行更新，<filename>faces.html</filename>会被合并，而<filename>bloo.png</filename>则是版本库新加的文件。(<filename>bloo.png</filename>前面的修订版本号为空表示了这个文件在工作拷贝已经不存在了。)</para>
        <!-- ###TODO describe -v here as well as -uv. -u and -v use
           different <quote>long</quote> formats and need to be
           documented separately.  Moreover, as you can combine -u and
           -v, it needs to be explained what each of them does.  As -u is
           much more important than -v, and the example following that
           paragraph *is* about -u, not -v, my patch concentrated on
           that. -->
        <para>此刻，你必须赶快看一下<xref linkend="svn.ref.svn.c.status"/>中所说的可能属性代码，下面是一些你会看到的常用状态代码：</para>
        <screen>
A    Resource is scheduled for Addition
D    Resource is scheduled for Deletion
M    Resource has local Modifications
C    Resource has Conflicts (changes have not been completely merged
       between the repository and working copy version)
X    Resource is eXternal to this working copy (may come from another
       repository).  See <xref linkend="svn.advanced.externals"/>
?    Resource is not under version control
!    Resource is missing or incomplete (removed by another tool than
       Subversion)
</screen>
        <para>关于<command>svn status</command>的详细讨论，见<xref linkend="svn.tour.cycle.examine.status"/>。</para>
      </section>
      <section xml:id="svn.forcvs.status-vs-update.update">
        <info>
          <title>更新</title>
        </info>
        <para><command>svn update</command>会更新你的工作拷贝，只打印这次更新的文件。</para>
        <para>Subversion将CVS的<literal>P</literal>和<literal>U</literal>合并为<literal>U</literal>，当合并或冲突发生时，Subversion会简单的打印<literal>G</literal>或<literal>C</literal>，而不是大段相关内容。</para>
        <para>关于<command>svn update</command>的详细讨论，见<xref linkend="svn.tour.cycle.update"/>。</para>
      </section>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.forcvs.branches-and-tags">
      <info>
        <title>分支和标签</title>
      </info>
      <para>Subversion不区分文件系统空间和<quote>分支</quote>空间；分支和标签都是普通的文件系统目录，这恐怕是CVS用户需要逾越的最大心理障碍，所有信息在<xref linkend="svn.branchmerge"/>。</para>
      <warning>
        <para>因为Subversion把分支和标签看作普通目录看待，你项目不同的开发线存在于主项目目录的不同子目录里。所以要记住检出你所要的保存特定开发线的子目录，而不是项目的根目录。如果你错误的检出了项目本身，你会紧张的发现你的项目拷贝包含了所有的分支和标签。<footnote><para>如果在检出完成之前没有消耗完磁盘空间的话。</para></footnote></para>
      </warning>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.forcvs.properties">
      <info>
        <title>元数据属性</title>
      </info>
      <para>Subversion的一个新特性就是你可以对文件和目录任意附加元数据(或者是<quote>属性</quote>)，属性是关联在工作拷贝文件或目录的任意名称/值对。</para>
      <para>为了设置或得到一个属性名称，使用<command>svn propset</command>和<command>svn propget</command>子命令，列出对象所有的属性，使用<command>svn proplist</command>。</para>
      <para>更多信息见<xref linkend="svn.advanced.props"/>。</para>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.forcvs.conflicts">
      <info>
        <title>解决冲突</title>
      </info>
      <para>CVS使用内联<quote>冲突标志</quote>来标记冲突，并且在更新时打印<literal>C</literal>。历史上讲，这导致了许多问题，因为CVS做得还不够。许多用户在它们快速闪过终端时忘记(或没有看到)<literal>C</literal>，即使出现了冲突标记，他们也经常忘记，然后提交了带有冲突标记的文件。</para>
      <para>Subversion solves this problem in a pair of ways.  First,
      when a conflict occurs in a file, Subversion records the fact
      that the file is in a state of conflict, and won't allow you to
      commit changes to that file until you explicitly resolve the
      conflict.  Second, Subversion 1.5 provides interactive
      conflict resolution, which allows you to resolve conflicts as
      they happen instead of having to go back and do so after the
      update or merge operation completes.  See <xref linkend="svn.tour.cycle.resolve"/> for more about conflict
      resolution in Subversion.</para>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.forcvs.binary-and-trans">
      <info>
        <title>二进制文件和行结束标记转换</title>
      </info>
      <para>在大多数情况下，Subversion比CVS更好的处理二进制文件，因为CVS使用RCS，它只可以存储二进制文件的完整拷贝，但是，Subversion使用二进制区别算法来表示文件的区别，而不管文件是文本文件还是二进制文件。这意味着所有的文件是以增量的(压缩的)形式存放在版本库。</para>
      <para>CVS用户需要使用<option>-kb</option>选项来标记二进制文件，防止数据的混淆(因为关键字解释和行结束转化)，他们有时候会忘记这样做。</para>
      <para>Subversion使用更加异想天开的方法—第一，如果你不明确的告诉它(详情见<xref linkend="svn.advanced.props.special.keywords"/>和<xref linkend="svn.advanced.props.special.eol-style"/>)这样做，它不会做任何关键字或行结束转化的操作，缺省情况下Subversion会把所有的数据看作字节串，所有的储存在版本库的文件都处于未转化的状态。</para>
      <para>第二，Subversion维护了一个内部的概念来区别一个文件是<quote>文本</quote>还是<quote>二进制</quote>文件，但这个概念<emphasis>只</emphasis>在工作拷贝非常重要，在<command>svn update</command>，Subversion会对本地修改的文本文件执行上下文的合并，但是对二进制文件不会。</para>
      <para>为了检测一个上下文的合并是可能的，Subversion检测<literal>svn:mime-type</literal>属性，如果没有<literal>svn:mime-type</literal>属性，或者这个属性是文本的(例如<literal>text/*</literal>)，Subversion会假定它是文本的，否则Subversion认为它是二进制文件。Subversion也会在<command>svn import</command>和<command>svn add</command>命令时通过运行一个二进制检测算法来帮助用户。这些命令会做出很好的猜测，然后(如果可能)设置添加文件的<literal>svn:mime-type</literal>属性。(如果Subversion猜测错误，用户可以删除或手工编辑这个属性。)</para>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.forcvs.modules">
      <info>
        <title>版本化的模块</title>
      </info>
      <para>不像CVS，Subversion工作拷贝会意识到它检出了一个模块，这意味着如果有人修改了模块的定义(例如添加和删除组件)，然后一个对<command>svn update</command>的调用会适当的更新工作拷贝，添加或删除组件。</para>
      <para>Subversion定义了模块作为一个目录属性的目录列表：见<xref linkend="svn.advanced.externals"/>。</para>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.forcvs.auth">
      <info>
        <title>认证</title>
      </info>
      <para>通过CVS的pserver，你需要在读写操作之前<quote>登陆</quote>到服务器(使用<command>cvs login</command>命令)—即使是匿名操作。Subversion版本库使用Apache的<command>httpd</command>或<command>svnserve</command>作为服务器，你不需要开始时提供认证凭证—如果一个操作需要认证，服务器会要求你的凭证(不管这凭证是用户名与密码，客户证书还是两个都有)。所以如果你的工作拷贝是全局可读的，在所有的读操作中不需要任何认证。</para>
      <para>相对于CVS，Subversion会一直在磁盘(在你的<filename>~/.subversion/auth/</filename>目录)缓存凭证，除非你通过<option>--no-auth-cache</option>选项告诉它不这样做。</para>
      <para>这个行为也有例外，当使用SSH管道的<command>svnserve</command>服务器时，使用<literal>svn+ssh://</literal>的URL模式这种情况下，<command>ssh</command>会在通道刚开始时无条件的要求认证。</para>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.forcvs.convert">
      <info>
        <title>迁移 CVS 版本库到 Subversion</title>
      </info>
      <para>或许让CVS用户熟悉Subversion最好的办法就是让他们的项目继续在新系统下工作，这可以简单得通过平淡的把CVS版本库的导出数据导入到Subversion完成，或者是更加完全的方案，不仅仅包括最新数据快照，还包括所有的历史，从一个系统到另一个系统。这是一个非常困难的问题，包括推导保持原子性的修改集，转化两个系统完全不同的分支政策。但是我们还是有许多工具声称至少部分具备了的转化已存在的CVS版本库为Subversion版本库的能力。</para>
      <para>最流行的(好像是最成熟的)转化工具是cvs2svn(<uri href="http://cvs2svn.tigris.org/">http://cvs2svn.tigris.org/</uri>)，它是最初由Subversion自己的开发社区成员开发的一个Python脚本：它会多次扫描你的CVS版本库，并尽可能尝试推断提交，分支和标签，当它结束时，结果是可以代表代码历史的Subversion版本库或可移植的Subversion转储文件，关于指令和警告的详细信息可以看网站。</para>
    </section>
  </appendix>
  <!--
local variables: 
sgml-parent-document: ("book.xml" "appendix")
end:
-->
  <appendix xml:id="svn.webdav">
    <info>
      <title>WebDAV 和自动版本</title>
    </info>
    <para>WebDAV是HTTP的一个扩展，作为一个文件共享的标准不断发展。当今的操作系统变得极端的web化，许多内置了对装配WebDAV服务器导出的<quote>共享</quote>的支持。</para>
    <para>如果你使用Apache/mod_dav_svn作为你的Subversion网络服务器，某种程度上，你也是在运行一个WebDAV服务器。这个附录提供了这种协议一些背景知识，Subversion如何使用它，Subversion如何和认识WebDAV的软件交互工作。</para>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.webdav.basic">
      <info>
        <title>什么是 WebDAV？</title>
      </info>
      <para><firstterm>DAV</firstterm>的意思是<quote>Distributed Authoring and Versioning</quote>。RFC 2518为HTTP 1.1定义了一组概念和附加扩展方法来把web变成一个更加普遍的读/写媒体，基本思想是一个WebDAV兼容的web服务器可以像普通的文件服务器一样工作；客户端可以通过HTTP装配类似于NFS或SMB的WebDAV共享文件夹。</para>
      <para>悲惨的是，RFC规范并没有提供任何版本控制模型。基本的DAV客户端和服务器只是假定每个文件或目录只有一个版本存在，可以重复的覆盖。</para>
      <para>因为RFC 2518漏下了版本概念，几年之后，另一个委员会留下来负责撰写RFC 3253来添加WebDAV的版本化，也就是<quote>DeltaV</quote>。WebDAV/DeltaV客户端和服务器经常叫做<quote>DeltaV</quote>客户端和服务器，因为DeltaV暗含了基本的WebDAV。</para>
      <para>最初的WebDAV标准得到了广泛的成功，所有的现代操作系统拥有内置的(后面有详细资料)对普通WebDAV的支持，许多流行的应用程序也可以使用WebDAV—Microsoft Office，Dreamweaver和Photoshop。在服务器方面，Apache从1998年就开始支持WebDAV，并被认为是一个事实上的开源标准，也有许多商业的WebDAV服务器，例如Microsoft的IIS。</para>
      <para>不幸的是，DeltaV没有这样的成功，很难寻找到任何DeltaV客户端和服务器。只有一些不太出名的商业产品，因此很难测试交互性，不清楚为什么DeltaV还这样停滞，一些人说规范太复杂了，还有些人认为尽管DeltaV的特性有很大的吸引力(即使最新的技术用户也喜欢使用网络文件共享)，版本控制特性对大多数用户还不是这样有趣和必须。最后，有些人认为DeltaV还这样不流行主要是因为一直没有开源的服务器产品实现它。</para>
      <para>当Subversion还在设计阶段时，使用Apache的httpd作为主要网络服务器就是一个很好的想法，已经有了支持WebDAV服务的模块(<command>mod_dav_svn</command>)。DeltaV有一个很新的规范，希望就是Subversion服务器模块最终能够成为一个开源的DeltaV参考实现，但非常不幸，DeltaV得版本模型过于详细，与Subversion的模型并不匹配，虽然有些概念可以对应起来，但有些则不能。</para>
      <para>这是什么意思呢？</para>
      <para>首先，Subversion客户端不是一个完全实现的DeltaV客户端，它需要从服务器得到DeltaV不能提供的东西，因此非常依赖于只有<command>mod_dav_svn</command>理解的Subversion特定的<literal>REPORT</literal>请求。</para>
      <para>其次，<command>mod_dav_svn</command>不是一个完全的DeltaV服务，许多与Subversion不相关的DeltaV规范还没有实现。</para>
      <para>在开发者社区一直有这样的讨论，是否值得弥补这种形势。改变Subversion的设计来匹配DeltaV看起来并不现实，所以可能没有办法让客户端从普通的DeltaV服务器上得到所有的东西。另一方面，mod_dav_svn<emphasis>可以</emphasis>继续开发来实现所有的DeltaV，但缺乏这样做的动力—几乎没有能与之交户的DeltaV客户端。</para>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.webdav.autoversioning">
      <info>
        <title>自动版本化</title>
      </info>
      <para>因为Subversion客户端不是完整的DeltaV客户端，Subversion服务器也不是完整的DeltaV服务器，但仍有值得高兴的交互特性：叫做<firstterm>自动版本化</firstterm>。</para>
      <para>自动版本化是DeltaV标准中的可选特性，一个典型的DeltaV服务器会拒绝一个对版本控制之下文件的<literal>PUT</literal>操作，为了修改一个版本控制下的文件，服务器只会接受一系列正确的版本请求：例如<literal>MKACTIVITY</literal>、<literal>CHECKOUT</literal>、<literal>PUT</literal>和<literal>CHECKIN</literal>。但是如果DeltaV服务器支持自动版本化，服务器可以在后台假装客户端执行了一些列正确的版本请求，也就是说，DeltaV服务器可以与一个对版本化一无所知的普通WebDAV客户端交互。</para>
      <para>因为有许多操作系统已经集成了WebDAV客户端，这个特性的用例可能是这样的：假设一个办公室有许多使用Microsoft Windows或Mac OS的普通用户，每个用户<quote>装载</quote>了一个Subversion版本库，看起来就是普通的网络共享文件夹。他们像普通目录一样的操作这个目录：打开文件、编辑它们，保存它们。同时，服务器自动的版本化所有的东西，任何管理员(或有知识的用户)可以一直使用Subversion客户端来查询历史来检索旧版本的数据。</para>
      <para>这个场景不是小说：对于Subversion 1.2来说，是真实的和有效的。为了激活<command>mod_dav_svn</command>的自动版本化，需要使用<filename>httpd.conf</filename>中Location区块的<literal>SVNAutoversioning</literal>指示，例如：</para>
      <screen>
&lt;Location /repos&gt;
  DAV svn
  SVNPath /var/svn/repository
  SVNAutoversioning on
&lt;/Location&gt;
</screen>
      <para>当激活了SVNAutoversioning，来自WebDAV的客户端请求会导致自动提交，每个修订版本会自动附加一个原始的日志信息。</para>
      <para>然而，在激活这个特性之前，需要理解你做的事情。WebDAV会做许多写请求，导致了产生数量<emphasis>非常多</emphasis>的自动提交修订版本。例如，当保存数据，许多客户端会使用一个<literal>PUT</literal>一个0字节的文件，然后紧跟一个<literal>PUT</literal>真实的文件数据。一个单独的文件写操作产生了两个不同的提交。考虑到许多应用程序隔几分钟的自动保存，会产生更多的提交。</para>
      <para>如果你有发送邮件的post-commit钩子程序，例如，你会根据是否有价值来开启和关闭邮件通知，另外，一个聪明的post-commit钩子也应该能够区分自动版本化和<command>svn commit</command>产生的事务。技巧就是检查修订版本的<literal>svn:autoversioned</literal>属性，如果有，则提交来自一个原始的WebDAV客户端。</para>
      <para>另一个作为<literal>SVNAutoversioning</literal>特性补充的特性来自Apache的<literal>mod_mime</literal>模块，如果一个原始的WebDAV客户端在版本库添加了一个新文件，用户就没有机会设置<literal>svn:mime-type</literal>属性，这会导致使用WebDAV共享目录查看时会看到原始的图标，而没有关联到任何应用。一个补救办法就是让系统管理员(或其他理解Subversion)的人检出一份工作拷贝，然后为需要的文件手动设置<literal>svn:mime-type</literal>属性，但是这个整理工作永远不会结束，作为替代，你可以在你的Subversion<literal>&lt;Location&gt;</literal>区使用<literal>ModMimeUsePathInfo</literal>指示：</para>
      <screen>
&lt;Location /repos&gt;
  DAV svn
  SVNPath /var/svn/repository
  SVNAutoversioning on

  ModMimeUsePathInfo on

&lt;/Location&gt;
</screen>
      <para>这个指示允许<literal>mod_mime</literal>在使用自动版本化添加新文件时尝试自动检测新文件的mime-type，这个模块查看文件的扩展名，有可能的话还包括检查内容；如果文件符合某个常用模式，就会自动设置文件的<literal>svn;mime-type</literal>。</para>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.webdav.clients">
      <info>
        <title>客户端交互性</title>
      </info>
      <para>所有的WebDAV客户端分为三类—独立应用程序，文件浏览器扩展或文件系统实现，这些分类定义了WebDAV用户可用的功能性。<xref linkend="svn.webdav.clients.tbl-1"/>给WebDAV常见软件进行了分类，并提供了的简短描述。这些软件支持的细节，以及总体的分类，可以在本章后面找到。</para>
      <table xml:id="svn.webdav.clients.tbl-1">
        <info>
          <title>常用的 WebDAV 客户端</title>
        </info>
        <tgroup cols="6">
          <thead>
            <row>
              <entry>软件</entry>
              <entry>类型</entry>
              <entry>Windows</entry>
              <entry>Mac</entry>
              <entry>Linux</entry>
              <entry>描述</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>Adobe Photoshop</entry>
              <entry>独立的WebDAV应用程序</entry>
              <entry>X</entry>
              <entry/>
              <entry/>
              <entry>图像编辑软件，允许直接从WebDAV的URL打开文件和修改。</entry>
            </row>
            <row>
              <entry>Cadaver</entry>
              <entry>独立的WebDAV应用程序</entry>
              <entry/>
              <entry>X</entry>
              <entry>X</entry>
              <entry>命令行的WebDAV客户端，支持文件传输，目录树显示和锁定操作</entry>
            </row>
            <row>
              <entry>DAV Explorer</entry>
              <entry>独立的WebDAV应用程序</entry>
              <entry>X</entry>
              <entry>X</entry>
              <entry>X</entry>
              <entry>浏览WebDAV共享的Java GUI工具</entry>
            </row>
            <row>
              <entry>Macromedia Dreamweaver</entry>
              <entry>独立的WebDAV应用程序</entry>
              <entry>X</entry>
              <entry/>
              <entry/>
              <entry>Web制作软件，可以直接读写WebDAV的URL</entry>
            </row>
            <row>
              <entry>Microsoft Office</entry>
              <entry>独立的WebDAV应用程序</entry>
              <entry>X</entry>
              <entry/>
              <entry/>
              <entry>Office上产套件，可以直接读写WebDAV的URL</entry>
            </row>
            <row>
              <entry>Microsoft Web 文件夹</entry>
              <entry>文件浏览器WebDAV扩展</entry>
              <entry>X</entry>
              <entry/>
              <entry/>
              <entry>可以在WebDAV执行树操作的GUI文件浏览器。</entry>
            </row>
            <row>
              <entry>GNOME Nautilus</entry>
              <entry>文件浏览器WebDAV扩展</entry>
              <entry/>
              <entry/>
              <entry>X</entry>
              <entry>GUI文件浏览器，可以对WebDAV共享执行目录树操作。</entry>
            </row>
            <row>
              <entry>KDE Konqueror</entry>
              <entry>文件浏览器WebDAV扩展</entry>
              <entry/>
              <entry/>
              <entry>X</entry>
              <entry>GUI文件浏览器，可以对WebDAV共享执行目录树操作。</entry>
            </row>
            <row>
              <entry>Mac OS X</entry>
              <entry>WebDAV文件系统实现</entry>
              <entry/>
              <entry>X</entry>
              <entry/>
              <entry>内置支持加载WebDAV共享的操作系统</entry>
            </row>
            <row>
              <entry>驱动器映射程序，可以将Windows驱动器加载为远程的WebDAV共享</entry>
              <entry>WebDAV文件系统实现</entry>
              <entry>X</entry>
              <entry/>
              <entry/>
              <entry>驱动器映射程序为了远程WebDAV共享分配Windows驱动器盘符。</entry>
            </row>
            <row>
              <entry>文件传输软件，可以将Windows驱动器加载为远程的WebDAV共享</entry>
              <entry>WebDAV文件系统实现</entry>
              <entry>X</entry>
              <entry/>
              <entry/>
              <entry>文件传输软件，也就是可以为加载的远程WebDAV共享赋予Windows驱动器盘符。</entry>
            </row>
            <row>
              <entry>davfs2</entry>
              <entry>WebDAV文件系统实现</entry>
              <entry/>
              <entry/>
              <entry>X</entry>
              <entry>Linux文件系统驱动允许加载WebDAV共享</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <!-- =============================================================== -->
      <section xml:id="svn.webdav.clients.standalone">
        <info>
          <title>独立的 WebDAV 应用程序</title>
        </info>
        <para>WebDAV应用使用WebDAV协议与WebDAV服务器通讯，我们将会介绍一些支持WebDAV的流行程序。</para>
        <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
        <section xml:id="svn.webdav.clients.standalone.windows">
          <info>
            <title>Microsoft Office，Dreamweaver，Photoshop</title>
          </info>
          <para>在Windows下，有许多已知的应用程序支持WebDAV客户端功能，例如微软Office，<footnote><para>在Windows下，有一些有名的集成WebDAV客户端功能的软件，例如Microsoft's Office、Adobe的Photoshop和Macromedia的Dreamweaver。它们都可以直接打开和保存URL，也可以在编辑时大量的使用WebDAV的锁定。</para></footnote>Adobe的Photoshop和Macromedia的Dreamweaver程序，他们可以直接打开和保存URL，并且在编辑文件时经常使用WebDAV的锁。 </para>
          <para>需要注意尽管这些程序也存在于Mac OS X，但是在这个平台上并不是直接支持WebDAV。实际上在Mac OS X，<guimenu>File→Open</guimenu>对话框不允许人们输入path或URL，这好像看起来我们的这个Macintosh应用不会支持WebDAV特性了，但实际上是因为OS X已经实现了底层的文件系统级WebDAV支持。</para>
        </section>
        <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
        <section xml:id="svn.webdav.clients.standalone.free">
          <info>
            <title>Cadaver，DAV 浏览器</title>
          </info>
          <para>Cadaver是一个简单的Unix命令行的WebDAV共享浏览程序，就像Subversion客户端，它使用neon的HTTP库，毫不奇怪，因为其作者就是neon的作者，Cadaver是一个自由软件(是用GPL许可证)，可以通过<uri href="http://www.webdav.org/cadaver/">http://www.webdav.org/cadaver/</uri>访问。</para>
          <para>使用cadaver与命令行FTP程序类似，因此它在基本的WebDAV调试中非常有用，它可以用来在紧急情况下上传或下载文件，也可以用来验证属性，并拷贝、移动、锁定或解锁文件：</para>
          <screen>
$ cadaver http://host/repos
dav:/repos/&gt; ls
Listing collection `/repos/': succeeded.
Coll: &gt; foobar                                 0  May 10 16:19
      &gt; playwright.el                       2864  May  4 16:18
      &gt; proofbypoem.txt                     1461  May  5 15:09
      &gt; westcoast.jpg                      66737  May  5 15:09

dav:/repos/&gt; put README
Uploading README to `/repos/README':
Progress: [=============================&gt;] 100.0% of 357 bytes succeeded.

dav:/repos/&gt; get proofbypoem.txt
Downloading `/repos/proofbypoem.txt' to proofbypoem.txt:
Progress: [=============================&gt;] 100.0% of 1461 bytes succeeded.
</screen>
          <para>DAV Explorer是另一个独立运行的WebDAV客户端，使用Java编写，有一个类Apache的许可证，网站是<uri href="http://www.ics.uci.edu/~webdav/">http://www.ics.uci.edu/~webdav/</uri>。DAV Explorer与cadaver功能差不多，优点可移植，并有一个用户友好的GUI程序。它也是最早的支持WebDAV访问控制协议(RFC 3744)的客户端之一。</para>
          <para>当然，在这个情况下DAV Explorer的ACL支持没有任何用处，因为<command>mod_dav_svn</command>不支持它，事实上，Cadaver和DAV Explorer支持的一些有限的DeltaV命令也并不有效，因为他们不允许<literal>MKACTIVITY</literal>请求，但是这都不相干；我们假定这些客户端都是针对自动版本化版本库工作。</para>
        </section>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.webdav.clients.file-explorer-extensions">
        <info>
          <title>文件浏览器的 WebDAV 扩展</title>
        </info>
        <para>一些流行的文件浏览器GUI程序支持WebDAV扩展，允许用户将DAV共享当作本地文件夹访问，例如Windows浏览器可以以<quote>network place</quote>方式浏览WebDAV服务器。用户可以拖入和拖出文件，或者是改名、拷贝或删除其中的文件。但是因为它只是文件浏览器的一个特性，DAV对普通应用不可见，所有的DAV交互必须通过浏览器界面。</para>
        <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
        <section xml:id="svn.webdav.clients.file-explorer-extensions.windows">
          <info>
            <title>Microsoft Web 文件夹</title>
          </info>
          <para>Microsoft是WebDAV规范最早的支持者，最早在Windows 98配置客户端，被称作<quote>网络文件夹</quote>，这个客户端在Windows NT4和2000上也存在。</para>
          <para>最早的Webfolders客户端是浏览器的扩展，主要的浏览文件系统的GUI程序，工作良好。在Windows 98，如果<quote>我的电脑</quote>里没有网络文件夹，这个特性需要明确安装。在Windows 2000，只需要添加一个新的<quote>网络位置</quote>，输入URL，WebDAV共享就会弹出让你浏览。</para>
          <para>伴随着Windows XP，Microsoft开始了另一种网络文件夹的实现，叫做<quote>WebDAV mini-redirector</quote>，这个新的实现是文件系统级的客户端，允许WebDAV转载到驱动器盘符上。不幸的是，这个实现充满难以相信的bug。客户端经常会尝试把http的URL(<literal>http://host/repos</literal>)转化为UNC共享符号(<literal>\\host\repos</literal>)，它也经常使用Windows域认证来回应基本的HTTP认证，按照<literal>HOST\username</literal>发送用户名。这类互动性问题在网络上大量传播，使大量用户受挫。即使是ApacheWebDAV的作者Greg Stein也建议不要对Apache服务器使用XP的网络文件夹。</para>
          <para>Windows Vista's initial implementation of Web Folders seems to
          be almost the same as XP's, so it has the same sort of
          problems.  With luck, Microsoft will remedy these issues in
          a Vista Service Pack.</para>
          <para>However, there seem to be workarounds for both XP and
          Vista that allow Web Folders to work against Apache.  Users
          have mostly reported success with these techniques, so we'll
          relay them here.</para>
          <para>On Windows XP, you have two options.  First, search
          Microsoft's web site for update KB90730, <quote>Software
          Update for Web Folders.</quote>  This may fix all your
          problems.  If it doesn't, it seems that the original pre-XP
          Web Folders implementation is still buried within the
          system.  You can unearth it by going to Network
          Places and adding a new network place.  When prompted,
          enter the URL of the repository, but <emphasis>include a
          port number</emphasis> in the URL.  For
          example, you should enter <userinput>http://host/repos</userinput> 
          as <userinput>http://host:80/repos</userinput> instead.
          Respond to any authentication prompts with your Subversion
          credentials.</para>
          <para>On Windows Vista, the same KB90730 update may clear
          everything up.  But there may still be other issues.  Some
          users have reported that Vista considers
          all <literal>http://</literal> connections insecure, and thus
          will always fail any authentication challenges from Apache
          unless the connection happens
          over <literal>https://</literal>.  If you're unable to connect
          to the Subversion repository via SSL, you can tweak the
          system registry to turn off this behavior.  Just change the
          value of the <literal>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\WebClient\Parameters\BasicAuthLevel</literal>
          key from <userinput>1</userinput> to <userinput>2</userinput>.  A final warning:  be sure to set up the Web
          Folder to point to the repository's root directory
          (<filename>/</filename>), rather than some subdirectory
          such as <filename>/trunk</filename>.  Vista Web Folders
          seems to work only against repository roots.</para>
          <para>In general, while these workarounds may function for
          you, you might get a better overall experience using a
          third-party WebDAV client such as WebDrive or NetDrive.</para>
        </section>
        <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
        <section xml:id="svn.webdav.clients.file-explorer-extensions.linux-de">
          <info>
            <title>Nautilus，Konqueror</title>
          </info>
          <para>Nautilus是GNOME桌面(<uri href="http://www.gnome.org">http://www.gnome.org)http://www.kde.org)</uri></para>
          <para>GNOME的Nautilus里，打开<guimenuitem>File→Open location</guimenuitem>，并且输入URL。版本库就会显示出来，就像其他文件系统。</para>
          <para>KDE的Konqueror里你需要在地址栏使用<literal>webdav://</literal>模式来输入URL，如果你输入<literal>http://</literal>的URL，Konqueror会像普通的web浏览器。你会看到mod_dav_svn输出的普通HTML目录列表。通过输入<literal>webdav://host/repos</literal>代替<literal>http://host/repos</literal>，Konqueror就成为了一个WebDAV客户端，并且按照文件系统的方式显示版本库。</para>
        </section>
      </section>
      <section xml:id="svn.webdav.clients.fs-impl">
        <info>
          <title>WebDAV 的文件系统实现</title>
        </info>
        <para>WebDAV文件系统实现被认为是最佳的WebDAV客户端，它通过低级的文件系统模块实现，通常在操作系统的核心。这意味着DAV共享像网络的其他文件系统一样装载，就像在Unix下面装载NFS，或者是在Windows下装载一个SMB共享。结果就是这种客户端为所有程序提供了对WebDAV得透明访问，应用程序甚至意识不到发生了WebDAV请求。</para>
        <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
        <section xml:id="svn.webdav.clients.fs-impl.windows">
          <info>
            <title>WebDrive，NetDrive</title>
          </info>
          <para>WebDrive和NetDrive都是优秀的商业产品，允许将WebDAV绑定到Windows的盘符，结果是你可以同对真实硬盘一样操作这些WebDAV后端支持的共享。WebDrive可以从South River Technologies(<uri href="http://www.southrivertech.com">http://www.southrivertech.com</uri>)购买。Netware的NetDrive可以在网络上免费下载，但用户还是需要有一个Netware许可证。</para>
        </section>
        <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
        <section xml:id="svn.webdav.clients.fs-impl.macosx">
          <info>
            <title>Mac OS X</title>
          </info>
          <para>Apple的OS X操作系统是集成的文件系统级的WebDAV客户端，通过Finder，选择<guimenu moreinfo="none">Go menu</guimenu>的<guimenuitem moreinfo="none">Connect to Server</guimenuitem>条目，输入WebDAV的URL，会在桌面显示一个磁盘，就像其他装载的卷。你也可以从Darwin终端通过<command>mount</command>类型为<literal>webdav</literal>的文件系统实现。</para>
          <screen>
$ mount -t webdav http://svn.example.com/repos/project /some/mountpoint
$
</screen>
          <para>注意如果<command>mod_dav_svn</command>是1.2之前的版本，OS X不能按照可读写装载，而是会成为只读。这是因为，OS X坚持要读写共享支持锁定，而锁定文件出现在Subversion 1.2。</para>
          <para>警告一句话：OS X的WebDAV客户端有时候对HTTP重定向很敏感，如果OS X不能装载版本库，你或许需要开启Apache服务器<filename>httpd.conf</filename>的BrowserMatch指示：</para>
          <screen>
BrowserMatch "^WebDAVFS/1.[012]" redirect-carefully
</screen>
        </section>
        <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
        <section xml:id="svn.webdav.clients.fs-impl.linux">
          <info>
            <title>Linux davfs2</title>
          </info>
          <para>Linux davfs2是一个Linux核心的文件系统模块，开发坐落在<uri href="http://dav.sourceforge.net/">http://dav.sourceforge.net/</uri>。一旦安装，一个WebDAV网络共享可以使用mount命令装载：</para>
          <screen>
$ mount.davfs http://host/repos /mnt/dav
</screen>
        </section>
      </section>
    </section>
  </appendix>
  <!--
local variables:
sgml-parent-document: ("book.xml" "appendix")
end:
-->
  <appendix xml:id="svn.copyright">
    <info>
      <title>版权</title>
    </info>
    <programlisting>

Copyright (c) 2002-2007
Ben Collins-Sussman, Brian W. Fitzpatrick, C. Michael Pilato.  

This work is licensed under the Creative Commons Attribution License.
To view a copy of this license, visit
http://creativecommons.org/licenses/by/2.0/ or send a letter to
Creative Commons, 559 Nathan Abbott Way, Stanford, California 94305,
USA.

A summary of the license is given below, followed by the full legal
text.

--------------------------------------------------------------------

You are free:

    * to copy, distribute, display, and perform the work
    * to make derivative works
    * to make commercial use of the work

Under the following conditions:
	
Attribution. You must give the original author credit.

    * For any reuse or distribution, you must make clear to others the
      license terms of this work.

    * Any of these conditions can be waived if you get permission from
      the author.

Your fair use and other rights are in no way affected by the above.

The above is a summary of the full license below.

====================================================================

Creative Commons Legal Code
Attribution 2.0

CREATIVE COMMONS CORPORATION IS NOT A LAW FIRM AND DOES NOT PROVIDE
LEGAL SERVICES. DISTRIBUTION OF THIS LICENSE DOES NOT CREATE AN
ATTORNEY-CLIENT RELATIONSHIP. CREATIVE COMMONS PROVIDES THIS
INFORMATION ON AN "AS-IS" BASIS. CREATIVE COMMONS MAKES NO WARRANTIES
REGARDING THE INFORMATION PROVIDED, AND DISCLAIMS LIABILITY FOR
DAMAGES RESULTING FROM ITS USE.

License

THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS
CREATIVE COMMONS PUBLIC LICENSE ("CCPL" OR "LICENSE"). THE WORK IS
PROTECTED BY COPYRIGHT AND/OR OTHER APPLICABLE LAW. ANY USE OF THE
WORK OTHER THAN AS AUTHORIZED UNDER THIS LICENSE OR COPYRIGHT LAW IS
PROHIBITED.

BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND
AGREE TO BE BOUND BY THE TERMS OF THIS LICENSE. THE LICENSOR GRANTS
YOU THE RIGHTS CONTAINED HERE IN CONSIDERATION OF YOUR ACCEPTANCE OF
SUCH TERMS AND CONDITIONS.

1. Definitions

   a. "Collective Work" means a work, such as a periodical issue,
      anthology or encyclopedia, in which the Work in its entirety in
      unmodified form, along with a number of other contributions,
      constituting separate and independent works in themselves, are
      assembled into a collective whole. A work that constitutes a
      Collective Work will not be considered a Derivative Work (as
      defined below) for the purposes of this License.

   b. "Derivative Work" means a work based upon the Work or upon the
      Work and other pre-existing works, such as a translation,
      musical arrangement, dramatization, fictionalization, motion
      picture version, sound recording, art reproduction, abridgment,
      condensation, or any other form in which the Work may be recast,
      transformed, or adapted, except that a work that constitutes a
      Collective Work will not be considered a Derivative Work for the
      purpose of this License. For the avoidance of doubt, where the
      Work is a musical composition or sound recording, the
      synchronization of the Work in timed-relation with a moving
      image ("synching") will be considered a Derivative Work for the
      purpose of this License.

   c. "Licensor" means the individual or entity that offers the Work
      under the terms of this License.

   d. "Original Author" means the individual or entity who created the Work.

   e. "Work" means the copyrightable work of authorship offered under
      the terms of this License.

   f. "You" means an individual or entity exercising rights under this
      License who has not previously violated the terms of this
      License with respect to the Work, or who has received express
      permission from the Licensor to exercise rights under this
      License despite a previous violation.

2. Fair Use Rights. Nothing in this license is intended to reduce,
   limit, or restrict any rights arising from fair use, first sale or
   other limitations on the exclusive rights of the copyright owner
   under copyright law or other applicable laws.

3. License Grant. Subject to the terms and conditions of this License,
   Licensor hereby grants You a worldwide, royalty-free,
   non-exclusive, perpetual (for the duration of the applicable
   copyright) license to exercise the rights in the Work as stated
   below:

   a. to reproduce the Work, to incorporate the Work into one or more
      Collective Works, and to reproduce the Work as incorporated in
      the Collective Works;

   b. to create and reproduce Derivative Works;

   c. to distribute copies or phonorecords of, display publicly,
      perform publicly, and perform publicly by means of a digital
      audio transmission the Work including as incorporated in
      Collective Works;

   d. to distribute copies or phonorecords of, display publicly,
      perform publicly, and perform publicly by means of a digital
      audio transmission Derivative Works.

   e.

      For the avoidance of doubt, where the work is a musical composition:

         i. Performance Royalties Under Blanket Licenses. Licensor
            waives the exclusive right to collect, whether
            individually or via a performance rights society
            (e.g. ASCAP, BMI, SESAC), royalties for the public
            performance or public digital performance (e.g. webcast)
            of the Work.

        ii. Mechanical Rights and Statutory Royalties. Licensor waives
            the exclusive right to collect, whether individually or
            via a music rights agency or designated agent (e.g. Harry
            Fox Agency), royalties for any phonorecord You create from
            the Work ("cover version") and distribute, subject to the
            compulsory license created by 17 USC Section 115 of the US
            Copyright Act (or the equivalent in other jurisdictions).

   f. Webcasting Rights and Statutory Royalties. For the avoidance of
      doubt, where the Work is a sound recording, Licensor waives the
      exclusive right to collect, whether individually or via a
      performance-rights society (e.g. SoundExchange), royalties for
      the public digital performance (e.g. webcast) of the Work,
      subject to the compulsory license created by 17 USC Section 114
      of the US Copyright Act (or the equivalent in other
      jurisdictions).

The above rights may be exercised in all media and formats whether now
known or hereafter devised. The above rights include the right to make
such modifications as are technically necessary to exercise the rights
in other media and formats. All rights not expressly granted by
Licensor are hereby reserved.

4. Restrictions.The license granted in Section 3 above is expressly
   made subject to and limited by the following restrictions:

   a. You may distribute, publicly display, publicly perform, or
      publicly digitally perform the Work only under the terms of this
      License, and You must include a copy of, or the Uniform Resource
      Identifier for, this License with every copy or phonorecord of
      the Work You distribute, publicly display, publicly perform, or
      publicly digitally perform. You may not offer or impose any
      terms on the Work that alter or restrict the terms of this
      License or the recipients' exercise of the rights granted
      hereunder. You may not sublicense the Work. You must keep intact
      all notices that refer to this License and to the disclaimer of
      warranties. You may not distribute, publicly display, publicly
      perform, or publicly digitally perform the Work with any
      technological measures that control access or use of the Work in
      a manner inconsistent with the terms of this License
      Agreement. The above applies to the Work as incorporated in a
      Collective Work, but this does not require the Collective Work
      apart from the Work itself to be made subject to the terms of
      this License. If You create a Collective Work, upon notice from
      any Licensor You must, to the extent practicable, remove from
      the Collective Work any reference to such Licensor or the
      Original Author, as requested. If You create a Derivative Work,
      upon notice from any Licensor You must, to the extent
      practicable, remove from the Derivative Work any reference to
      such Licensor or the Original Author, as requested.

   b. If you distribute, publicly display, publicly perform, or
      publicly digitally perform the Work or any Derivative Works or
      Collective Works, You must keep intact all copyright notices for
      the Work and give the Original Author credit reasonable to the
      medium or means You are utilizing by conveying the name (or
      pseudonym if applicable) of the Original Author if supplied; the
      title of the Work if supplied; to the extent reasonably
      practicable, the Uniform Resource Identifier, if any, that
      Licensor specifies to be associated with the Work, unless such
      URI does not refer to the copyright notice or licensing
      information for the Work; and in the case of a Derivative Work,
      a credit identifying the use of the Work in the Derivative Work
      (e.g., "French translation of the Work by Original Author," or
      "Screenplay based on original Work by Original Author"). Such
      credit may be implemented in any reasonable manner; provided,
      however, that in the case of a Derivative Work or Collective
      Work, at a minimum such credit will appear where any other
      comparable authorship credit appears and in a manner at least as
      prominent as such other comparable authorship credit.

5. Representations, Warranties and Disclaimer

UNLESS OTHERWISE MUTUALLY AGREED TO BY THE PARTIES IN WRITING,
LICENSOR OFFERS THE WORK AS-IS AND MAKES NO REPRESENTATIONS OR
WARRANTIES OF ANY KIND CONCERNING THE WORK, EXPRESS, IMPLIED,
STATUTORY OR OTHERWISE, INCLUDING, WITHOUT LIMITATION, WARRANTIES OF
TITLE, MERCHANTIBILITY, FITNESS FOR A PARTICULAR PURPOSE,
NONINFRINGEMENT, OR THE ABSENCE OF LATENT OR OTHER DEFECTS, ACCURACY,
OR THE PRESENCE OF ABSENCE OF ERRORS, WHETHER OR NOT
DISCOVERABLE. SOME JURISDICTIONS DO NOT ALLOW THE EXCLUSION OF IMPLIED
WARRANTIES, SO SUCH EXCLUSION MAY NOT APPLY TO YOU.

6. Limitation on Liability. EXCEPT TO THE EXTENT REQUIRED BY
   APPLICABLE LAW, IN NO EVENT WILL LICENSOR BE LIABLE TO YOU ON ANY
   LEGAL THEORY FOR ANY SPECIAL, INCIDENTAL, CONSEQUENTIAL, PUNITIVE
   OR EXEMPLARY DAMAGES ARISING OUT OF THIS LICENSE OR THE USE OF THE
   WORK, EVEN IF LICENSOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
   DAMAGES.

7. Termination

   a. This License and the rights granted hereunder will terminate
      automatically upon any breach by You of the terms of this
      License. Individuals or entities who have received Derivative
      Works or Collective Works from You under this License, however,
      will not have their licenses terminated provided such
      individuals or entities remain in full compliance with those
      licenses. Sections 1, 2, 5, 6, 7, and 8 will survive any
      termination of this License.

   b. Subject to the above terms and conditions, the license granted
      here is perpetual (for the duration of the applicable copyright
      in the Work). Notwithstanding the above, Licensor reserves the
      right to release the Work under different license terms or to
      stop distributing the Work at any time; provided, however that
      any such election will not serve to withdraw this License (or
      any other license that has been, or is required to be, granted
      under the terms of this License), and this License will continue
      in full force and effect unless terminated as stated above.

8. Miscellaneous

   a. Each time You distribute or publicly digitally perform the Work
      or a Collective Work, the Licensor offers to the recipient a
      license to the Work on the same terms and conditions as the
      license granted to You under this License.

   b. Each time You distribute or publicly digitally perform a
      Derivative Work, Licensor offers to the recipient a license to
      the original Work on the same terms and conditions as the
      license granted to You under this License.

   c. If any provision of this License is invalid or unenforceable
      under applicable law, it shall not affect the validity or
      enforceability of the remainder of the terms of this License,
      and without further action by the parties to this agreement,
      such provision shall be reformed to the minimum extent necessary
      to make such provision valid and enforceable.

   d. No term or provision of this License shall be deemed waived and
      no breach consented to unless such waiver or consent shall be in
      writing and signed by the party to be charged with such waiver
      or consent.

   e. This License constitutes the entire agreement between the
      parties with respect to the Work licensed here. There are no
      understandings, agreements or representations with respect to
      the Work not specified here. Licensor shall not be bound by any
      additional provisions that may appear in any communication from
      You. This License may not be modified without the mutual written
      agreement of the Licensor and You.

Creative Commons is not a party to this License, and makes no warranty
whatsoever in connection with the Work. Creative Commons will not be
liable to You or any party on any legal theory for any damages
whatsoever, including without limitation any general, special,
incidental or consequential damages arising in connection to this
license. Notwithstanding the foregoing two (2) sentences, if Creative
Commons has expressly identified itself as the Licensor hereunder, it
shall have all rights and obligations of Licensor.

Except for the limited purpose of indicating to the public that the
Work is licensed under the CCPL, neither party will use the trademark
"Creative Commons" or any related trademark or logo of Creative
Commons without the prior written consent of Creative Commons. Any
permitted use will be in compliance with Creative Commons'
then-current trademark usage guidelines, as may be published on its
website or otherwise made available upon request from time to time.

Creative Commons may be contacted at http://creativecommons.org/.

====================================================================
</programlisting>
  </appendix>
  <!--
local variables: 
sgml-parent-document: ("book.xml" "")
end:
-->
  <index xml:id="svn.index"/>
</book>
