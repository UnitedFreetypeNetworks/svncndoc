<chapter xml:id="svn.advanced">
    <info>
      <title>高级主题</title>
    </info>
    <para>如果你是从头到尾按章节阅读本书，你一定已经具备了使用Subversion客户端执行大多数不同的版本控制操作足够的知识，你理解了怎样从Subversion版本库取出一个工作拷贝，你已经熟悉了通过<command>svn commit</command>和<command>svn update</command>来提交和接收修改，你甚至也经常下意识的使用<command>svn status</command>，无论目的是什么，你已经可以正常使用Subversion了。</para>
    <para>但是Subversion的特性并没有止于<quote>普通的版本控制操作</quote>，它也有一些超越了与版本库传递文件和目录修改以外的功能。</para>
    <para>本章重点介绍了一些很重要但不是经常使用的Subversion特性，本章假定你熟悉Subversion对文件和目录的基本版本操作能力，如果你还没有阅读这些内容，或者是需要一个复习，我们建议你重读<xref linkend="svn.basic"/>和<xref linkend="svn.tour"/>，一旦你已经掌握了基础知识和本章的内容，你会变成Subversion的超级用户！</para>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.tour.revs.specifiers">
      <info>
        <title>版本清单</title>
      </info>
      <para>就像你在<xref linkend="svn.basic.in-action.revs"/>见到的，Subversion的修订版本号码非常直接—就是随提交增大的整数。尽管如此，不会花很长时间你就会忘记每个修订版本的修改，但幸运的是，典型的Subvesion工作流程中一般不会要求你提供任意的修订版本号。在需要输入修订版本号时，通常或者是你在一个提交邮件中看到了一个修订版本，或者是在其他Subversion命令的输出结果中，或者是任何上下文环境得到某个版本号码的情况下。</para>
      <para>但是有时候，你需要精确指定一个时间，而无法记住或者记录了某个版本，这时除了使用修订版本号码，<command>svn</command>允许使用其他形式来指定修订版本—<firstterm>修订版本关键字</firstterm>和修订版本日期。</para>
      <note>
        <para>当用来指定修订版本范围时，不同形式的Subversion修订版本可以混合匹配。例如，你可以<replaceable>REV1</replaceable>是修订版本关键字，<replaceable>REV2</replaceable>是修订版本号，或者是<replaceable>REV1</replaceable>是日期，而<replaceable>REV2</replaceable>是修订版本关键字，等等。不同的修订版本指定符是等价的，所以你可以在冒号两边任意使用。</para>
      </note>
      <!-- =============================================================== -->
      <section xml:id="svn.tour.revs.keywords">
        <info>
          <title>修订版本关键字</title>
        </info>
        <indexterm>
          <primary>版本</primary>
          <secondary>版本关键字</secondary>
        </indexterm>
        <indexterm>
          <primary>HEAD</primary>
        </indexterm>
        <indexterm>
          <primary>BASE</primary>
        </indexterm>
        <indexterm>
          <primary>COMMITTED</primary>
        </indexterm>
        <indexterm>
          <primary>PREV</primary>
        </indexterm>
        <para>Subversion客户端可以理解一些<firstterm>修订版本关键字</firstterm>，这些关键字可以用来代替<option>--revision</option>(<option>-r</option>)的数字参数，这会被Subversion解释到特定修订版本号：</para>
        <variablelist>
          <varlistentry>
            <term>
              <literal>HEAD</literal>
            </term>
            <listitem>
              <para>版本库中最新的(或者是<quote>最年轻的</quote>)版本。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>BASE</literal>
            </term>
            <listitem>
              <para>工作拷贝中一个条目的修订版本号，如果这个版本在本地修改了，则这里指的是这个条目在本地未修改的版本。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>COMMITTED</literal>
            </term>
            <listitem>
              <para>项目最近修改的修订版本，与<literal>BASE</literal>相同或更早。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>PREV</literal>
            </term>
            <listitem>
              <para>一个项目最后修改版本<emphasis>之前</emphasis>的那个版本，技术上可以认为是<literal>COMMITTED</literal> -1。</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <para>因为可以从描述中得到，关键字<literal>PREV</literal>，<literal>BASE</literal>和<literal>COMMITTED</literal>只在引用工作拷贝路径时使用，而不能用于版本库URL，而关键字<literal>HEAD</literal>则可以用于两种路径类型。</para>
        <para>下面是一些修订版本关键字的例子：</para>
        <screen>
$ svn diff -r PREV:COMMITTED foo.c
# shows the last change committed to foo.c

$ svn log -r HEAD
# shows log message for the latest repository commit

$ svn diff -r HEAD
# compares your working copy (with all of its local changes) to the
# latest version of that tree in the repository

$ svn diff -r BASE:HEAD foo.c
# compares the unmodified version of foo.c with the latest version of
# foo.c in the repository

$ svn log -r BASE:HEAD
# shows all commit logs for the current versioned directory since you
# last updated

$ svn update -r PREV foo.c
# rewinds the last change on foo.c, decreasing foo.c's working revision

$ svn diff -r BASE:14 foo.c
# compares the unmodified version of foo.c with the way foo.c looked
# in revision 14
</screen>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.tour.revs.dates">
        <info>
          <title>版本日期</title>
        </info>
        <indexterm>
          <primary>版本</primary>
          <secondary>以日期指定</secondary>
        </indexterm>
        <para>在版本控制系统以外，修订版本号码是没有意义的，但是有时候你需要将时间和历史修订版本号关联。为此，<option>--revision</option>(<option>-r</option>)选项接受使用花括号(<literal>{</literal>和<literal>}</literal>)包裹的日期输入，Subversion支持标准ISO-8601日期和时间格式，也支持一些其他的。下面是一些例子。(记住使用引号括起所有包含空格的日期。)</para>
        <screen>
$ svn checkout -r {2006-02-17}
$ svn checkout -r {15:30}
$ svn checkout -r {15:30:00.200000}
$ svn checkout -r {"2006-02-17 15:30"}
$ svn checkout -r {"2006-02-17 15:30 +0230"}
$ svn checkout -r {2006-02-17T15:30}
$ svn checkout -r {2006-02-17T15:30Z}
$ svn checkout -r {2006-02-17T15:30-04:00}
$ svn checkout -r {20060217T1530}
$ svn checkout -r {20060217T1530Z}
$ svn checkout -r {20060217T1530-0500}
…
</screen>
        <para>当你指定一个日期，Subversion会在版本库找到接近这个日期的最近版本，并且对这个版本继续操作：</para>
        <screen>
$ svn log -r {2006-11-28}
------------------------------------------------------------------------
r12 | ira | 2006-11-27 12:31:51 -0600 (Mon, 27 Nov 2006) | 6 lines
…
</screen>
        <sidebar>
          <info>
            <title>Subversion 会早一天吗？</title>
          </info>
          <para>如果你只是指定了日期而没有时间(举个例子<literal>2006-11-27</literal>)，你也许会以为Subversion会给你11-27号最后的版本，相反，你会得到一个26号版本，甚至更早。记住Subversion会根据你的日期找到<emphasis>最新的</emphasis>版本，如果你给一个日期，而没有给时间，像<literal>2006-11-27</literal>，Subversion会假定时间是00:00:00，所以在27号找不到任何版本。</para>
          <para>如果你希望查询包括27号，你既可以使用(<literal>{"2006-11-27 23:59"}</literal>)，或是直接使用第二天(<literal>{2006-11-28}</literal>)。</para>
        </sidebar>
        <para>你可以使用时间段，Subversion会找到这段时间的所有版本：</para>
        <screen>
$ svn log -r {2006-11-20}:{2006-11-29}
…
</screen>
        <warning>
          <para>因为一个版本的时间戳是作为一个属性存储的—不是版本化的，而是可以编辑的属性(见<xref linkend="svn.advanced.props"/>)—版本号的时间戳可以被修改，从而建立一个虚假的年代表，也可以被完全删除。Subversion正确转化修订版本日期到修订版本的能力依赖于修订版本时间戳顺序排列—修订版本越年轻，则时间戳越年轻。如果顺序没有被维护，你会发现使用日期指定修订版本不会返回你期望的数据。</para>
        </warning>
      </section>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.advanced.props">
      <info>
        <title>属性</title>
      </info>
      <indexterm>
        <primary>属性</primary>
      </indexterm>
      <para>我们已经详细讲述了Subversion存储和检索版本库中不同版本的文件和目录的细节，并且用了好几个章节来论述这个工具的基本功能。如果对于版本化的支持到此为止，从版本控制的角度来看Subversion已经完整了。</para>
      <para>但不仅仅如此。</para>
      <para>作为目录和文件版本化的补充，Subversion提供了对每一个版本化的目录和文件添加、修改和删除版本化的元数据的接口，我们用<firstterm>属性</firstterm>来表示这些元数据。我们可以认为它们是一个两列的表，附加到你的工作拷贝的每个条目上，映射属性名到任意的值。一般来说，属性的名称和值可以是你希望的任何值，限制就是名称必须是可读的文本，并且最好的一点是这些属性也是版本化的，就像你的文本文件内容，你可以像提交文本修改一样修改、提交和恢复属性修改，当你更新时也会接收到别人的属性修改—你不必为适应属性改变你的工作流程。</para>
      <note>
        <para>Subversion自己保留了一组名称以<literal>svn:</literal>开头的属性，现在已经有了一些在用的属性，所以在你根据需要创建自定义属性时，需要避免这些前缀开头的名称，否则，Subversion的新版本可能会采用同名的属性来满足新的特性，而其含义可能会完全不同。</para>
      </note>
      <para>Subversion的属性也可以在别的地方出现，就像文件和目录可能附加有任意的属性名和值，每个修订版本作为一个整体也可以附加任意的属性，也有同样的限制—可读的文本名称和任何你希望的二进制值，主要的区别是修订版本属性不是版本化的，换句话说，如果你修改，删除一个修订版本属性，在Subversion领域内没有办法恢复到以前的值。</para>
      <para>Subversion不关心如何使用属性，但是要求你不要使用<literal>svn:</literal>为前缀的属性名，这是Subversion自己使用的命名空间，Subversion使用了版本化的和未版本化的属性。文件和目录上的特定版本化属性都有特别的意义或效果，或者是提供了修订版本的一些信息。一些修订版本属性会在提交时自动附加到修订版本上，包含了修订版本的信息。大多数这些属性会作为普通的主题在后面提及，关于Subversion预定义的属性的详细列表可以看<xref linkend="svn.ref.properties"/>。</para>
      <para>在本小节，我们将会检验这个工具—不仅是对Subversion的用户，也对Subversion本身—对于属性的支持。你会学到与属性相关的<command>svn</command>子命令，和属性怎样影响你的普通Subversion工作流。</para>
      <!-- =============================================================== -->
      <section xml:id="svn.advanced.props.why">
        <info>
          <title>为什么需要属性？</title>
        </info>
        <para>就像Subversion使用属性保存其包含的文件、目录和修订版本的附加信息，你也会发现属性有一些类似的使用，你会发现如果在数据附近有个地方保存自定义元数据会非常有用。</para>
        <para>假设你希望设计一个存放许多数码照片的网站，会显示标题和缩略图。现在你的图片会经常修改，所以你希望能够让这个站点尽量自动处理这些事情，这些照片会很大，所以作为网站，你希望为访问者提供相似的缩略图。</para>
        <para>现在，你可以利用这些功能使用传统文件。你可以有一个<filename>image123.jpg</filename>和一个对应的<filename>image123-thumbnail.jpg</filename>在同一个目录里，有时候你希望保持文件名相同，你可以使用不同的目录，如<filename>thumbnails/image123.jpg</filename>。你可以用一种相似的样式来保存你的标题和时间戳，同原始图像文件分开。每个新图片的添加都会成倍的增加混乱，很快你的目录树会是一团糟。</para>
        <para>现在考虑使用Subversion文件的属性的方式来管理这个站点，想象我们有一个单独的图像文件<filename>image123.jpg</filename>，然后这个文件的属性集包括<literal>caption</literal>、<literal>datestamp</literal>甚至<literal>thumbnail</literal>。现在你的工作拷贝目录看起来更容易管理—实际上，它看起来只有图像文件，但是你的自动化脚本知道得更多，它们知道可以用<command>svn</command>(更好的选择是使用Subversion的语言绑定—见<xref linkend="svn.developer.usingapi"/>)来挖掘更多的站点显示需要的额外信息，而不必去阅读一个索引文件或者是玩一个路径处理的游戏。</para>
        <note>
          <para>While Subversion places few restrictions on the names
          and values you use for properties, it has not been designed
          to optimally carry large property values or large sets of
          properties on a given file or directory.  Subversion
          commonly holds all the property names and values associated
          with a single item in memory at the same time, which can
          cause detrimental performance or failed operations when
          extremely large property sets are used.</para>
        </note>
        <para>自定义修订版本属性也经常被使用，一个常见的用法是一个包含问题跟踪ID的属性，可能是因为这个修改修正了这个ID的问题。另外一些人用属性来存放更容易记的修订版本名称—记住修订版本1935是一个完全测试的版本是很困难的，但是如果在修订版本上设置一个值为<literal>all passing</literal>的<literal>test-results</literal>属性，这就有了一个有用的信息。</para>
        <sidebar>
          <info>
            <title>可搜索性(或者，为什么<emphasis>不</emphasis>使用属性)</title>
          </info>
          <para>对于Subversion属性的所有功能—或者更准确的讲，对于属性的所有接口—都有一些主要的应用会削弱他们的应用。设置一个自定义属性后，很容易发现属性完全变成另外一会儿事。</para>
          <para>为了定位一个自定义属性通常要线形访问版本库的所有修订版本，向每个修订版本询问，“你们有我找的属性吗？”尝试查找自定义版本化属性也是同样的痛苦，通常需要在整个工作拷贝递归调用<command>svn propget</command>。在你的情况下，可能不会比遍历所有修订版本差。但也在性能和成功可能性里留下了许多悬念，特别是当你需要从版本库的根开始搜索时。</para>
          <para>因为这个原因，你会选择—特别是在修订版本属性用例—简单的添加你的元数据到修订版本日志信息，使用一些政策驱动(并且是编程强制的)且可以通过<command>svn log</command>快速解析的格式。如下的Subversion日志信息会很常见：</para>
          <programlisting>
Issue(s): IZ2376, IZ1919
Reviewed by:  sally

This fixes a nasty segfault in the wort frabbing process
…
</programlisting>
          <para>但是现在依然有一些不幸，Subversion不支持日志信息模版机制，虽然这样对用户与日志嵌入的修订版本元数据保持一致有很大帮助。</para>
        </sidebar>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.advanced.props.manip">
        <info>
          <title>操作属性</title>
        </info>
        <para><command>svn</command>命令提供一些方法来添加和修改文件或目录的属性，对于短的，可读的属性，最简单的添加方法是在<command>propset</command>子命令里指定正确的名称和值。</para>
        <screen>
$ svn propset copyright '(c) 2006 Red-Bean Software' calc/button.c
property 'copyright' set on 'calc/button.c'
$
</screen>
        <para>但是我们已经吹捧了Subversion提供的属性功能的灵活性，如果你计划使用多行文本，或者是二进制属性值，你可能不会希望通过命令行提供这些值，所以<command>propset</command>子命令提供的<option>--file</option>(<option>-F</option>)选项可以指定包含属性值的文件。</para>
        <screen>
$ svn propset license -F /path/to/LICENSE calc/button.c
property 'license' set on 'calc/button.c'
$
</screen>
        <para>对于属性名称也有一些限制，属性名必须以一个字符、一个冒号(<literal>:</literal>)或下划线(<literal>_</literal>)开始，之后你可以使用数字，横线(<literal>-</literal>)和句号(<literal>.</literal>)。 <footnote><para>如果你熟悉XML，其实这就是XML的"Name"语法的ASCII子集。</para></footnote></para>
        <para>作为<command>propset</command>命令的补充，<command>svn</command>提供了一个<command>propedit</command>命令，这个命令使用定制的编辑器程序(见<xref linkend="svn.advanced.confarea.opts.config"/>)来添加和修改属性。当你运行这个命令，<command>svn</command>调用你的编辑器程序打开一个临时文件，文件中保存当前的属性值(或者是空文件，如果你正在添加新的属性)。然后你只需要修改为你想要的值，保存临时文件，然后离开编辑器程序。如果Subversion发现你已经修改了属性值，就会接受新值，如果你未作任何修改而离开，不会产生属性修改操作：</para>
        <screen>
$ svn propedit copyright calc/button.c  ### exit the editor without changes
No changes to property 'copyright' on 'calc/button.c'
$
</screen>
        <para>我们也应该注意到，像其它<command>svn</command>子命令一样，这些关联的属性可以一次添加到多个路径上，这样就可以通过一个命令修改一组文件的属性。例如，我们可以：</para>
        <screen>
$ svn propset copyright '(c) 2006 Red-Bean Software' calc/*
property 'copyright' set on 'calc/Makefile'
property 'copyright' set on 'calc/button.c'
property 'copyright' set on 'calc/integer.c'
…
$
</screen>
        <para>如果不能方便的得到存储的属性值，那么属性的添加和编辑操作也不会很容易，所以<command>svn</command>提供了两个子命令来显示文件和目录存储的属性名和值。<command>svn proplist</command>命令会列出路径上存在的所有属性名称，一旦你知道了某个节点的属性名称，你可以用<command>svn propget</command>获取它的值，这个命令获取给定的路径(或者是一组路径)和属性名称，打印这个属性的值到标准输出。</para>
        <screen>
$ svn proplist calc/button.c
Properties on 'calc/button.c':
  copyright
  license
$ svn propget copyright calc/button.c
(c) 2006 Red-Bean Software
</screen>
        <para>还有一个<command>proplist</command>变种命令会列出所有属性的名称和值，只需要设置<option>--verbose</option>(<option>-v</option>)选项。</para>
        <screen>
$ svn proplist -v calc/button.c
Properties on 'calc/button.c':
  copyright : (c) 2006 Red-Bean Software
  license : ================================================================
Copyright (c) 2006 Red-Bean Software.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions 
are met:

1. Redistributions of source code must retain the above copyright
notice, this list of conditions, and the recipe for Fitz's famous
red-beans-and-rice.
…
</screen>
        <para>最后一个与属性相关的子命令是<command>propdel</command>，因为Subversion允许属性值为空，所有不能用<command>propedit</command>或者<command>propset</command>命令删除一个属性。例如，这个命令<emphasis>不会</emphasis>产生预期的效果：</para>
        <screen>
$ svn propset license '' calc/button.c
property 'license' set on 'calc/button.c'
$ svn proplist -v calc/button.c
Properties on 'calc/button.c':
  copyright : (c) 2006 Red-Bean Software
  license : 
$
</screen>
        <para>你需要用<command>propdel</command>来删除属性，语法与其它与属性命令相似：</para>
        <screen>
$ svn propdel license calc/button.c
property 'license' deleted from 'calc/button.c'.
$ svn proplist -v calc/button.c
Properties on 'calc/button.c':
  copyright : (c) 2006 Red-Bean Software
$
</screen>
        <para>还记的这些未版本化的修订版本属性？你也可以使用<command>svn</command>子命令修改这些属性。只需要添加<option>--revprop</option>命令参数，说明希望修改属性的修订版本。因为修订版本是全局的，你不需要指定一个路径，只要你已经位于你希望修改属性的工作拷贝路径，或者，你也可以提供版本库的URL的任何路径(也包括版本库的根URL)。例如，<footnote><para>修正提交日志信息的拼写错误，文法错误和<quote>简单的错误</quote>是<option>--revprop</option>选项最常见用例。</para></footnote>如果你当前的工作路径是一个版本库工作拷贝的一部分，你可以简单的运行没有目标路径的<command>svn propset</command>命令：</para>
        <screen>
$ svn propset svn:log '* button.c: Fix a compiler warning.' -r11 --revprop
property 'svn:log' set on repository revision '11'
$
</screen>
        <para>但是即使你没有从版本库检出一个工作拷贝，你仍然可以通过提供版本库根URL来影响属性修改。</para>
        <screen>
$ svn propset svn:log '* button.c: Fix a compiler warning.' -r11 --revprop \
              http://svn.example.com/repos/project
property 'svn:log' set on repository revision '11'
$
</screen>
        <para>注意，修改这些未版本化的属性的能力一定要明确的添加给版本库管理员(见<xref linkend="svn.reposadmin.maint.setlog"/>)。因为属性没有版本化，如果编辑的时候不小心，就会冒丢失信息的风险，版本库管理员可以设置方法来防范这种意外，缺省情况下，修改未版本化的属性是禁止的。</para>
        <tip>
          <para>用户必须在可能的情况下使用<command>svn propedit</command>，而不是<command>svn propset</command>。然而这两个命令的结果是相同的，前一个会允许他们查看修改以前的内容，可以帮助用户验证，实际上，作出他们所期望的修改，当修改未版本化修订版本属性时，这一点特别需要。另外，这个命令也可以通过文本编辑器或命令行轻松的修改多行属性。</para>
        </tip>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.advanced.props.workflow">
        <info>
          <title>属性和 Subversion 工作流程</title>
        </info>
        <para>现在你已经熟悉了所有与属性相关的<command>svn</command>子命令，让我们看看属性修改如何影响Subversion的工作流。我们前面提到过，文件和目录的属性是版本化的，这一点类似于版本化的文件内容。后果之一，就是Subversion具有了同样的机制来合并—用干净或者冲突的方式—其他人的修改应用到你的修改。</para>
        <para>就像文件内容，你的属性修改是本地修改，只有使用<command>svn commit</command>命令提交后才会保存到版本库中，属性修改也可以很容易的取消—<command>svn revert</command>命令会恢复你的文件和目录为编辑前状态，包括内容、属性和其它的信息。另外，你可以使用<command>svn status</command>和<command>svn diff</command>接受感兴趣的文件和目录属性的状态信息。</para>
        <screen>
$ svn status calc/button.c
 M     calc/button.c
$ svn diff calc/button.c
Property changes on: calc/button.c
___________________________________________________________________
Name: copyright
   + (c) 2006 Red-Bean Software

$
</screen>
        <para>注意<command>status</command>子命令显示的<literal>M</literal>在第二列而不是在第一列，这是因为我们修改了<filename>calc/button.c</filename>的属性，而不是它的文本内容，如果我们都修改了，我们也会看到<literal>M</literal>出现在第一列(见<xref linkend="svn.tour.cycle.examine.status"/>)。</para>
        <sidebar>
          <info>
            <title>属性冲突</title>
          </info>
          <para>与文件内容一样，本地的属性修改也会同别人的提交冲突，如果你更新你的工作拷贝目录并且接收到有资源属性修改与你的修改冲突，Subversion会报告资源处于冲突状态。</para>
          <screen>
$ svn update
U  INSTALL
G  README
Conflict discovered in 'bar.c'.
Select: (p) postpone, (df) diff-full, (e) edit,
        (h) help for more options:
</screen>
          <para>Subversion也会在冲突资源的同一个目录创建一个<filename>.prej</filename>扩展名的文件，保存冲突的细节。你一定要检查这个文件的内容来决定如何解决冲突，在你解决冲突之前，你会在使用<command>svn status</command>时看到这个资源的输出的第二列是一个<literal>C</literal>，提交本地修改的尝试会失败。</para>
          <screen>
$ svn status calc
 C     calc/button.c
?      calc/button.c.prej
$ cat calc/button.c.prej 
prop 'linecount': user set to '1256', but update set to '1301'.
$
</screen>
          <para>为了解决属性冲突，只需要确定冲突的属性保存了它们应该的值，然后使用<command>svn resolved</command>命令告诉Subversion你已经手工解决了问题。</para>
        </sidebar>
        <para>你也许已经注意到了Subversion在显示属性时的非标准方式。你还可以运行<command>svn diff</command>并且重定向输出来产生一个有用的补丁文件，<command>patch</command>程序会忽略属性补丁—作为规则，它会忽略任何不理解的噪音。很遗憾，这意味着完全应用<command>svn diff</command>产生的补丁时，任何属性修改必须手工实施。</para>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.advanced.props.auto">
        <info>
          <title>自动设置属性</title>
        </info>
        <para>属性是Subversion一个强大的特性，成为本章和其它章讨论的许多Subversion特性的关键组成部分—文本区别和合并支持、关键字替换、新行的自动转换等等。但是为了从属性得到完全的利益，他们必须设置到正确的文件和目录。不幸的是，在日常工作中很容易忘记这一步工作，特别是当没有设置属性不会引起明显的错误时(至少相对与未能添加一个文件到版本控制这种操作)，为了帮助你在需要添加属性的文件上添加属性，Subversion提供了一些简单但是有用的特性。</para>
        <para>当你使用<command>svn add</command>或是<command>svn import</command>准备加入一个版本控制的文件时，Subversion会自动运行一个基本探测来检查文件是包含了可读还是不可读的内容，首先，在支持执行允许位的操作系统，Subversion会自动会为设置执行位的文件设置<literal>svn:executable</literal>属性(更多信息见<xref linkend="svn.advanced.props.special.executable"/>)。</para>
        <para>。第二，Subversion会试图确定文件的MIME类型。如果你配置了一个<literal>mime-types-files</literal>运行配置参数，Subversion会根据这个文件的后缀名查找一个映射的MIME类型，如果这个映射不存在或者没有文件后缀名的映射，Subversion会采用启发式的方式确定文件是否包含非文本的内容，如果是，则自动将文件的<literal>svn:mime-type</literal>属性设置为<literal>application/octet-stream</literal>(<quote>一组字节</quote>的类型)。当然，如果Subversion猜测错误，或者是你希望使用<literal>svn:mime-type</literal>属性更精确的设置—或许是<literal>image/png</literal>或者<literal>application/x-shockwave-flash</literal>—你可以一直删除或编辑那个属性(关于Subversion使用MIME类型的更多信息，见本章后面的<xref linkend="svn.advanced.props.special.mime-type"/>。)</para>
        <para>Subversion也通过运行配置系统(见<xref linkend="svn.advanced.confarea"/>)提供了一个更灵活的自动属性特性，允许你创建文件名到属性名称与值影射，这个影射在你的运行配置区域设置，它们会影响添加和导入操作，而且不仅仅会覆盖Subversion所有缺省的MIME类型判断操作，也会设置额外的Subversion或者自定义的属性。举个例子，你会创建一个影射文件说在任何时候你添加了一个JPEG文件—一些符合<literal>*.jpg</literal>的文件—Subversion一定会自动设置它们的<literal>svn:mime-type</literal>属性为<literal>image/jpeg</literal>。或者是任何匹配<literal>*.cpp</literal>的文件，必须把<literal>svn:eol-style</literal>设置为<literal>native</literal>，并且<literal>svn:keywords</literal>设置为<literal>Id</literal>。自动属性支持是Subversion工具箱中属性相关最垂手可得的工具，见<xref linkend="svn.advanced.confarea.opts.config"/>来查看更多的配置支持。</para>
      </section>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.advanced.props.file-portability">
      <info>
        <title>文件移植性</title>
      </info>
      <para>幸运的是，对于许多在不同操作系统下工作的用户，Subversion命令行程序的行为方式几乎完全一致，如果你知道在一个平台上如何运行<command>svn</command>，你也就学会了在其他平台上运行。</para>
      <para>然而，这一点在本软件的其他几类地方或Subversion保持的实际文件并不一定都是正确的。例如，在一个Windows系统，<quote>文本文件</quote>的定义与Linux环境下的类似，但是也有区别—行结束的字符串并不相同。当然也有其他的区别，Unix平台支持(Subversion也支持)符号链；Windows不知吃，Unix使用文件系统执行位来检测可执行性；而Windows使用文件扩展名。</para>
      <para>因为Subversion不是要将世界上的所有此类事情统一起来，所以我们最好是尽可能让我们在多个计算机和操作系统上使用版本化文件和目录时能够更简单，本节描述了Subversion是如何做的。</para>
      <!-- =============================================================== -->
      <section xml:id="svn.advanced.props.special.mime-type">
        <info>
          <title>文件内容类型</title>
        </info>
        <para>Subversion同很多应用一样利用多用途网际邮件扩展(MIME)内容类型，<literal>svn:mime-type</literal>属性为Subversion的许多目的服务，除了保存一个文件的MIME分类以外，这个<literal>svn:mime-type</literal>属性值也描述了一些Subversion自己使用的行为特性。</para>
        <sidebar>
          <info>
            <title>识别文件类型</title>
          </info>
          <para>大多数现代操作系统通过文件名的扩展名推断文件的类型和格式，例如，以<filename>.txt</filename>为后缀的文件通常被认为是可读的，不需要通过复杂的解码处理就可以被阅读。对于后缀名为<filename>.png</filename>文件，则被认为是Portable Network Graphics类型—不是可读的格式，只能通过识别PNG格式并且可以将信息转化为光栅的软件使用。</para>
          <para>不幸的是，一些扩展名已经随时间改变了意义。当个人电脑第一次出现时，一个叫做<filename>README.DOC</filename>的文件一定是一个纯文本文件了，就像现在的<filename>.txt</filename>文件。但是在九十年代中期，你可以打赌这个文件已经不是文本文件，而变成了微软的私有的、不可读的Word文档格式。但是这个变化不是一夜完成的—在一段时间里一定会有用户在看到一个<filename>.DOC</filename>时感到困惑。<footnote><para>你认为那样过于粗狂？在同一个时代里，WordPerfect也使用<filename>.DOC</filename>作为它们私有文件格式的扩展名！</para></footnote></para>
          <para>计算机网络的普及导致对于文件名和其关联内容的更多混淆，当信息存放在网络上并由服务器脚本动态生成时，会没有文件名。Web服务器，需要使用其他方式告诉浏览器它们所请求内容的信息，这样浏览器才能智能的根据信息作一些事情，或者是使用注册的程序显示数据，或者是提示用户将文件下载到某个地方。</para>
          <para>最终，一个描述数据流内容的标准出现了。1996年，5个描述MIME的RFC中的第一个RFC2045发布了，这个RFC描述了媒体类型和子类型概念，并且提出了表示这些类型的推荐语法。现在，MIME媒体类型—或<quote>MIME类型</quote>已经广泛应用在电邮应用，Web服务器和其他软件，成为了防止文件内容混淆的标准机制。</para>
        </sidebar>
        <para>举个例子，一个好处就是Subversion在更新时通常可以提供基于上下文的行为基础的合并，如果一个文件<literal>svn:mime-type</literal>属性设置为非文本的MIME类型(通常是那些不是<literal>text/</literal>开头的类型，但也有例外)，Subversion会假定这个文件保存了二进制内容—也就是不可读的数据。一个好处就是Subversion通常在更新工作拷贝时提供了一个前后相关的以行为基础的修改合并，但是对于二进制数据文件，没有<quote>行</quote>的概念，所以对这些文件，Subversion不会在更新时尝试执行合并操作，相反，任何时候你在本地已经修改的一个二进制文件有了更新，你的文件扩展名会修改为<filename>.orig</filename>，然后Subversion保存一个新的工作拷贝文件来保存更新时得到的修改，但原来的文件名已经不是你自己的本地修改。这个行为模式是用来保护用户在对不可文本合并的文件尝试执行文本的合并时失败的情形。</para>
        <warning>
          <para>当<literal>svn:mime-type</literal>属性的值设置为非文本的值时，会根据其它属性导致一些非预期的行为。例如，因为行结束符的概念(因此，行结束符转化)，使得应用到非文本文件时没有意义，Subversion会防止你为文件设置<literal>svn:eol-style</literal>属性，但是如果你递归执行属性设置，这可能不是很清楚了，因为这时Subversion会默默的略过不适合特定属性的文件。</para>
        </warning>
        <para>从Subversion 1.5开始，用户可以配置一个新的<literal>mime-types-file</literal>运行中配置参数，可以作为MIME类型映射文件的定位，Subversion会根据映射文件来确定新添加和导入文件的MIME类型。</para>
        <para>另外，如果设置了<literal>svn:mime-type</literal>属性，Subversion的Apache模块会使用这个值来在HTTP头里输入<literal>Content-type:</literal>，这给了web浏览器如何显示版本库的一个文件提供了至关重要的线索。</para>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.advanced.props.special.executable">
        <info>
          <title>文件的可执行性</title>
        </info>
        <para>在多数操作系统，执行一个文件或命令的能力是由执行位管理的，这些位缺省是关闭的，必须由用户根据需要显式的指定，但是记住应该为哪些检出的文件设置可执行位会是一件很麻烦的事情，所以Subversion提供了<literal>svn:executable</literal>这个属性来保持打开执行位，在工作拷贝得到这些文件时设置执行位。</para>
        <para>这个属性对于没有可执行权限位的文件系统无效，如FAT32和NTFS。 <footnote><para>Windows文件系统使用文件扩展名(如<literal>.EXE</literal>、<literal>.BAT</literal>和<literal>.COM</literal>)来标示可执行文件。</para></footnote>也就是说，尽管它没有定义的值，在设置这个属性时，Subversion会强制它的值为<literal>*</literal>，最后，这个属性只对文件有效，目录无效。</para>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.advanced.props.special.eol-style">
        <info>
          <title>行结束字符序列</title>
        </info>
        <para>除非使用版本化文件的<literal>svn:mime-type</literal>属性注明，Subversion会假定这个文件保存了可读的数据，一般来讲，Subversion只使用这些信息来判断一个文件是否可以用上下文区别的报告，否则，对Subversion来说只是字节。</para>
        <para>这意味着缺省情况下，Subversion不会关注任何<firstterm>行结束标记(end-of-line，EOL)</firstterm>，不幸的是不同的操作系统在文本文件使用不同的行结束标志，举个例子，Windows平台下的A编辑工具使用一对ASCII控制字符—回车(<literal>CR</literal>)和一个换行(<literal>LF</literal>)，而Unix软件，只使用一个<literal>LF</literal>来表示一个行的结束。</para>
        <para>并不是所有操作系统的工具准备好了理解与<firstterm>本地行结束样式</firstterm>不一样的行结束格式，一个常见的结果是Unix程序会把Windows文件中的<literal>CR</literal>当作一个不同的字符(通常表现为<literal>^M</literal>)，而Windows程序会把Unix文件合并为一个非常大的行，因为没有发现标志行结束的回车加换行(或者是<literal>CRLF</literal>)字符。</para>
        <para>对外来EOL标志的敏感会让在多种操作系统分享文件的人们感到沮丧，例如，考虑有一个源代码文件，开发者会在Windows和Unix系统上编辑这个文件，如果所有的用户使用的工具可以展示文件的行结束，那就没有问题了。</para>
        <para>但实践中，许多常用的工具不会正确的读取外来的EOL标志，或者只是在保存文件时将文件的行结束符转化为本地的样式，如果是前者，他需要一个外部的转化工具(如<command>dos2unix</command>，或是他的伴侣<command>unix2dos</command>)来准备需要编辑的文件。后一种情况不需要额外的准备工作，两种方法都会造成文件会与原来的文件在每一行上都不一样！在提交之前，用户有两个选择，或者选择用一个转化工具恢复文件的行结束样式，或者是简单的提交文件—包含新的EOL标志。</para>
        <para>这个情景的结局看起来像是要浪费时间对提交的文件作不必要的修改，浪费时间是痛苦的，但是如果提交修改了文件的每一行，判断文件修改了哪一行会是一件复杂的工作，bug在哪一行修正的？哪一行导致了语法错误？</para>
        <para>这个问题的解决方案是<literal>svn:eol-style</literal>属性，当这个属性设置为一个正确的值时，Subversion使用它来判断针对行结束样式执行何种特殊的操作，而不会随着多种操作系统的每次提交而发生剧烈变化，正确的值有：</para>
        <variablelist>
          <varlistentry>
            <term>
              <literal>native</literal>
            </term>
            <listitem>
              <para>这会导致保存EOL标志的文件使用Subversion运行的操作系统的本地编码，换句话说，如果一个Windows用户取出一个工作拷贝包含的文件设置<literal>native</literal>的属性为<literal>svn:eol-style</literal>，这个文件会使用<literal>CRLF</literal>的EOL标志，一个Unix用户取出相同的文件会看到他的文件使用<literal>LF</literal>的EOL标志。</para>
              <para>注意Subversion实际上使用<literal>LF</literal>的EOL标志，而不会考略操作系统，尽管这对用户来说是透明的。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>CRLF</literal>
            </term>
            <listitem>
              <para>这会导致这个文件使用<literal>CRLF</literal>序列作为EOL标志，不管使用何种操作系统。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>LF</literal>
            </term>
            <listitem>
              <para>这会导致文件使用<literal>LF</literal>字符作为EOL标志，不管使用何种操作系统。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>CR</literal>
            </term>
            <listitem>
              <para>这会导致文件使用<literal>LF</literal>字符作为EOL标志，不管使用何种操作系统。</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.advanced.props.special.ignore">
      <info>
        <title>忽略未版本控制的条目</title>
      </info>
      <para>在任何工作拷贝，将版本化文件和目录与没有也不准备版本化的文件分开会是非常常见的情况。文本编辑器的备份文件会将目录搞乱，代码编译过程中生成的中间文件，甚至最终文件也不是你希望版本化的，用户在见到这些文件和目录(经常是版本控制工作拷贝中)的任何时候都会将他们删除。</para>
      <para>期望让Subversion的工作拷贝摆脱混乱保持干净是可笑的，实际上Subversion将工作拷贝是普通目录作为它的一项<emphasis>特性</emphasis>。但是这些没有版本化的文件和目录会给Subversion用户带来一些烦恼，例如，因为<command>svn add</command>和<command>svn import</command>命令都是会递归执行的，并不知道哪些文件你不希望版本化，很容易意外的添加一些文件。因为<command>svn status</command>会报告工作拷贝中包括未版本化文件和目录的信息，如果这种文件很多，它的输出会变得非常嘈杂。</para>
      <para>所以Subversion提供了两种方法让你指明哪些文件可以被漠视，一种方法需要你修改Subversion的运行配置系统(见<xref linkend="svn.advanced.confarea"/>)，这样会使所有的Subversion操作都利用这个配置，通常来说，这是在某一个计算机上的操作，或者是某个计算机某个用户的操作。另一种方法利用了Subversion目录属性支持，与版本化的目录树紧密结合，因而会影响所有拥有这个目录树工作拷贝的人。两种机制都使用文件模式。</para>
      <para>Subversion运行配置系统提供一个<literal>global-ignores</literal>选项，其中的值是空格分开的文件名模式(或glob)。这些模式会应用到可以添加到版本控制的候选者，也就是<command>svn status</command>显示出来的未版本化文件。如果文件名与其中的某个模式匹配，Subversion会当这个文件不存在。这个文件模式最好是全局不期望版本化的模式，例如编辑器Emacs的备份文件<literal>*~</literal>和<literal>.*~</literal>。</para>
      <sidebar>
        <info>
          <title>Subversion 中的文件模式？</title>
        </info>
        <para>文件模式(也叫做<firstterm>globs</firstterm>或<firstterm>shell wildcard patterns</firstterm>)用来匹配文件名的字符串，通常是用来在无需输入完成文件名的情况下快速选择类似文件的一个子集，这个模式包含两种字符：普通字符，是与潜在匹配的明确比较，和特殊通配符，用来解释不同的匹配目标。</para>
        <para>文件模式语法有不同的类型，但是Unix系统实现中Subversion使用最常见的<function>fnmatch</function>系统函数，支持如下的通配符，为了你的便利有一些简短的描述：</para>
        <variablelist>
          <varlistentry>
            <term>
              <literal>?</literal>
            </term>
            <listitem>
              <para>匹配单个字符</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>*</literal>
            </term>
            <listitem>
              <para>匹配任何字符串，包括空字符串。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>[</literal>
            </term>
            <listitem>
              <para>开始一个字符类定义，由<literal>]</literal>结束，用来匹配一组字符串的子集。</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <para>你可以在Unix的shell提示符中看到同样的模式匹配，下面是一些不同方式使用模式的例子：</para>
        <screen>
$ ls   ### the book sources
appa-quickstart.xml             ch06-server-configuration.xml
appb-svn-for-cvs-users.xml      ch07-customizing-svn.xml
appc-webdav.xml                 ch08-embedding-svn.xml
book.xml                        ch09-reference.xml
ch00-preface.xml                ch10-world-peace-thru-svn.xml
ch01-fundamental-concepts.xml   copyright.xml
ch02-basic-usage.xml            foreword.xml
ch03-advanced-topics.xml        images/
ch04-branching-and-merging.xml  index.xml
ch05-repository-admin.xml       styles.css
$ ls ch*   ### the book chapters
ch00-preface.xml                ch06-server-configuration.xml
ch01-fundamental-concepts.xml   ch07-customizing-svn.xml
ch02-basic-usage.xml            ch08-embedding-svn.xml
ch03-advanced-topics.xml        ch09-reference.xml
ch04-branching-and-merging.xml  ch10-world-peace-thru-svn.xml
ch05-repository-admin.xml
$ ls ch?0-*   ### the book chapters whose numbers end in zero
ch00-preface.xml  ch10-world-peace-thru-svn.xml
$ ls ch0[3578]-*   ### the book chapters that Mike is responsible for
ch03-advanced-topics.xml   ch07-customizing-svn.xml
ch05-repository-admin.xml  ch08-embedding-svn.xml
$
</screen>
        <para>文件模式匹配可能比我们这里描述更复杂一点，但是基本的使用水平会适合大多数Subversion的用户。</para>
      </sidebar>
      <para>如果是在版本化目录上发现<literal>svn:ignore</literal>属性，其内容是一列以行分割的文件模式，Subversion用来判断在这个目录下对象是否被忽略。这些模式不会覆盖在运行配置设置的全局忽略，而是向其添加忽略模式。不像全局忽略选项，在<literal>svn:ignore</literal>属性中设置的值只会应用到其设置的目录，而不会应用到其子目录。<literal>svn:ignore</literal>属性是告诉Subversion在每个用户的工作拷贝对应目录忽略相同的文件的好方法，例如编译输出或—使用一个本书相关的例子—本书从DocBook XML文件生成的HTML、PDF或PostScript。</para>
      <note>
        <para>Subversion对于忽略文件模式的支持仅限于将未版本化文件和目录添加到版本控制时，如果一个文件已经在Subversion控制下，忽略模式机制不会再有效果，不要期望Subversion会阻止你提交一个符合忽略条件的修改—Subversion一直认为它是版本化的对象。</para>
      </note>
      <sidebar>
        <info>
          <title>CVS 用户的忽略模式</title>
        </info>
        <para>Subversion的<literal>svn:ignore</literal>属性与CVS的<filename>.cvsignore</filename>文件的语法和功能非常类似，实际上，如果你移植一个CVS的工作拷贝到Subversion，你可以直接使用<filename>.cvsignore</filename>作为<command>svn propset</command>输入文件参数：</para>
        <screen>
$ svn propset svn:ignore -F .cvsignore .
property 'svn:ignore' set on '.'
$
</screen>
        <para>但是CVS和Subversion处理忽略模式的方式有一些不同，这两个系统在不同的时候使用忽略模式，忽略模式应用的对象也由微小的不同，另外Subversion不可以使用<literal>!</literal>模式来去取消忽略模式。</para>
      </sidebar>
      <para>全局忽略模式只是一种个人喜好，可能更接近于用户的特定工具链，而不是特定工作拷贝的需要，所以余下的小节将关注<literal>svn:ignore</literal>属性和它的使用。</para>
      <para>假定你的<command>svn status</command>有如下输出：</para>
      <screen>
$ svn status calc
 M     calc/button.c
?      calc/calculator
?      calc/data.c
?      calc/debug_log
?      calc/debug_log.1
?      calc/debug_log.2.gz
?      calc/debug_log.3.gz
</screen>
      <para>在这个例子里，你对<filename>button.c</filename>文件作了一些属性修改，但是你的工作拷贝也有一些未版本化的文件：你从源代码编译的最新<filename>计算器</filename>程序，一系列调试输出日志文件，现在你知道你的编译系统一直会编译生成<filename>计算器</filename>程序。 <footnote><para>这不是编译系统的基本功能吗？</para></footnote>而且你知道你的测试组件总是会留下这些调试日志，这对所有的工作拷贝都是一样的，不仅仅是你的。你也知道你不会有兴趣在<command>svn status</command>命令中显示这些信息，所以使用<command>svn propedit svn:ignore calc</command>来为<filename>calc</filename>目录增加一些忽略模式，举个例子，你或许会添加如下的值作为<literal>svn:ignore</literal>的属性：</para>
      <programlisting>
calculator
debug_log*
</programlisting>
      <para>当你添加完这些属性，你会在<filename>calc</filename>目录有一个本地修改，但是注意你的<command>svn status</command>输出有什么其他的不同：</para>
      <screen>
$ svn status
 M     calc
 M     calc/button.c
?      calc/data.c
</screen>
      <para>现在，所有多余的输出不见了！当然，你的<filename>计算器</filename>程序和所有的日志文件还在工作拷贝中，Subversion仅仅是不再提醒你它们的存在和未版本化。现在所有讨厌的噪音都已经不再显示，只留下了你感兴趣的条目—如你忘记添加到版本控制的源代码文件<filename>data.c</filename>。</para>
      <para>当然，不仅仅只有这种简略的工作拷贝状态输出，如果想查看被忽略的文件，可以使用Subversion的<option>--no-ignore</option>选项：</para>
      <screen>
$ svn status --no-ignore
 M     calc
 M     calc/button.c
I      calc/calculator
?      calc/data.c
I      calc/debug_log
I      calc/debug_log.1
I      calc/debug_log.2.gz
I      calc/debug_log.3.gz
</screen>
      <para>我们在前面提到过，<command>svn add</command>和<command>svn import</command>也会使用这个忽略模式列表，这两个操作都包括了询问Subversion来开始管理一组文件和目录。比强制用户挑拣目录树中那个文件要纳入版本控制的方式更好，Subversion使用忽略模式来检测那个文件不应该在大的迭代添加和导入操作中进入版本控制系统。再次说明，操作Subversion文件和目录时你可以使用<option>--no-ignore</option>选项忽略这个忽略列表。</para>
      <tip>
        <para>即使设置了<literal>svn:ignore</literal>，你还是会在使用shell通配符时遇到问题。在Subversion实际操作之前，shell通配符会被扩展成了目标的立标，所以运行<command>svn <replaceable>SUBCOMMAND</replaceable> *</command>就像你运行<command>svn <replaceable>SUBCOMMAND</replaceable> file1 file2 file3 …</command>。如果是<command>svn add</command>的情况，这与传递 <option>--no-ignore</option>选项的效果类似。所以作为使用通配符的替代，使用<command>svn add --force .</command>会导致大块的未版本化文件的预订提交。明确的目标可以保证不会因为已经纳入版本控制的内容导致目录过度搜索，<option>--force</option>选项会导致Subversion遍历目录，在尊重<literal>svn:ignore</literal>属性和<literal>global-ignores</literal>运行配置变量的情况下添加未版本化的文件。如果你不希望完全的递归所有的目录，一定要确认也要为<command>svn add</command>添加<option>--depth files</option>选项。</para>
      </tip>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.advanced.props.special.keywords">
      <info>
        <title>关键字替换</title>
      </info>
      <para>Subversion具备添加<firstterm>关键字</firstterm>的能力—一些有用的，关于版本化的文件动态信息的片断—不必直接添加到文件本身。关键字通常会用来描述文件最后一次修改的一些信息，因为这些信息每次都有改变，更重要的一点，这是在文件修改<emphasis>之后</emphasis>，除了版本控制系统，对于任何企图保持数据最新的过程都是一场混乱，作为人类作者，信息变得陈旧是不可避免的。</para>
      <para>举个例子，你有一个文档希望显示最后修改的日期，你需要麻烦每个作者提交之前做这件事情，也要修改文档的一部分来描述何时作的修改，但是迟早会有人忘记做这件事，不选择简单的告诉Subversion来执行替换<literal>LastChangedDate</literal>关键字的操作，你通过在目标位置放置一个<firstterm>keyword anchor</firstterm>来控制关键字插入的位置，这个anchor只是一个格式为<literal>$</literal><replaceable>KeywordName</replaceable><literal>$</literal>字符串。</para>
      <para>所有作为anchor出现在文件里的关键字是大小写敏感的：为了关键字的扩展，你必须使用正确的大写，你必须考虑<literal>svn:keywords</literal>的属性值也是大小写敏感—特定的关键字名会忽略大小写，但是这个特性已经被废弃了。</para>
      <para>Subversion定义了用来替换的关键字列表，这个列表保存了如下五个关键字，有一些也包括了可用的别名：</para>
      <variablelist>
        <varlistentry>
          <term>
            <literal>Date</literal>
          </term>
          <listitem>
            <para>这个关键字保存了文件最后一次在版本库修改的日期，看起来类似于<literal>$Date: 2006-07-22 21:42:37 -0700 (Sat, 22 Jul 2006) $</literal>，它也可以用<literal>LastChangedDate</literal>来指定。</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>Revision</literal>
          </term>
          <listitem>
            <para>这个关键字描述了这个文件最后一次修改的修订版本，看起来像<literal>$Revision: 144 $</literal>，也可以通过<literal>LastChangedRevision</literal>或者<literal>Rev</literal>引用。</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>Author</literal>
          </term>
          <listitem>
            <para>这个关键字描述了最后一个修改这个文件的用户，看起来类似<literal>$Author: harry $</literal>，也可以用<literal>LastChangedBy</literal>来指定。</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>HeadURL</literal>
          </term>
          <listitem>
            <para>这个关键字描述了这个文件在版本库最新版本的完全URL，看起来类似<literal>$HeadURL: http://svn.collab.net/repos/trunk/README $</literal>，可以缩写为<literal>URL</literal>。</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>Id</literal>
          </term>
          <listitem>
            <para>这个关键字是其他关键字一个压缩组合，它看起来就像<literal>$Id: calc.c 148 2006-07-28 21:30:43Z sally $</literal>，可以解释为文件<filename>calc.c</filename>上一次修改的修订版本号是148，时间是2006年7月28日，作者是<literal>sally</literal>。这个关键字中显示的日期是UTC的，与<literal>Date</literal>关键字不一样(使用本地时区)。</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>前面的一些描述使用了类似<quote>最后已知的</quote>短语，请记住关键字扩展是客户端操作，你的客户端只<quote>知道</quote>在你更新工作拷贝时版本库发生的修改，如果你从不更新工作拷贝，即使文件在版本库里有规律的修改，这些关键字也不会扩展为不同的值。</para>
      <para>只在你的文件增加关键字anchor不会做什么特别的事情，Subversion不会尝试对你的文件内容执行文本替换，除非明确的被告知这样做，毕竟，你可以撰写一个关于如何使用关键字的文档<footnote><para>… 或者可能是一本书的一个小节 …</para></footnote>，你不希望Subversion会替换你漂亮的关于不需要替换的关键字anchor实例！</para>
      <para>为了告诉Subversion是否替代某个文件的关键字，我们要再次求助于属性相关的子命令，当<literal>svn:keywords</literal>属性设置到一个版本化的文件，这些属性控制了哪些关键字将会替换到这个文件，这个属性的值是空格分隔的前面列表的名称或是别名列表。</para>
      <para>举个例子，假定你有一个版本化的文件<filename>weather.txt</filename>，内容如下：</para>
      <programlisting>
Here is the latest report from the front lines.
$LastChangedDate$
$Rev$
Cumulus clouds are appearing more frequently as summer approaches.
</programlisting>
      <para>当没有<literal>svn:keywords</literal>属性设置到这个文件，Subversion不会有任何特别操作，现在让我们允许<literal>LastChangedDate</literal>关键字的替换。</para>
      <screen>
$ svn propset svn:keywords "Date Author" weather.txt
property 'svn:keywords' set on 'weather.txt'
$
</screen>
      <para>现在你已经对<filename>weather.txt</filename>的属性作了修改，你会看到文件的内容没有改变(除非你之前做了一些属性设置)，注意这个文件包含了<literal>Rev</literal>的关键字anchor，但我们没有在属性值中包括这个关键字，Subversion会高兴的忽略替换这个文件中的关键字，也不会替换<literal>svn:keywords</literal>属性中没有出现的关键字。</para>
      <para>在你提交了属性修改后，Subversion会立刻更新你的工作文件为新的替代文本，你将无法找到<literal>$LastChangedDate$</literal>的关键字anchor，你会看到替换的结果，这个结果也保存了关键字的名字，与美元符号(<literal>$</literal>)绑定在一起，而且我们预测的，<literal>Rev</literal>关键字不会被替换，因为我们没有要求这样做。</para>
      <para>注意我们设置<literal>svn:keywords</literal>属性为<quote>Date Author</quote>，关键字anchor使用别名<literal>$LastChangedDate$</literal>并且正确的扩展。</para>
      <screen>
Here is the latest report from the front lines.
$LastChangedDate: 2006-07-22 21:42:37 -0700 (Sat, 22 Jul 2006) $
$Rev$
Cumulus clouds are appearing more frequently as summer approaches.
</screen>
      <para>如果有其他人提交了<filename>weather.txt</filename>的修改，你的此文件的拷贝还会显示同样的替换关键字值—直到你更新你的工作拷贝，此时你的<filename>weather.txt</filename>重的关键字将会被替换来反映最新的提交信息。</para>
      <sidebar>
        <info>
          <title>$GlobalRev$ 是什么？</title>
        </info>
        <para>新用户经常为如何使用<literal>$Rev$</literal>关键字迷惑，自从版本库有了单独的全局增长的修订版本号码，许多人以为<literal>$Rev$</literal>关键字是反映修订版本号码的，但实际上<literal>$Rev$</literal>是文件最后修改的修订版本，而不是最后更新的。理解这一点，会减少一些混淆，但是还有一些挫折—如果没有Subversion关键字的支持，你怎么才能在你的文件自动得到全局修订版本号？</para>
        <para>为此你需要外置处理，Subversion中有一个工具<command>svnversion</command>就是为此设计。<command>svnversion</command>遍历你的工作拷贝，然后输出它发现的修订版本，你可以使用这个程序，外加一些工具，将修订版本信息嵌入到你的文件。关于<command>svnversion</command>的更多信息，见<xref linkend="svn.ref.svnversion"/>。</para>
      </sidebar>
      <para>Subversion 1.2引入了另一种关键字的语法，提供了额外和有用的，尽管是非典型的功能。你现在可以告诉Subversion为替代的关键字维护一个固定长度(从消耗字节的观点)，通过在关键字名后使用双冒号(<literal>::</literal>)，然后紧跟一组空格，你就定义了固定宽度。当Subversion使用替代值代替你的关键字，只会替换这些空白字符，保持关键字字段长度保持不变，如果替代值比定义的字段短，会有替代字段后保留空格；如果替代值太长，就会在最后的美元符号终止符前用井号(<literal>#</literal>)截断。</para>
      <para>例如，你有一篇文档，其中一段是一些反映Subversion关键字的表格数据，使用原始的Subversion关键字替换语法，你的文件或许像这样：</para>
      <screen>
$Rev$:     Revision of last commit
$Author$:  Author of last commit
$Date$:    Date of last commit
</screen>
      <para>现在，表格看起来佷漂亮，但是当你提交文件(当然，关键字替换功能已打开)，你会看到：</para>
      <screen>
$Rev: 12 $:     Revision of last commit
$Author: harry $:  Author of last commit
$Date: 2006-03-15 02:33:03 -0500 (Wed, 15 Mar 2006) $:    Date of last commit
</screen>
      <para>结果并不漂亮，你可能会尝试重新调整文件使之更像一个列表。只有关键字的长度是相同的时候才能保证保持样式，如果进入另一个修订版本(如从99到100)，或者是另一个有较长用户名的人提交了文件，表格又会变形。然而，如果你使用Subversion 1.2，你可以使用新的固定长度的关键字语法，定义合适的字段宽度，然后你的文件可能如此：</para>
      <screen>
$Rev::               $:  Revision of last commit
$Author::            $:  Author of last commit
$Date::              $:  Date of last commit
</screen>
      <para>你提交这个文件的修改，这一次Subversion注意到了新的固定长度的关键字语法，根据你在双冒号之间指定的空格长度调整格式，并且紧跟一个美元符号。经过替换，字段的长度没有发生变化—<literal>Rev</literal>和<literal>Author</literal>多了一些空格，而较长的<literal>Date</literal>字段被一个分号截断：</para>
      <screen>
$Rev:: 13            $:  Revision of last commit
$Author:: harry      $:  Author of last commit
$Date:: 2006-03-15 0#$:  Date of last commit
</screen>
      <para>固定长度关键字在执行复杂文件格式的替换中非常易用，也可以处理那些很难通过其他程序(例如Microsoft Office文档)进行修改的文件。</para>
      <warning>
        <para>需要意识到，因为关键字字段的长度是以字节为单位，可能会破坏多字节值，例如一个用户名包含多字节的UTF-8字符，可能会遭遇从某个字符中间截断的情况，从字节角度看仅仅是一种截断，但是从UTF-8字符串角度看可能是错误和曲解的，当载入文件时，破坏的UTF-8文本可能导致整个文件的破坏，整个文件无法操作。所以，当限制关键字为固定大小时，需要选择一个可以扩展的大小。</para>
      </warning>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.advanced.sparsedirs">
      <info>
        <title>稀疏目录</title>
      </info>
      <para>By default, most Subversion operations on directories act in
      a recursive manner.  For example, <command>svn
      checkout</command> creates a working copy with every file and
      directory in the specified area of the repository, descending
      recursively through the repository tree until the entire
      structure is copied to your local disk.  Subversion 1.5
      introduces a feature called <firstterm>sparse
      directories</firstterm> (or <firstterm>shallow
      checkouts</firstterm>) that allows you to easily check out a
      working copy—or a portion of a working copy—more
      shallowly than full recursion, with the freedom to bring in
      previously ignored files and subdirectories at a later
      time.</para>
      <para>For example, say we have a repository with a tree of files
      and directories with names of the members of a human family with
      pets.  (It's an odd example, to be sure, but bear with us.)  A
      regular <command>svn checkout</command> operation will give us a
      working copy of the whole tree:</para>
      <screen>
$ svn checkout file:///var/svn/repos mom
A    mom/son
A    mom/son/grandson
A    mom/daughter
A    mom/daughter/granddaughter1
A    mom/daughter/granddaughter1/bunny1.txt
A    mom/daughter/granddaughter1/bunny2.txt
A    mom/daughter/granddaughter2
A    mom/daughter/fishie.txt
A    mom/kitty1.txt
A    mom/doggie1.txt
Checked out revision 1.
$
</screen>
      <para>Now, let's check out the same tree again, but this time
      we'll ask Subversion to give us only the topmost directory
      with none of its children at all:</para>
      <screen>
$ svn checkout file:///var/svn/repos mom-empty --depth empty
Checked out revision 1
$
</screen>
      <para>Notice that we added to our original <command>svn
      checkout</command> command line a new <option>--depth</option>
      option.  This option is present on many of Subversion's
      subcommands and is similar to the
      <option>--non-recursive</option> (<option>-N</option>) and
      <option>--recursive</option> (<option>-R</option>) options.  In
      fact, it combines, improves upon, supercedes, and ultimately
      obsoletes these two older options.  For starters, it expands the
      supported degrees of depth specification available to users,
      adding some previously unsupported (or inconsistently supported)
      depths.  Here are the depth values that you can request for a
      given Subversion operation:</para>
      <variablelist>
        <varlistentry>
          <term>
            <literal>--depth empty</literal>
          </term>
          <listitem>
            <para>Include only the immediate target of the operation,
            not any of its file or directory children.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>--depth files</literal>
          </term>
          <listitem>
            <para>Include the immediate target of the operation and any
            of its immediate file children.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>--depth immediates</literal>
          </term>
          <listitem>
            <para>Include the immediate target of the operation and any
            of its immediate file or directory children.  The directory
            children will themselves be empty.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>--depth infinity</literal>
          </term>
          <listitem>
            <para>Include the immediate target, its file and directory
            children, its children's children, and so on to full
            recursion.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>Of course, merely combining two existing options into one
      hardly constitutes a new feature worthy of a whole section in
      our book.  Fortunately, there is more to this story.  This idea
      of depth extends not just to the operations you perform with
      your Subversion client, but also as a description of a working
      copy citizen's <firstterm>ambient depth</firstterm>, which is
      the depth persistently recorded by the working copy for that
      item.  Its key strength is this very persistence—the fact
      that it is <firstterm>sticky</firstterm>.  The working copy
      remembers the depth you've selected for each item in it until
      you later change that depth selection; by default, Subversion
      commands operate on the working copy citizens present,
      regardless of their selected depth settings.</para>
      <tip>
        <para>You can check the recorded ambient depth of a working copy
        using the <command>svn info</command> command.  If the ambient
        depth is anything other than infinite recursion, <command>svn
        info</command> will display a line describing that depth
        value:</para>
        <screen>
$ svn info mom-immediates | grep '^Depth:'
Depth: immediates
$
</screen>
      </tip>
      <para>Our previous examples demonstrated checkouts of infinite
      depth (the default for <command>svn checkout</command>) and
      empty depth.  Let's look now at examples of the other depth
      values:</para>
      <screen>
$ svn checkout file:///var/svn/repos mom-files --depth files
A    mom-files/kitty1.txt
A    mom-files/doggie1.txt
Checked out revision 1.
$ svn checkout file:///var/svn/repos mom-immediates --depth immediates
A    mom-immediates/son
A    mom-immediates/daughter
A    mom-immediates/kitty1.txt
A    mom-immediates/doggie1.txt
Checked out revision 1.
$
</screen>
      <para>As described, each of these depths is something more than
      only the target, but something less than full recursion.</para>
      <para>We've used <command>svn checkout</command> as an example
      here, but you'll find the <option>--depth</option> option
      present on many other Subversion commands, too.  In those other
      commands, depth specification is a way to limit the scope of an
      operation to some depth, much like the way the older
      <option>--non-recursive</option> (<option>-N</option>) and
      <option>--recursive</option> (<option>-R</option>) options
      behave.  This means that when operating on a working copy of
      some depth, while requesting an operation of a shallower depth,
      the operation is limited to that shallower depth.  In fact, we
      can make an even more general statement: given a working copy of
      any arbitrary—even mixed—ambient depth, and a
      Subversion command with some requested operational depth, the
      command will maintain the ambient depth of the working copy
      members while still limiting the scope of the operation to the
      requested (or default) operational depth.</para>
      <para>In addition to the <option>--depth</option> option, the
      <command>svn update</command> and <command>svn switch</command>
      subcommands also accept a second depth-related option:
      <option>--set-depth</option>.  It is with this option that you
      can change the sticky depth of a working copy item.  Watch what
      happens as we take our empty-depth checkout and gradually
      telescope it deeper using <userinput>svn update
      --set-depth <replaceable>NEW-DEPTH</replaceable> <replaceable>TARGET</replaceable></userinput>:</para>
      <screen>
$ svn update --set-depth files mom-empty
A    mom-empty/kittie1.txt
A    mom-empty/doggie1.txt
Updated to revision 1.
$ svn update --set-depth immediates mom-empty
A    mom-empty/son
A    mom-empty/daughter
Updated to revision 1.
$ svn update --set-depth infinity mom-empty
A    mom-empty/son/grandson
A    mom-empty/daughter/granddaughter1
A    mom-empty/daughter/granddaughter1/bunny1.txt
A    mom-empty/daughter/granddaughter1/bunny2.txt
A    mom-empty/daughter/granddaughter2
A    mom-empty/daughter/fishie1.txt
Updated to revision 1.
$
</screen>
      <para>随着我们逐渐的增加我们的depth选择，版本库给我们目录树的片段。</para>
      <para>在我们的例子里，我们只操作我们工作拷贝的根，修改其周围的depth值，但是我们可以独立的修改工作拷贝任何子目录的depth值。小心的使用这个能力允许我们充实工作拷贝树的一部分，而让其他部分不需参与(因此是特性名称的<quote>稀疏</quote>部分)。下面是我们可能如何构建分支的一部分的例子，为另一个分支开启完全的递归，保持其他部分是被修剪的(不在磁盘里)。</para>
      <screen>
$ rm -rf mom-empty
$ svn checkout file:///var/svn/repos mom-empty --depth empty
Checked out revision 1.
$ svn update --set-depth empty mom-empty/son
A    mom-empty/son
Updated to revision 1.
$ svn update --set-depth empty mom-empty/daughter
A    mom-empty/daughter
Updated to revision 1.
$ svn update --set-depth infinity mom-empty/daughter/granddaughter1
A    mom-empty/daughter/granddaughter1
A    mom-empty/daughter/granddaughter1/bunny1.txt
A    mom-empty/daughter/granddaughter1/bunny2.txt
Updated to revision 1.
$
</screen>
      <para>幸运的是，在单个工作拷贝中有一组复杂depth的设置不会让你与工作拷贝的交互变的更复杂，你仍可以回退、显示和提交工作拷贝的本地修改，而不必为相关子命令提供任何新的选项(包括<option>--depth</option>或<option>--set-depth</option>)，即使<command>svn update</command>和没有提供任何depth一样工作—它更新工作拷贝目标，并遵守相关的depth设置。</para>
      <para>You might at this point be wondering, <quote>So what?  When
      would I use this?</quote>  One scenario where this feature
      finds utility is tied to a particular repository layout,
      specifically where you have many related or codependent
      projects or software modules living as siblings in a single
      repository location (<filename>trunk/project1</filename>,
      <filename>trunk/project2</filename>,
      <filename>trunk/project3</filename>, etc.).  In such
      scenarios, it might be the case that you personally care 
      about only a handful of those projects—maybe some primary
      project and a few other modules on which it depends.  You can
      check out individual working copies of all of these things, but
      those working copies are disjoint and, as a result, it can be
      cumbersome to perform operations across several or all of them
      at the same time.  The alternative is to use the sparse
      directories feature, building out a single working copy that
      contains only the modules you care about.  You'd start with an
      empty-depth checkout of the common parent directory of the
      projects, and then update with infinite depth only the items you
      wish to have, like we demonstrated in the previous example.
      Think of it like an opt-in system for working copy
      citizens.</para>
      <para>Subversion 1.5's implementation of shallow checkouts is
      good but does not support a couple of interesting behaviors.
      First, you cannot de-telescope a working copy item.  Running
      <userinput>svn update --set-depth empty</userinput> in an
      infinite-depth working copy will not have the effect of
      discarding everything but the topmost directory—it will
      simply error out.  Second, there is no depth value to indicate
      that you wish an item to be explicitly excluded.  You have to do
      implicit exclusion of an item by including everything
      else.</para>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.advanced.locking">
      <info>
        <title>锁定</title>
      </info>
      <para>Subversion的拷贝-修改-合并版本控制模型的关键是其合并算法，也就是如何处理多个用户修改同时修改一个文件产生冲突时的算法。Subversion本身只提供了一个这样的算法，其三方区别算法可以足够聪明的的行粒度的数据处理，Subversion也支持使用外置比较工具(<xref linkend="svn.advanced.externaldifftools.diff3"/>中有描述)，有一些可以做得非常好，或许可以提供以单词或字母粒度的算法。但是，这些工具的共同点是基于文本的，当你讨论非文本文件格式时，这看起来有一点残酷。如果你无法找到一个工具支持这种类型的合并，你的拷贝-修改-合并模型就会遇到麻烦。</para>
      <para>让我们看一个使用这个模型的真实例子，Harry和Sally是同一个项目的图形设计师，汽车技工的间接营销。海报的设计一个小车，需要一些主要部分的工作，使用PNG文件格式。海报的布局几乎完成，Harry和Sally都看上了一个从损坏小车得到的特别照片—一个1967的淡蓝色的Ford Mustang，挡泥板有一些溅迹。</para>
      <para>现在，作为图像设计的惯例，计划的改变导致车的颜色很重要，所以Sally将工作拷贝更新到<literal>HEAD</literal>，启动图形编辑软件，修改图像将车的颜色修改为樱桃红，同时Harry那一天特别有灵感，所以决定如果这个车受到更大的撞击可能会有更好的效果。他也更新到<literal>HEAD</literal>，然后在车挡风玻璃上制作了一些裂痕，他设法在Sally完成前结束修改，因为受到自己不可阻挡天赋的鼓舞，提交了图像。没过多久，Sally结束了她的工作，尝试提交。但是如我们所料，Subversion提交失败，告诉Sally她的图像已经过期了。</para>
      <para>这里就是麻烦的地方，如果Harry和Sally修改的是文本文件，她只需要简单得更新工作拷贝，接收Harry的修改。在最坏的情况下，他们会修改文件的同一部分，Sally需要人工解决冲突。但是现在不是文本文件—而是二进制图像，没法估计合并的结果会是什么样子的，已存的软件不可能从基线图像分离出Harry和Sally的工作，并组合出一个挡风玻璃坏掉的红色Mustang。</para>
      <para>很显然，如果能够将Harry和Sally的工作串行话事情会变得平滑，也就是说Harry可以等到Sally的红车然后再画上破坏的挡风玻璃，或者Sally在破坏之后改变颜色。就像在<xref linkend="svn.basic.vsn-models.copy-merge"/>讨论的，如果Harry和Sally之间有完美的交流，就不会有这种问题发生。<footnote><para>对于Harry和Sally的好莱坞同名人来说交流也不是那么差的药，也是关于那一点。</para></footnote>但是作为一种版本控制系统，实际上是一种交流的形式，使得软件遵循非并行编辑的串行化也不是一件坏事，这里Subversion实现了锁定-修改-解锁模型，这里我们要讨论Subversion的<firstterm>锁定</firstterm>特性，与其他版本控制系统的<quote>保留检出</quote>机制类似。</para>
      <para><emphasis>辅助交流</emphasis>。通过要求用户对某个版本化对象串行工作，用户可以知道对象正在被别人修改，这样可以防止浪费精力和时间去修改一个不可合并和提交的对象。</para>
      <para>当我们引用Subversion锁定特性时，这是在讨论一个处理版本化文件的行为特性<footnote><para>Subversion目前不允许锁定目录。</para></footnote>(声明对一个文件排他性修改特权)，包括对文件的锁定和解锁(释放排他性修改权限)，察看包括文件被谁锁定的报告，以及提醒企图修改锁定文件的用户。在本小节，我们会覆盖锁定特性的大部分内容。</para>
      <sidebar xml:id="svn.advanced.locking.meanings">
        <info>
          <title><quote>锁定</quote>的三种含义</title>
        </info>
        <para>在本小节，和几乎本书的每一个地方<quote>lock</quote>和<quote>locking</quote>描述了一种避免用户之间冲突提交的排他机制，但是佷不幸，Subversion中还有另外两种锁，因此需要在本书格外关心。</para>
        <para>第一种是<firstterm>工作拷贝锁</firstterm>，Subversion内部用来防止不同客户端同时操作同一份工作拷贝的锁，这种锁使用<command>svn status</command>输出中第三列出现的<computeroutput>L</computeroutput>表示，可以使用<command>svn cleanup</command>删除，<xref linkend="svn.tour.cleanup"/>有介绍。</para>
        <para>第二种，<firstterm>数据库锁</firstterm>，在Berkeley DB后端内部使用，防止多个程序访问数据库发生冲突，一个导致版本库<quote>楔住</quote>的错误发生后产生，<xref linkend="svn.reposadmin.maint.recovery"/>有描述。</para>
        <para>在发生问题之前你完全可以忘记上面两种锁，在本书，<quote>锁定</quote>意味着第一种锁，除非是在从上下文中十分明确或明确指出的。</para>
      </sidebar>
      <!-- =============================================================== -->
      <section xml:id="svn.advanced.locking.creation">
        <info>
          <title>创建锁定</title>
        </info>
        <para>在Subversion的版本库，一个<firstterm>锁</firstterm>是一份元数据，可以排它赋予某个用户修改权，这个用户被称作<firstterm>锁的拥有者</firstterm>。每个锁都有一个唯一标识，通常是一长串字符，叫做<firstterm>锁令牌</firstterm>。版本库管理锁，控制着锁的创建，权限控制和删除。如果提交包含了修改或者删除锁</para>
        <para>为了描述锁的产生，我们回到前面那个关于多个图形设计师共同工作的例子，Harry决定修改一个JPEG图像，为了防止其他用户此时提交这个文件的修改(也是警告别人他正在修改它)，他使用<command>svn lock</command>命令锁定了版本库中的这个文件：</para>
        <screen>
$ svn lock banana.jpg -m "Editing file for tomorrow's release."
'banana.jpg' locked by user 'harry'.
$
</screen>
        <para>前一个例子描述了许多新事物，第一，注意Harry在<command>svn lock</command>中使用了<option>--message (-m)</option>选项，类似于<command>svn commit</command>，<command>svn lock</command>命令可以有描述锁定原因的注释(通过<option>--message (-m)</option>或<option>--file (-F)</option>)。然而不像<command>svn commit</command>，<command>svn lock</command>不会自动强制启动你喜欢的编辑器，锁定注释是可选的，但是为了方便交流我们还是推荐使用。</para>
        <para>第二，锁定成功了，这意味着文件没有被别人锁定，Harry的文件是最新的版本。如果Harry的工作拷贝文件不是最新的，版本库会拒绝请求，强制Harry执行<command>svn update</command>并重新运行锁定命令，同样，如果此文件已经被别的用户锁定了，锁定命令也会失败。</para>
        <para>就像你看到的，<command>svn lock</command>打印了锁定成功的确认信息。此时，通过<command>svn status</command>和<command>svn info</command>的输出我们可以看到文件已经锁定。</para>
        <screen>
$ svn status
     K banana.jpg

$ svn info banana.jpg
Path: banana.jpg
Name: banana.jpg
URL: http://svn.example.com/repos/project/banana.jpg
Repository UUID: edb2f264-5ef2-0310-a47a-87b0ce17a8ec
Revision: 2198
Node Kind: file
Schedule: normal
Last Changed Author: frank
Last Changed Rev: 1950
Last Changed Date: 2006-03-15 12:43:04 -0600 (Wed, 15 Mar 2006)
Text Last Updated: 2006-06-08 19:23:07 -0500 (Thu, 08 Jun 2006)
Properties Last Updated: 2006-06-08 19:23:07 -0500 (Thu, 08 Jun 2006)
Checksum: 3b110d3b10638f5d1f4fe0f436a5a2a5
Lock Token: opaquelocktoken:0c0f600b-88f9-0310-9e48-355b44d4a58e
Lock Owner: harry
Lock Created: 2006-06-14 17:20:31 -0500 (Wed, 14 Jun 2006)
Lock Comment (1 line):
Editing file for tomorrow's release.

$
</screen>
        <para><command>svn info</command>命令不会联系版本库，当对工作拷贝路径应用<command>svn info</command>命令时，可以揭示令牌的一个重要事实—它们缓存在工作拷贝。有锁定令牌是非常重要的，这给了工作拷贝权利利用这个锁的能力。<command>svn status</command>会在文件后面显示一个<literal>K</literal>(locKed的缩写)，表明了拥有锁定令牌。</para>
        <sidebar>
          <info>
            <title>关于锁定令牌</title>
          </info>
          <para>一个锁不是一个认证令牌，而是一个<emphasis>授权</emphasis>令牌，这个令牌不是一个受保护的秘密，事实上，任何人都可以通过<command>svn info URL</command>发现这个唯一令牌。一个锁定令牌只有在工作拷贝中才有特别的意义，它是锁定建立在这个工作拷贝的证据，而不是其它用户在其他地方，仅仅检验锁定拥有者还不能防止出现意外。</para>
          <para>例如，你在办公室电脑上锁定了一个文件，或许修改正在进行中。很有可能在你的家用计算机上的一个工作拷贝(或别的Subversion客户端)里你又不小心修改了同一个文件，仅仅因为检验了你就是锁定的拥有者。换句话说，锁定令牌防止你通过一个Subversion相关软件的工作破坏另一个的工作。(在我们的例子里，如果你真的需要在另一个工作拷贝修改这个文件，你必须<firstterm>打破</firstterm>锁定再重新锁定文件。)</para>
        </sidebar>
        <para>现在Harry已经锁定了<filename>banana.jpg</filename>，Sally不能修改或删除这个文件：</para>
        <screen>
$ svn delete banana.jpg
D         banana.jpg
$ svn commit -m "Delete useless file."
Deleting       banana.jpg
svn: Commit failed (details follow):
svn: Server sent unexpected return value (423 Locked) in response to DELETE\
 request for '/repos/project/!svn/wrk/64bad3a9-96f9-0310-818a-df4224ddc35d/\
banana.jpg'
$
</screen>
        <para>但是，当完成了香蕉的黄色渐变，就可以提交文件的修改，因为认证为锁定的拥有者，也因为他的工作拷贝有正确的锁定令牌：</para>
        <screen>
$ svn status
M    K banana.jpg
$ svn commit -m "Make banana more yellow"
Sending        banana.jpg
Transmitting file data .
Committed revision 2201.
$ svn status
$
</screen>
        <para>需要注意到提交之后，<command>svn status</command>显示工作拷贝已经没有锁定令牌了，这是<command>svn commit</command>的标准行为方式—它会遍历工作拷贝(或者从目标列表，如果有列表的话)，并且作为提交的一部分发送所有遇到的锁定令牌到服务器。当提交完全成功，前面用到的所有版本库锁定都会被释放—<emphasis>即使是没有提交的文件。</emphasis>这样的原因是不鼓励用户滥用锁定，或者是长时间的保持锁定。例如，假定Harry不小心锁定了<filename>images</filename>目录的30个文件，因为他不确定要修改什么文件，他最后只修改了四个文件，当他运行<command>svn commit images</command>，会释放所有的30个锁定。</para>
        <para>自动释放锁定的特性可以通过<command>svn commit</command>的<option>--no-unlock</option>选项关闭，当你要提交文件，同时期望继续修改而必须保留锁定时非常有用。这个特性也可以半永久性的设定，方法是设置运行中<filename>config</filename>文件(见<xref linkend="svn.advanced.confarea"/>)的<literal>no-unlock = yes</literal>。</para>
        <para>当然，锁定一个文件不会强制一个人要提交修改，任何时候都可以通过运行<command>svn unlock</command>命令释放锁定：</para>
        <screen>
$ svn unlock banana.c
'banana.c' unlocked.
</screen>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.advanced.locking.discovery">
        <info>
          <title>发现锁定</title>
        </info>
        <para>最明显的方式就是因为锁定而不能提交一个文件，最简单的方式是<command>svn status --show-updates</command>：</para>
        <screen>
$ svn status -u
M              23   bar.c
M    O         32   raisin.jpg
       *       72   foo.h
Status against revision:     105
$
</screen>
        <para>在这个例子里，Sally可以见到不仅她的<filename>foo.h</filename>是过期的，而且发现两个计划要提交的文件被锁定了。<literal>O</literal>符号表示其他人所订了文件。如果她尝试提交，<filename>raisin.jpg</filename>的锁定会阻止她，Sally会纳闷谁锁定了文件，什么时候，为什么。再一次，<command>svn info</command>拥有答案：</para>
        <screen>
$ svn info http://svn.example.com/repos/project/raisin.jpg
Path: raisin.jpg
Name: raisin.jpg
URL: http://svn.example.com/repos/project/raisin.jpg
Repository UUID: edb2f264-5ef2-0310-a47a-87b0ce17a8ec
Revision: 105
Node Kind: file
Last Changed Author: sally
Last Changed Rev: 32
Last Changed Date: 2006-01-25 12:43:04 -0600 (Sun, 25 Jan 2006)
Lock Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b
Lock Owner: harry
Lock Created: 2006-02-16 13:29:18 -0500 (Thu, 16 Feb 2006)
Lock Comment (1 line):
Need to make a quick tweak to this image.
$
</screen>
        <para>就像<command>svn info</command>可以检验工作拷贝的对象，它也可以检验版本库的对象，如果<command>svn info</command>的主要参数是工作拷贝路径，所有工作拷贝的缓存信息都会显示，发现了锁定就意味着工作拷贝拥有锁定令牌(如果一个文件被另一个用户在另一个工作拷贝锁定，工作拷贝路径上运行<command>svn info</command>不会显示锁定信息)。如果<command>svn info</command>的主参数是URL，就会反映版本库中最新版本的对象信息，任何对锁定的提及描述了当前对象的锁定。</para>
        <para>所以在这个特定的例子里，Sally可以看到Harry在二月十六日为了<quote>做修改</quote>而锁定了这个文件，现在已经六月了，她怀疑他可能是忘记了这个锁定，她会打电话给Harry去询问他应该释放这个锁定，如果他不再，她就要自己强制解除这个锁定或者是找管理员去做。</para>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.advanced.locking.break-steal">
        <info>
          <title>解除和偷窃锁定</title>
        </info>
        <para>版本库锁定并不是神圣不可侵犯的—在Subversion的缺省配置状态，不只是创建者可以释放锁定，任何人都可以。当有其他人期望消灭锁定时，我们称之为<firstterm>打破</firstterm>锁定。</para>
        <para>从管理员的位子上很容易打破锁定，<command>svnlook</command>和<command>svnadmin</command>程序都有能力从版本库直接显示和删除锁定。(关于这些工具的信息可以看<xref linkend="svn.reposadmin.maint.tk"/>。)</para>
        <screen>
$ svnadmin lslocks /var/svn/repos
Path: /project2/images/banana.jpg
UUID Token: opaquelocktoken:c32b4d88-e8fb-2310-abb3-153ff1236923
Owner: frank
Created: 2006-06-15 13:29:18 -0500 (Thu, 15 Jun 2006)
Expires: 
Comment (1 line):
Still improving the yellow color.

Path: /project/raisin.jpg
UUID Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b
Owner: harry
Created: 2006-02-16 13:29:18 -0500 (Thu, 16 Feb 2006)
Expires: 
Comment (1 line):
Need to make a quick tweak to this image.

$ svnadmin rmlocks /var/svn/repos /project/raisin.jpg
Removed lock on '/project/raisin.jpg'.
$
</screen>
        <para>更有趣的选项是允许用户互相打破锁定，为此，Sally只需要使用unlock命令的<option>--force</option>选项：</para>
        <screen>
$ svn status -u
M              23   bar.c
M    O         32   raisin.jpg
       *       72   foo.h
Status against revision:     105
$ svn unlock raisin.jpg
svn: 'raisin.jpg' is not locked in this working copy
$ svn info raisin.jpg | grep URL
URL: http://svn.example.com/repos/project/raisin.jpg
$ svn unlock http://svn.example.com/repos/project/raisin.jpg
svn: Unlock request failed: 403 Forbidden (http://svn.example.com)
$ svn unlock --force http://svn.example.com/repos/project/raisin.jpg
'raisin.jpg' unlocked.
$
</screen>
        <para>Sally初始的unlock命令失败了，因为她直接在自己的工作拷贝上运行了<command>svn unlock</command>，而这里没有锁定令牌。为了直接从版本库删除锁定，她需要给<command>svn unlock</command>传递URL参数，她的这一次尝试又失败了，因为她不是锁定的拥有者(也没有锁定令牌)。当她使用了<option>--force</option>选项后，认证和授权的要求被忽略了，远程的锁定被打破了。</para>
        <para>当然，简单的打破锁定也许还不够，在这个例子里，Sally不仅想要打破Harry遗忘的锁定，她也希望自己重新锁定。她可以通过运行<command>svn unlock --force</command>紧接着<command>svn lock</command>，但是有可能有人在这两次命令之间锁定了文件，最简单的方式是<firstterm>窃取</firstterm>这个锁定，将打破和重新锁定变成一种原子操作，为此需要运行<command>svn lock</command>加<option>--force</option>选项：</para>
        <screen>
$ svn lock raisin.jpg
svn: Lock request failed: 423 Locked (http://svn.example.com)
$ svn lock --force raisin.jpg
'raisin.jpg' locked by user 'sally'.
$
</screen>
        <para>在任何情况下，无论锁定被打破还是窃取，Harry都会感到惊讶。Harry的工作拷贝还保留有原来的锁定令牌，但是锁定已经不存在了，锁定令牌可以说已经<firstterm>死掉了</firstterm>。锁定令牌指代的锁定被打破(版本库中不再存在)或者是窃取了(被另一个锁定代替了)，任何一种情况下，Harry都可以使用<command>svn status</command>询问版本库：</para>
        <screen>
$ svn status
     K raisin.jpg
$ svn status -u
     B         32   raisin.jpg
$ svn update
  B  raisin.jpg
$ svn status
$
</screen>
        <para>如果版本库锁定被打破了，<command>svn status --show-updates</command>会在文件旁边显示一个<literal>B</literal> (Broken)。如果有一个新的锁，就会显示一个<literal>T</literal> (sTolen)符号。最终，<command>svn update</command>会注意到所有死掉的锁定并且把它们从工作拷贝中删除掉。</para>
        <sidebar>
          <info>
            <title>锁定策略</title>
          </info>
          <para>不同的系统有不同的锁定限制程度的观念。有些人认为锁定必须不顾任何代价的严格执行，只有原始的创建者和管理员可以释放。他们认为如果有人打破了锁定，混乱就会放任，锁定就完全失去了意义。另外一些人认为锁定是第一个和最首要的交流工具，如果用户经常的打破别人的锁定，代表了团队的文化失败和软件之外的问题。</para>
          <para>Subversion缺省是比较<quote>宽松的</quote>方式，但也允许管理员创建钩子脚本来建立严格的控制策略。具体来说，<filename>pre-lock</filename>和<filename>pre-unlock</filename>钩子允许管理员决定什么时候创建和释放锁定。根据锁定是否已经存在，这两个钩子脚本可以决定是否允许特定用户打破或窃取锁定。也有<filename>post-lock</filename>和<filename>post-unlock</filename>钩子，可以用来发送锁定动作的通知邮件。关于版本库钩子的更多信息可以看<xref linkend="svn.reposadmin.create.hooks"/>。</para>
        </sidebar>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.advanced.locking.lock-communication">
        <info>
          <title>锁定交流</title>
        </info>
        <para>我们已经见到了如何利用<command>svn lock</command>和<command>svn unlock</command>来创建、释放、打破和窃取锁定，这就满足了顺序访问文件的要求，但是浪费时间这个大问题该如何呢？</para>
        <para>例如，假定Harry锁定了一个图片，并开始编辑。同时，几英里之外的Sally希望做同样的工作，她没想到运行<command>svn status --show-updates</command>，她不知道Harry已经锁定了文件。她花费了数小时来修改文件，当她真被提交时发现文件已经被锁定或者是她的文件已经过期了。她的修改不能和Harry的合并，他们中的一人需要抛弃自己的工作，许多时间被浪费了。</para>
        <para>Subversion针对此问题的解决方案是提供一种机制，提醒用户在开始编辑<emphasis>以前</emphasis>必须锁定这个文件，这个机制就是提供一种特别的属性--<literal>svn:needs-lock</literal>。当有这个值时，<emphasis>除非</emphasis>用户锁定这个文件，否则文件一直是只读的。当得到一个锁定令牌(运行<command>svn lock</command>的结果)，文件变成可读写，当释放这个锁后，文件又变成只读。</para>
        <para>根据这个原理，如果一个图像文件有这个属性，Sally打开编辑文件就会立刻注意到有些特别，大多数程序会在打开只读文件时立刻警告，至少所有的程序会防止她保存修改，这提醒了她编辑之前需要锁定文件，这样她就发现了原来存在的锁定：</para>
        <screen>
$ /usr/local/bin/gimp raisin.jpg
gimp: error: file is read-only!
$ ls -l raisin.jpg
-r--r--r--   1 sally   sally   215589 Jun  8 19:23 raisin.jpg
$ svn lock raisin.jpg
svn: Lock request failed: 423 Locked (http://svn.example.com)
$ svn info http://svn.example.com/repos/project/raisin.jpg | grep Lock
Lock Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b
Lock Owner: harry
Lock Created: 2006-06-08 07:29:18 -0500 (Thu, 08 June 2006)
Lock Comment (1 line):
Making some tweaks.  Locking for the next two hours.
$
</screen>
        <tip>
          <para>我们鼓励用户和管理员都应该给不能根据上下文的文件添加<literal>svn:needs-lock</literal>属性，这是鼓励好的锁定习惯和防止浪费的主要技术手段。</para>
        </tip>
        <para>需要注意到这个属性是依赖于锁定系统的交流工具，不管是否有这个属性，文件都可以锁定。相反的，无论有没有这个属性，并不会要求提交需要首先锁定文件。</para>
        <para>这个系统并不是毫无瑕疵，即使有这个属性，只读提醒也有可能失效。有些程序<quote>偷偷的篡改了</quote>文件的只读属性，悄无声息的允许用户编辑和保存文件，不幸的是，Subversion对此无能为力—即使到了现今，还是没有任何工具能够代替人与人的良好交流。<footnote><para>除非是，或许一个经典的火神精神融合。</para></footnote></para>
      </section>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.advanced.externals">
      <info>
        <title>外部定义</title>
      </info>
      <para>有时候创建一个由多个不同检出得到的工作拷贝是非常有用的，举个例子，你或许希望不同的子目录来自不同的版本库位置，或者是不同的版本库。你可以手工设置这样一个工作拷贝—使用<command>svn checkout</command>来创建这种你需要的嵌套的工作拷贝结构。但是如果这个结构对所有的用户是很重要的，每个用户需要执行同样的检出操作。</para>
      <para>很幸运，Subversion提供了<firstterm>外部定义</firstterm>的支持，一个外部定义是一个本地路经到URL的影射—也有可能一个特定的修订版本—一些版本化的资源。在Subversion你可以使用<literal>svn:externals</literal>属性来定义外部定义，你可以用<command>svn propset</command>或<command>svn propedit</command>(见<xref linkend="svn.advanced.props.manip"/>)创建和修改这个属性。它可以设置到任何版本化的路经，它的值是一个多行的子目录，可选的修订版本标记和完全有效的Subversion版本库URL的列表(相对于设置属性的版本化目录)。</para>
      <para><literal>svn:externals</literal>的方便之处是这个属性设置到版本化的路径后，任何人可以从那个目录取出一个工作拷贝，同样得到外部定义的好处。换句话说，一旦一个人努力来定义这些嵌套的工作拷贝检出，其他任何人不需要再麻烦了—Subversion会在原先的工作拷贝检出之后，也会检出外部工作拷贝。</para>
      <warning>
        <para>外部定义的相对目标子目录不需要存在于你的或其它用户的系统中—Subversion会在检出工作拷贝时创建这些文件。实际上，你一定不要使用外部定义来产生已经在版本控制的路径。</para>
      </warning>
      <para>你也能够从外部定义设计得到所有普通Subversion属性所有的好处，定义是版本化的。如果你希望修改外部定义，你可以使用普通的属性修改子命令，当你提交一个<literal>svn:externals</literal>属性修改后，当你运行<command>svn update</command>时，Subversion会根据修改的外部定义同步检出的项目，同样的事情也会发生在别人更新他们的工作拷贝接受你的外部定义修改时。</para>
      <tip>
        <para>因为<literal>svn:externals</literal>的值是多行的，所以我们强烈建议使用<command>svn propedit</command>，而不是使用<command>svn propset</command>。</para>
      </tip>
      <para>Subversion releases prior to 1.5 honor an externals
      definition format that is a multiline table of subdirectories
      (relative to the versioned directory on which the property is
      set), optional revision flags, and fully qualified, absolute
      Subversion repository URLs.  An example of this might looks as
      follows:</para>
      <screen>
$ svn propget svn:externals calc
third-party/sounds             http://svn.example.com/repos/sounds
third-party/skins -r148        http://svn.example.com/skinproj
third-party/skins/toolkit -r21 http://svn.example.com/skin-maker
</screen>
      <para>注意前一个外部定义实例，当有人取出了一个<filename>calc</filename>目录的工作拷贝，Subversion会继续来取出外部定义的项目。</para>
      <screen>
$ svn checkout http://svn.example.com/repos/calc
A  calc
A  calc/Makefile
A  calc/integer.c
A  calc/button.c
Checked out revision 148.

Fetching external item into calc/third-party/sounds
A  calc/third-party/sounds/ding.ogg
A  calc/third-party/sounds/dong.ogg
A  calc/third-party/sounds/clang.ogg
…
A  calc/third-party/sounds/bang.ogg
A  calc/third-party/sounds/twang.ogg
Checked out revision 14.

Fetching external item into calc/third-party/skins
…
</screen>
      <para>As of Subversion 1.5, though, a new format of the
      <literal>svn:externals</literal> property is supported.
      Externals definitions are still multiline, but the order and
      format of the various pieces of information have changed.  The
      new syntax more closely mimics the order of arguments you might
      pass to <command>svn checkout</command>: the optional revision
      flags come first, then the external Subversion repository URL,
      and finally the relative local subdirectory.  Notice, though,
      that this time we didn't say <quote>fully qualified, absolute
      Subversion repository URLs.</quote> That's because the new
      format supports relative URLs and URLs that carry peg revisions.
      The previous example of an externals definition might, in
      Subversion 1.5, look like the following:</para>
      <screen>
$ svn propget svn:externals calc
      http://svn.example.com/repos/sounds third-party/sounds
-r148 http://svn.example.com/skinproj third-party/skins
-r21  http://svn.example.com/skin-maker third-party/skins/toolkit
</screen>
      <para>Or, making use of the peg revision syntax (which we describe
      in detail in <xref linkend="svn.advanced.pegrevs"/>), it might
      appear as:</para>
      <screen>
$ svn propget svn:externals calc
http://svn.example.com/repos/sounds third-party/sounds
http://svn.example.com/skinproj@148 third-party/skins
http://svn.example.com/skin-maker@21 third-party/skins/toolkit
</screen>
      <tip>
        <para>你一定要要慎重考虑在所有的外部定义中使用明确的修订版本，这样做意味着你已经决定了何时拖出外部信息不同的快照，和精确的拖出哪个快照。除了不会受到第三方版本库的意外修改的影响以外，当你的工作拷贝回溯到以前的版本库时，使用明确的修订版本号会让外部定义回到以前的那个修订版本，也意味着外部定义的工作拷贝更新会匹配以前修订版本的样子。对于软件项目，这可能是编译复杂代码基的老快照成功和失败的区别。</para>
      </tip>
      <para>对于大多数版本库，三种外部定义的格式都有相同的最终效果，它们都带来了同样的益处，不幸的是，它们也带来了同样的烦恼。因为定义本身使用绝对路径，移动和拷贝路径他们附着的路径不会影响他们作为外部的检出(尽管相对的本地目标子目录会这样，当然，根据重命名的目录改变)。在特定情形下这看起来有些迷惑—甚至让人沮丧。举个例子，你的顶级目录叫作<filename>my-project</filename>，你在它的子目录(<filename moreinfo="none">my-project/some-dir</filename>)创建了一个外部定义，而这个外部定义指向的是另一个子目录(<filename>my-project/external-dir</filename>)的最新版本。</para>
      <screen>
$ svn checkout http://svn.example.com/projects .
A    my-project
A    my-project/some-dir
A    my-project/external-dir
…
Fetching external item into 'my-project/some-dir/subdir'
Checked out external at revision 11.

Checked out revision 11.
$ svn propget svn:externals my-project/some-dir
subdir http://svn.example.com/projects/my-project/external-dir

$
</screen>
      <para>现在你使用<command>svn move</command>将目录<filename>my-project</filename>改名，此刻，你的外部定义还是指向<filename>my-project</filename>目录，即使这个目录已经不存在了。</para>
      <screen>
$ svn move -q my-project renamed-project
$ svn commit -m "Rename my-project to renamed-project."
Deleting       my-project
Adding         my-renamed-project

Committed revision 12.
$ svn update

Fetching external item into 'renamed-project/some-dir/subdir'
svn: Target path does not exist
$
</screen>
      <para>另外，如果版本库存在多种URL模式时，使用绝对URL来引用外部定义会导致问题。例如，如果你的Subversion服务器已经配置为任何用户可以使用<literal>http://</literal>或<literal>https://</literal>检出，但是只能通过<literal>https://</literal>提交，你现在有了一个很有趣的问题。如果你的外部定义使用<literal>http://</literal>形式，则你不能从这个工作拷贝提交任何内容。另一方面，如果他们使用<literal>https://</literal>方式的URL，任何因为不支持<literal>https://</literal>的客户端使用<literal>http://</literal>检出的工作拷贝不能得到外部项目。也需要意识到，如果你需要重定位你的工作拷贝(使用<command>svn switch --relocate</command>)，外部定义不会重新定位。</para>
      <para>Subversion 1.5 takes a huge step in relieving these
     frustrations.  As mentioned earlier, the URLs used in the new
     externals definition format can be relative, and Subversion
     provides syntax magic for specifying multiple flavors of URL
     relativity.</para>
      <variablelist>
        <varlistentry>
          <term>
            <literal>../</literal>
          </term>
          <listitem>
            <para>设置<literal>svn:externals</literal>属性的目录的相对URL。</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>^/</literal>
          </term>
          <listitem>
            <para>相对于<literal>svn:externals</literal>属性版本化的目录版本库的根。</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>//</literal>
          </term>
          <listitem>
            <para>设置<literal>svn:externals</literal>属性的目录的相对URL。</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>/</literal>
          </term>
          <listitem>
            <para>相对于<literal>svn:externals</literal>属性版本化的目录版本库的根。</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>So, looking a fourth time at our previous externals
      definition example, and making use of the new absolute URL
      syntax in various ways, we might now see:</para>
      <screen>
$ svn propget svn:externals calc
^/sounds third-party/sounds
/skinproj@148 third-party/skins
//svn.example.com/skin-maker@21 third-party/skins/toolkit
</screen>
      <para>Subversion目前对外部定义的支持还不够理想。首先，一个外部定义只可以指向目录，而不是文件。另外，一个定义的本地路径部分不能使用父目录指示符<literal>..</literal>(例如<filename>../../skins/myskin</filename>)。或许最令人失望的，通过外部定义创建的工作拷贝与主工作拷贝还是断开的(在实际设置<literal>svn:externals</literal>的版本化目录上)，Subversion会以不关联的工作拷贝操作。所以，举个例子，如果你希望提交一个或多个外部定义的拷贝，你必须在这些工作拷贝显示的运行<command>svn commit</command>—对主工作拷贝的提交不会迭代到外部定义的部分。</para>
      <para>We've already mentioned some of the additional shortcomings
      of the old <literal>svn:externals</literal> format and how the
      new Subversion 1.5 format improves upon it.  But be careful when
      making use of the new format that you don't inadvertently cause
      problems for other folks accessing your repository who are using
      older Subversion clients.  While Subversion 1.5 clients will
      continue to recognize and support the original externals
      definition format, older clients will <emphasis>not</emphasis>
      be able to correctly parse the new format.</para>
      <para>Besides the <command>svn checkout</command>, <command>svn
      update</command>, <command>svn switch</command>, and
      <command>svn export</command> commands which actually manage the
      <firstterm>disjoint</firstterm> (or disconnected) subdirectories
      into which externals are checked out, the <command>svn
      status</command> command also recognizes externals definitions.
      It displays a status code of <literal>X</literal> for the
      disjoint external subdirectories, and then recurses into those
      subdirectories to display the status of the external items
      themselves.  You can pass the
      <option>--ignore-externals</option> option to any of these
      subcommands to disable externals definition processing.</para>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.advanced.pegrevs">
      <info>
        <title>Peg 和实施修订版本</title>
      </info>
      <para>文件和目录的拷贝、改名和移动能力使你可以创建一个项目，然后删除它，然后在同一个位置添加一个新的—这是在我们的计算机中经常发生的操作，而你的版本控制系统不应该成为你这样操作的障碍。Subversion的文件管理操作是这样的开放，提供了几乎和普通文件一样的操作版本化文件的灵活性，但是灵活意味着在整个版本库的生命周期中，一个给定的版本化的资源可能会出现在许多不同的路径，一个给定的路径会展示给我们许多完全不同的版本化资源。当然这些功能也增加了你与这些路径和资源交互的难度。</para>
      <para>Subversion可以非常聪明的注意到一个对象的包括一个<quote>地址改变</quote>历史变化，举个例子，如果你询问一个曾经上周改过名的文件的所有的日志信息，Subversion会很高兴提供所有的日志—重命名发生的修订版本，外加相关版本之前和之后的修订版本日志，所以大多数时间里，你不需要考虑这些事情，但是偶尔，Subversion会需要你的帮助来清除混淆。</para>
      <para>这个最简单的例子发生在当一个目录或者文件从版本控制中删除时，然后一个新的同样名字目录或者文件添加到版本控制，显然你删除的和你后来添加的不是同样的东西，它们仅仅是有同样的路径，例如<filename>/trunk/object</filename>。什么，这意味着询问Subversion来查看<filename>/trunk/object</filename>的历史？你是询问当前这个位置的东西还是你在这个位置删除的那个对象？你是希望询问对这个对象的所有操作还是这个路径的所有对象？很明显，Subversion需要线索知道你真实的想法。</para>
      <para>由于移动，版本化对象的历史会变得非常扭曲。举个例子，你会有一个目录叫做<filename>concept</filename>，保存了一些你用来试验的初生的软件项目，最终，这个项目变得足够成熟，说明这个注意确实需要一些翅膀了，所以你决定给这个项目一个名字。 <footnote><para><quote>你不是被期望去命名它，一旦你取了名字，你开始与之联系在一起。</quote> — Mike Wazowski</para></footnote>假定你叫你的软件为Frabnaggilywort，此刻，把你的目录命名为反映项目名称的名字是有意义的，所以<filename>concept</filename>改名为<filename>frabnaggilywort</filename>。生活还在继续，Frabnaggilywort发布了1.0版本，并且被许多希望改进他们生活的分散用户天天使用。</para>
      <para>这是一个美好的故事，但是没有在这里结束，作为主办人，你一定想到了另一件事，所以你创建了一个目录叫做<filename>concept</filename>，周期重新开始。实际上，这个循环在几年里开始了多次，每一个想法从使用旧的<filename>concept</filename>目录开始，然后有时在想法成熟之后重新命名，有时你放弃了这个注意而删除了这个目录。或者更加变态一点，或许你把<filename>concept</filename>改成其他名字之后又因为一些原因重新改回<filename>concept</filename>。</para>
      <para>当这样的情景发生时，指导Subversion工作在重新使用的路径上的尝试就像指导一个芝加哥西郊的乘客驾车到东面的罗斯福路并且左转到主大道。仅仅20分钟，你可以穿过惠顿、格伦埃林何朗伯德的<quote>主大道</quote>，但是它们不是一样的街道，我们的乘客—和我们的Subversion—需要更多的细节来做正确的事情。</para>
      <para>在1.1版本，Subversion提供了一种方法来说明你所指是哪一个街道，叫做<firstterm>peg修订版本</firstterm>，通过这个修订版本我们可以唯一确定一条历史线路，因为一个版本化的文件会在任何时间占用某个路径—路径和peg修订版本的合并是可以指定一个历史的特定线路。Peg修订版本可以在Subversion命令行客户端中用<firstterm>at语法</firstterm>指定，之所以使用这个名称是因为会在关联的修订版本的路径后面追加一个<quote>at符号</quote>(<literal>@</literal>)。</para>
      <para>但是我们在本书多次提到的<option>--revision</option>(<option>-r</option>)到底是什么？修订版本(或者是修订版本集)叫做<firstterm>实施的修订版本</firstterm>(或者叫做<firstterm>实施的修订版本范围</firstterm>)，一旦一个特定历史线路通过一个路径和peg修订版本指定，Subversion会使用实施的修订版本执行要求的操作。类似的，为了指出这个到我们芝加哥的道路，如果我们被告知到惠顿主大道606号， <footnote><para>伊利诺伊州惠顿主大道606号市惠顿离市中心，让它作为惠顿的<quote>历史</quote>中心，看起来是恰当的…。</para></footnote> 我们可以把<quote>主大道</quote>看作路径，把<quote>惠顿</quote>当作我们的peg修订版本。这两段信息确认了我们可以旅行(主大道的北方或南方)的唯一路径，也会保持我们不会在前前后后寻找目标时走到错误的主大道。现在我们把<quote>606 N.</quote>作为我们实施的修订版本，我们<emphasis>精确的</emphasis>知道到哪里。</para>
      <sidebar>
        <info>
          <title>Peg 修订版本算法</title>
        </info>
        <para>Subversion命令行在解决路径和修订版本混淆时需要peg修订版本算法，这里是一个用以说明的例子：</para>
        <screen>
$ svn <replaceable>command</replaceable> -r <replaceable>OPERATIVE-REV</replaceable> item@<replaceable>PEG-REV</replaceable>
</screen>
        <para>如果<replaceable>OPERATIVE-REV</replaceable>比<replaceable>PEG-REV</replaceable>更老，则算法如下：</para>
        <orderedlist inheritnum="ignore" continuation="restarts">
          <listitem>
            <para>来到修订版本<replaceable>PEG-REV</replaceable>，找到<replaceable>item</replaceable>，在版本库定位到一个唯一的对象。</para>
          </listitem>
          <listitem>
            <para>追踪对象的历史背景(通过任何可能的改名)来到修订版本<replaceable>OPERATIVE-REV</replaceable>的祖先。</para>
          </listitem>
          <listitem>
            <para>对那个祖先执行请求的动作，无论它的位置，无论它是什么名字，无论当时是否存在。</para>
          </listitem>
        </orderedlist>
        <para>但是如果<replaceable>OPERATIVE-REV</replaceable>比<replaceable>PEG-REV</replaceable>更年轻时会怎么样？这为定位<replaceable>OPERATIVE-REV</replaceable>中的路径的理论问题增加了一些复杂性，因为在<replaceable>PEG-REV</replaceable>和<replaceable>OPERATIVE-REV</replaceable>之间，路径在历史中可以出现多次(由于拷贝操作)，而且那还不是全部—Subversion不会保存向前跟踪历史的足够信息，所以算法会有一点不同：</para>
        <orderedlist inheritnum="ignore" continuation="restarts">
          <listitem>
            <para>来到修订版本<replaceable>PEG-REV</replaceable>，找到<replaceable>item</replaceable>，在版本库定位到一个唯一的对象。</para>
          </listitem>
          <listitem>
            <para>追踪对象的历史背景(通过任何可能的改名)来到修订版本<replaceable>PEG-REV</replaceable>的祖先。</para>
          </listitem>
          <listitem>
            <para>在<replaceable>PEG-REV</replaceable>中检验对象的位置(顺序)与在<replaceable>OPERATIVE-REV</replaceable>中相同，如果那是问题，则至少两个位置是直接关联的，所以在<replaceable>OPERATIVE-REV</replaceable>的位置执行请求动作。否则，关联没有建立，所以会报告没有可用位置的错误。(有一天，我们希望Subversion可以更灵活和优雅的处理这种场景。)</para>
          </listitem>
        </orderedlist>
        <para>注意，即使你没有明确提供peg修订版本或操作修订版本，他们依然是存在的。为了使用的简便，对于工作拷贝项目的缺省peg修订版本是<literal>BASE</literal>，而版本库URL的缺省值是<literal>HEAD</literal>。当没有提供操作修订版本时，缺省是与peg修订版本一样。</para>
      </sidebar>
      <para>也就是说很久以前我们创建了我们的版本库，在修订版本1添加我们第一个<filename>concept</filename>目录，并且在这个目录增加一个<filename>IDEA</filename>文件与concept相关，在几个修订版本之后，真实的代码被添加和修改，我们在修订版本20，修改这个目录为<filename>frabnaggilywort</filename>。通过修订版本27，我们有了一个新的概念，所以一个新的<filename>concept</filename>目录用来保存这些东西，一个新的<filename>IDEA</filename>文件来描述这个概念，然后经过5年20000个修订版本，就像他们都有一个非常浪漫的历史。</para>
      <para>现在，一年之后，我们想知道<filename>IDEA</filename>在修订版本1时是什么样子，但是Subversion需要知道我们是想询问<emphasis>当前</emphasis>文件在修订版本1时的样子，还是希望知道<filename>concepts/IDEA</filename>在修订版本1时的那个文件？确定这些问题有不同的答案，并且因为peg修订版本，你可以用两种方式询问。为了知道当前的<filename>IDEA</filename>文件在旧版本的样子，我们可以运行：</para>
      <screen>
$ svn cat -r 1 concept/IDEA 
svn: Unable to find repository location for 'concept/IDEA' in revision 1
</screen>
      <para>当然，在这个例子里，当前的<filename>IDEA</filename>文件在修订版本1中并不存在，所以Subversion给出一个错误，这个上面的命令是长的peg修订版本命令一个缩写，扩展的写法是：</para>
      <screen>
$ svn cat -r 1 concept/IDEA@BASE
svn: Unable to find repository location for 'concept/IDEA' in revision 1
</screen>
      <para>当执行时，它包含期望的结果。</para>
      <para>如果工作拷贝路径或URL中确实有一个at记号，peg修订版本语法是否会导致问题？深刻理解的读者可能会产生这样的疑问。毕竟，<command>svn</command>是如何知道<literal>news@11</literal>是我的目录树中的一个目录，还是修订版本11的<filename>news</filename>文件？幸好，<command>svn</command>会一直假定后者。你只需要在路径最后添加一个at符号，例如<literal>news@11@</literal>，<command>svn</command>只关心最后一个at标记，如果遗漏了最后的修订版本号，不会认为不合法。这个法则甚至可以应用到以at结尾的路径—你可以使用<literal>filename@@</literal>来引用<filename>filename@</filename>。</para>
      <para>然后让我们询问另一个问题—在修订版本1 ，占据<filename>concepts/IDEA</filename>路径的文件的内容到底是什么？我们会使用一个明确的peg修订版本来帮助我们完成。</para>
      <screen>
$ svn cat concept/IDEA@1
The idea behind this project is to come up with a piece of software
that can frab a naggily wort.  Frabbing naggily worts is tricky
business, and doing it incorrectly can have serious ramifications, so
we need to employ over-the-top input validation and data verification
mechanisms.
</screen>
      <para>注意我们这一次没有提供操作修订版本，那是因为如果没有指定操作修订版本，Subversion假定缺省的操作修订版本是peg修订版本。</para>
      <para>正像你看到的，这看起来是正确的输出，这些文本甚至提到“frabbing naggily worts”，所以这就是现在叫做Frabnaggilywort项目的那个文件，实际上，我们可以使用显示的peg修订版本和实施修订版本的组合核实这一点。我们知道在<literal>HEAD</literal>，Frabnaggilywort项目坐落在<filename>frabnaggilywort</filename>目录，所以我们指定我们希望看到<literal>HEAD</literal>的<filename>frabnaggilywort/IDEA</filename>路经在历史上的修订版本1的内容。</para>
      <screen>
$ svn cat -r 1 frabnaggilywort/IDEA@HEAD
The idea behind this project is to come up with a piece of software
that can frab a naggily wort.  Frabbing naggily worts is tricky
business, and doing it incorrectly can have serious ramifications, so
we need to employ over-the-top input validation and data verification
mechanisms.
</screen>
      <para>而且peg修订版本和实施修订版本也不需要这样琐碎，举个例子，我们的<filename>frabnaggilywort</filename>已经在<literal>HEAD</literal>删除，但我们知道在修订版本20它是存在的，我们希望知道<filename>IDEA</filename>从修订版本4到10的区别，我们可以使用peg修订版本20和<filename>IDEA</filename>文件的修订版本20的URL的组合，然后使用4到10作为我们的实施修订版本范围。</para>
      <screen>
$ svn diff -r 4:10 http://svn.red-bean.com/projects/frabnaggilywort/IDEA@20
Index: frabnaggilywort/IDEA
===================================================================
--- frabnaggilywort/IDEA	(revision 4)
+++ frabnaggilywort/IDEA	(revision 10)
@@ -1,5 +1,5 @@
-The idea behind this project is to come up with a piece of software
-that can frab a naggily wort.  Frabbing naggily worts is tricky
-business, and doing it incorrectly can have serious ramifications, so
-we need to employ over-the-top input validation and data verification
-mechanisms.
+The idea behind this project is to come up with a piece of
+client-server software that can remotely frab a naggily wort.
+Frabbing naggily worts is tricky business, and doing it incorrectly
+can have serious ramifications, so we need to employ over-the-top
+input validation and data verification mechanisms.
</screen>
      <para>幸运的是，几乎所有的人不会面临如此复杂的情形，但是如果是，记住peg修订版本是帮助Subversion清除混淆的额外提示。</para>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.advanced.changelists">
      <info>
        <title>修改列表</title>
      </info>
      <para>It is commonplace for a developer to find himself working at
      any given time on multiple different, distinct changes to a
      particular bit of source code.  This isn't necessarily due to
      poor planning or some form of digital masochism.  A software
      engineer often spots bugs in his peripheral vision while working
      on some nearby chunk of source code.  Or perhaps he's halfway
      through some large change when he realizes the solution he's
      working on is best committed as several smaller logical units.
      Often, these logical units aren't nicely contained in some
      module, safely separated from other changes.  The units might
      overlap, modifying different files in the same module, or even
      modifying different lines in the same file.</para>
      <para>Developers can employ various work methodologies
      to keep these logical changes organized.  Some use
      separate working copies of the same repository to hold each
      individual change in progress.  Others might choose to create
      short-lived feature branches in the repository and use a single
      working copy that is constantly switched to point to one such
      branch or another.  Still others use <command>diff</command> and
      <command>patch</command> tools to back up and restore uncommitted
      changes to and from patch files associated with each change.
      Each of these methods has its pros and cons, and to a large
      degree, the details of the changes being made heavily influence
      the methodology used to distinguish them.</para>
      <para>Subversion 1.5 brings a new
      <firstterm>changelists</firstterm> feature that adds yet
      another method to the mix.  Changelists are basically arbitrary
      labels (currently at most one per file) applied to working copy files for the express purpose of
      associating multiple files together.  Users of many of Google's
      software offerings are familiar with this concept already.  For
      example, <link href="http://mail.google.com/">Gmail</link>
      doesn't provide the traditional folders-based email organization
      mechanism.  In Gmail, you apply arbitrary labels to emails, and
      multiple emails can be said to be part of the same group if they
      happen to share a particular label.  Viewing only a group of
      similarly labeled emails then becomes a simple user interface
      trick.  Many other Web 2.0 sites have similar
      mechanisms—consider the <quote>tags</quote> used by sites
      such as <link href="http://www.youtube.com/">YouTube</link> and
      <link href="http://www.flickr.com/">Flickr</link>,
      <quote>categories</quote> applied to blog posts, and so on.
      Folks understand today that organization of data is critical,
      but that how that data is organized needs to be a flexible
      concept.  The old files-and-folders paradigm is too rigid for
      some applications.</para>
      <para>Subversion's changelist support allows you to create
      changelists by applying labels to files you want to be
      associated with that changelist, remove those labels, and limit
      the scope of the files on which its subcommands operate to only
      those bearing a particular label.  In this section, we'll look
      in detail at how to do these things.</para>
      <!-- =============================================================== -->
      <section xml:id="svn.advanced.changelists.creating">
        <info>
          <title>创建和更新修改列表</title>
        </info>
        <para>You can create, modify, and delete changelists using the
        <command>svn changelist</command> command.  More accurately,
        you use this command to set or unset the changelist
        association of a particular working copy file.  A changelist
        is effectively created the first time you label a file with
        that changelist; it is deleted when you remove that label from
        the last file that had it.  Let's examine a usage scenario
        that demonstrates these concepts.</para>
        <para>Harry is fixing some bugs in the calculator application's
        mathematics logic.  His work leads him to change a couple of
        files:</para>
        <screen>
$ svn status
M      integer.c
M      mathops.c
$
</screen>
        <para>While testing his bug fix, Harry notices that his changes
        bring to light a tangentially related bug in the user
        interface logic found in <filename>button.c</filename>.  Harry
        decides that he'll go ahead and fix that bug, too, as a
        separate commit from his math fixes.  Now, in a small working
        copy with only a handful of files and few logical changes,
        Harry can probably keep his two logical change groupings
        mentally organized without any problem.  But today he's going
        to use Subversion's changelists feature as a special favor to
        the authors of this book.</para>
        <para>Harry first creates a changelist and associates with it
        the two files he's already changed.  He does this by using the
        <command>svn changelist</command> command to assign the same
        arbitrary changelist name to those files:</para>
        <screen>
$ svn changelist math-fixes integer.c mathops.c
Path 'integer.c' is now a member of changelist 'math-fixes'.
Path 'mathops.c' is now a member of changelist 'math-fixes'.
$ svn status

--- Changelist 'math-fixes':
M      integer.c
M      mathops.c
$
</screen>
        <para>就像你看到的，你的<command>svn status</command>反映了新的分组。</para>
        <para>Harry now sets off to fix the secondary UI problem.  Since
        he knows which file he'll be changing, he assigns that path to
        a changelist, too.  Unfortunately, Harry carelessly assigns this
        third file to the same changelist as the previous two files:</para>
        <screen>
$ svn changelist math-fixes button.c
Path 'button.c' is now a member of changelist 'math-fixes'.
$ svn status

--- Changelist 'math-fixes':
       button.c
M      integer.c
M      mathops.c
$
</screen>
        <para>Fortunately, Harry catches his mistake.  At this point, he
        has two options.  He can remove the changelist association
        from <filename>button.c</filename>, and then assign a
        different changelist name:</para>
        <screen>
$ svn changelist --remove button.c
Path 'button.c' is no longer a member of a changelist.
$ svn changelist ui-fix button.c
Path 'button.c' is now a member of changelist 'ui-fix'.
$
</screen>
        <para>Or, he can skip the removal and just assign a new
        changelist name.  In this case, Subversion will first warn
        Harry that <filename>button.c</filename> is being removed from
        the first changelist:</para>
        <screen>
$ svn changelist ui-fix button.c
svn: warning: Removing 'button.c' from changelist 'math-fixes'.
Path 'button.c' is now a member of changelist 'ui-fix'.
$ svn status

--- Changelist 'ui-fix':
       button.c

--- Changelist 'math-fixes':
M      integer.c
M      mathops.c
$
</screen>
        <para>Harry now has two distinct changelists present in his
        working copy, and <command>svn status</command> will group its
        output according to these changelist determinations.  Notice
        that even though Harry hasn't yet modified
        <filename>button.c</filename>, it still shows up in the output
        of <command>svn status</command> as interesting because it has
        a changelist assignment.  Changelists can be added to and
        removed from files at any time, regardless of whether they
        contain local modifications.</para>
        <para>Harry now fixes the user interface problem in
        <filename>button.c</filename>.</para>
        <screen>
$ svn status

--- Changelist 'ui-fix':
M      button.c

--- Changelist 'math-fixes':
M      integer.c
M      mathops.c
$
</screen>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.advanced.changelists.asfilters">
        <info>
          <title>用修改列表作为操作过滤器</title>
        </info>
        <para>The visual grouping that Harry sees in the output of
        <command>svn status</command> as shown in our previous section
        is nice, but not entirely useful.  The
        <command>status</command> command is but one of many
        operations that he might wish to perform on his working copy.
        Fortunately, many of Subversion's other operations understand
        how to operate on changelists via the use of the
        <option>--changelist</option> option.</para>
        <para>When provided with a <option>--changelist</option> option,
        Subversion commands will limit the scope of their operation to
        only those files to which a particular changelist name is
        assigned.  If Harry now wants to see the actual changes he's
        made to the files in his <literal>math-fixes</literal>
        changelist, he <emphasis>could</emphasis> explicitly list only
        the files that make up that changelist on the <command>svn
        diff</command> command line.</para>
        <screen>
$ svn diff integer.c mathops.c
Index: integer.c
===================================================================
--- integer.c	(revision 1157)
+++ integer.c	(working copy)
…
Index: mathops.c
===================================================================
--- mathops.c	(revision 1157)
+++ mathops.c	(working copy)
…
$
</screen>
        <para>That works okay for a few files, but what if Harry's
        change touched 20 or 30 files?  That would be an annoyingly
        long list of explicitly named files.  Now that he's using
        changelists, though, Harry can avoid explicitly listing the
        set of files in his changelist from now on, and instead
        provide just the changelist name:</para>
        <screen>
$ svn diff --changelist math-fixes
Index: integer.c
===================================================================
--- integer.c	(revision 1157)
+++ integer.c	(working copy)
…
Index: mathops.c
===================================================================
--- mathops.c	(revision 1157)
+++ mathops.c	(working copy)
…
$
</screen>
        <para>And when it's time to commit, Harry can again use the
        <option>--changelist</option> option to limit the scope of the
        commit to files in a certain changelist.  He might commit his
        user interface fix by doing the following:</para>
        <screen>
$ svn ci -m "Fix a UI bug found while working on math logic." \
      --changelist ui-fix
Sending        button.c
Transmitting file data .
Committed revision 1158.
$
</screen>
        <para>In fact, the <command>svn commit</command> command
        provides a second changelists-related option:
        <option>--keep-changelists</option>.  Normally, changelist
        assignments are removed from files after they are committed.
        But if <option>--keep-changelists</option> is provided,
        Subversion will leave the changelist assignment on the
        committed (and now unmodified) files.  In any case, committing
        files assigned to one changelist leaves other changelists
        undisturbed.</para>
        <screen>
$ svn status

--- Changelist 'math-fixes':
M      integer.c
M      mathops.c
$
</screen>
        <note>
          <para>The <option>--changelist</option> option acts only as a
          filter for Subversion command targets, and will not add
          targets to an operation.  For example, on a commit operation
          specified as <userinput>svn commit /path/to/dir</userinput>, the
          target is the directory <filename>/path/to/dir</filename>
          and its children (to infinite depth).  If you then add a
          changelist specifier to that command, only those files in
          and under <filename>/path/to/dir</filename> that are
          assigned that changelist name will be considered as targets
          of the commit—the commit will not include files
          located elsewhere (such is in
          <filename>/path/to/another-dir</filename>), regardless of
          their changelist assignment, even if they are part of the
          same working copy as the operation's target(s).</para>
        </note>
        <para>Even the <command>svn changelist</command> command accepts
        the <option>--changelist</option> option.  This allows you to
        quickly and easily rename or remove a changelist:</para>
        <screen>
$ svn changelist math-bugs --changelist math-fixes --depth infinity .
svn: warning: Removing 'integer.c' from changelist 'math-fixes'.
Path 'integer.c' is now a member of changelist 'math-bugs'.
svn: warning: Removing 'mathops.c' from changelist 'math-fixes'.
Path 'mathops.c' is now a member of changelist 'math-bugs'.
$ svn changelist --remove --changelist math-bugs --depth infinity .
Path 'integer.c' is no longer a member of a changelist.
Path 'mathops.c' is no longer a member of a changelist.
$
</screen>
        <para>Finally, you can specify multiple instances of the
        <option>--changelist</option> option on a single command
        line.  Doing so limits the operation you are performing to
        files found in any of the specified changesets.</para>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.advanced.changelists.limitations">
        <info>
          <title>修改列表的限制</title>
        </info>
        <para>Subversion's changelist feature is a handy tool for
        grouping working copy files, but it does have a few limitations.
        Changelists are artifacts of a particular working copy, which
        means that changelist assignments cannot be propagated to the
        repository or otherwise shared with other users.  Changelists
        can be assigned only to files—Subversion doesn't
        currently support the use of changelists with directories.
        Finally, you can have at most one changelist assignment on a
        given working copy file.  Here is where the blog post category
        and photo service tag analogies break down—if you find
        yourself needing to assign a file to multiple changelists,
        you're out of luck.</para>
      </section>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.serverconfig.netmodel">
      <info>
        <title>网络模型</title>
      </info>
      <para>在某些情况下，你需要理解Subversion客户端如何与服务器通讯。Subversion网络层是抽象的，意味着Subversion客户端不管其操作的对象都会使用相同的行为方式，不管是使用HTTP协议(<literal>http://</literal>)与Apache HTTP服务器通讯或是使用自定义Subversion协议(<literal>svn://</literal>)与<command>svnserve</command>通讯，基本的网络模型是相同的。在本小节，我们要解释网络模型基础，包括Subversion如何管理认证和授权信息。</para>
      <!-- =============================================================== -->
      <section xml:id="svn.serverconfig.netmodel.reqresp">
        <info>
          <title>请求和响应</title>
        </info>
        <para>Subversion客户端花费大量的时间来管理工作拷贝，当它需要远程版本库的信息，它会做一个网络请求，然后服务器给一个恰当的回答，具体的网络协议细节对用户不可见，客户端尝试去访问一个URL，根据URL模式的不同，会使用特定的协议与服务器联系(见<xref linkend="svn.basic.in-action.wc.sb-1"/>)。</para>
        <tip>
          <para>用户可以运行<command>svn --version</command>来查看客户端可以使用的URL模式和协议。</para>
        </tip>
        <para>当服务器处理一个客户端请求，它通常会要求客户端确定它自己的身份，它会发出一个认证请求给客户端，而客户端通过提供<firstterm>凭证</firstterm>给服务器作为响应，一旦认证结束，服务器会响应客户端最初请求的信息。注意这个系统与CVS之类的系统不一样，它们会在请求之前，预先提供凭证(<quote>logs in</quote>)给服务器，在Subversion里，服务器通过请求客户端适时地<quote>拖入</quote>凭证，而不是客户端<quote>推</quote>出，这使得这种操作更加的优雅。例如，如果一个服务器配置为世界上的任何人都可以读取版本库，在客户使用<command>svn checkout</command>时，服务器永远不会发起一个认证请求。</para>
        <para>如果客户端的请求会在版本库创建新的修订版本(例如<command>svn commit</command>)，Subversion就会使用认证过的用户名作为此次提交的作者。也就是说经过认证的用户名作为<literal>svn:author</literal>属性的值保存到新的修订本里(见<xref linkend="svn.ref.properties"/>)。如果客户端没有经过认证(换句话说，服务器没有发起过认证请求)，这时修订本的<literal>svn:author</literal>的值是空的。</para>
      </section>
      <!-- =============================================================== -->
      <section xml:id="svn.serverconfig.netmodel.credcache">
        <info>
          <title>客户端凭证缓存</title>
        </info>
        <para>许多服务器配置为每次请求要求认证，对被强制每次输入用户名密码，许多用户会感到很讨厌。幸运的是，Subversion客户端对此有一个修补—存在一个在磁盘上保存认证凭证缓存的系统，缺省情况下，当一个命令行客户端成功的响应了服务器的认证请求，它会保存一个认证文件到用户的私有运行配置区(类Unix系统下会在<filename>~/.subversion/auth/</filename>，Windows下在<filename>%APPDATA%/Subversion/auth/</filename>，运行配置系统在<xref linkend="svn.advanced.confarea"/>会有更多细节描述)。成功的凭证会缓存在磁盘，以主机名、端口和认证域的组合作为唯一性区别。</para>
        <para>当客户端接收到一个认证请求，它会首先查找用户磁盘中的认证凭证缓存，如果没有发现，或者是缓存的凭证认证失败，客户端会提示用户提供需要的信息。</para>
        <para>十分关心安全的人们一定会想<quote>把密码缓存在磁盘？太可怕了，永远不要这样做！</quote></para>
        <para>Subversion开发者认识到这种关注的正确性，所以Subversion使用操作系统和环境提供的机制来减少泄露这些信息的风险，下面是在大多数平台上这种含义的列表：</para>
        <itemizedlist>
          <listitem>
            <para>在Windows 2000或更新的系统上，Subversion客户端使用标准Windows加密服务来加密磁盘上的密码。因为加密密钥是Windows管理的，与用户的登陆凭证相关，只有用户可以解密密码。(注意：如果用户的Windows账户密码被管理员重置，所有的缓存密码就不可以解密了，此时Subversion客户端就会当它们根本不存在，在需要时继续询问密码。)</para>
          </listitem>
          <listitem>
            <para>类似的，在Mac OS X，Subversion客户端在登陆keyring(使用Keychain管理)保存了所有的版本库密码，使用户用帐号密码保护。用户选择的设置可以强加额外的政策，例如在需要用户密码时要求输入用户帐号密码。</para>
          </listitem>
          <listitem>
            <para>对于其他类Unix系统，没有标准的加密服务。然而<filename>auth/</filename>缓存区只有用户(拥有者)可以访问，而不是全世界都可以，操作系统的访问许可可以保护密码文件。</para>
          </listitem>
        </itemizedlist>
        <para>当然，对于真正的妄想狂，没有任何机制是完美的。这类人希望用无限的安全来牺牲便利性，Subversion提供了各种方法来完全关闭凭证缓存。</para>
        <para>你可以关闭凭证缓存，只需要一个简单的命令，使用参数<option>--no-auth-cache</option>：</para>
        <screen>
$ svn commit -F log_msg.txt --no-auth-cache
Authentication realm: &lt;svn://host.example.com:3690&gt; example realm
Username:  joe
Password for 'joe':

Adding         newfile
Transmitting file data .
Committed revision 2324.

# password was not cached, so a second commit still prompts us

$ svn delete newfile
$ svn commit -F new_msg.txt
Authentication realm: &lt;svn://host.example.com:3690&gt; example realm
Username:  joe
…
</screen>
        <para>或许，你希望永远关闭凭证缓存，你可以编辑你的运行运行配置区的<filename>config</filename>文件，只需要把<literal>store-auth-creds</literal>设置为<literal>no</literal>，这样在影响的主机上的Subversion操作就不会有凭证缓存在磁盘。通过修改系统级的运行配置区，这个功能也会影响到本机的所有用户(详细内容见<xref linkend="svn.advanced.confarea.layout"/>)。</para>
        <screen>
[auth]
store-auth-creds = no
</screen>
        <para>有时候，用户希望从磁盘缓存删除特定的凭证，为此你可以浏览到<filename>auth/</filename>区域，删除特定的缓存文件，凭证都是作为一个单独的文件缓存，如果你打开每一个文件，你会看到键和值，<literal>svn:realmstring</literal>描述了这个文件关联的特定服务器的域：</para>
        <screen>
$ ls ~/.subversion/auth/svn.simple/
5671adf2865e267db74f09ba6f872c28
3893ed123b39500bca8a0b382839198e
5c3c22968347b390f349ff340196ed39

$ cat ~/.subversion/auth/svn.simple/5671adf2865e267db74f09ba6f872c28

K 8
username
V 3
joe
K 8
password
V 4
blah
K 15
svn:realmstring
V 45
&lt;https://svn.domain.com:443&gt; Joe's repository
END
</screen>
        <para>一旦你定位了正确的缓存文件，只需要删除它。</para>
        <para><command>svn</command>认证的行为的最后一点，对使用<option>--username</option>和<option>--password</option>选项的一点说明，许多客户端和子命令接受这个选项，但是要明白使用这个选项<emphasis>不会</emphasis>主动地发送凭证信息到服务器，就像前面讨论过的，服务器会在需要的时候才会从客户端<quote>拖</quote>入凭证，客户端不会随意<quote>推</quote>出。如果一个用户名和/或密码作为选项传入，它们<emphasis>只会</emphasis>在服务器需要时才展现给服务器。通常，只有在使用非缺省用户(例如系统登陆名)进行认证，或者是为了防止交互式输入(例如在脚本里调用<command>svn</command>)时，才会使用这些选项。</para>
        <note>
          <para>再次重申，一个常见的错误是把服务器配置为从不会请求认证，当用户传递<option>--username</option>和<option>--password</option>给客户端时，他们惊奇的发现它们没有被使用，如新的修订版本看起来始终是由匿名用户提交的！</para>
        </note>
        <para>这里是Subversion客户端在收到认证请求的时候的行为方式最终总结：</para>
        <orderedlist inheritnum="ignore" continuation="restarts">
          <listitem>
            <para>首先，检查用户是否通过命令选项(<option>--username</option>和/或<option>--password</option>)指定了任何凭证信息，如果没有，或者这些选项没有认证成功，然后</para>
          </listitem>
          <listitem>
            <para>如果没有提供命令行凭证，或提供的是错误的，则客户端会查找运行中的<filename>auth/</filename>区域保存的服务器名，端口和认证域信息，来确定用户是否已经有了恰当的认证缓存，如果有，它会使用这些凭证进行认证。</para>
          </listitem>
          <listitem>
            <para>最终，如果前一种机制未能够为服务器成功认证用户，客户端返回并提示用户输入正确的凭证(除非使用<option>--non-interactive</option>选项或客户端对等的方式)。</para>
          </listitem>
        </orderedlist>
        <para>如果客户端通过以上的任何一种方式成功认证，它会尝试在磁盘缓存凭证(除非用户已经关闭了这种行为方式，在前面提到过。)</para>
      </section>
    </section>
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <!-- ================================================================= -->
    <section xml:id="svn.advanced.summary">
      <info>
        <title>总结</title>
      </info>
      <para>After reading this chapter, you should have a firm grasp on
      some of Subversion's features that, while perhaps not used
      <emphasis>every</emphasis> time you interact with your version
      control system, are certainly handy to know about.  But don't
      stop here!  Read on to the following chapter, where you'll learn
      about branches, tags, and merging.  Then you'll have nearly full
      mastery of the Subversion client.  Though our lawyers won't
      allow us to promise you anything, this additional knowledge
      could make you measurably more cool.
      <footnote><para>No purchase necessary.  Certains terms and conditions
          apply.  No guarantee of coolness—implicit or 
          otherwise—exists.  Mileage may vary.</para></footnote>
    </para>
    </section>
  </chapter>
  <!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->